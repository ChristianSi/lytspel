#!/usr/bin/perl -CA
# Split compound words and derived forms in 'phonetic-dict.txt' into their
# likely parts.
#
# Copyright (c) 2015 Christian Siefkes
# See accompanying LICENSE file for licensing information.
#
# Parts of the code are based on
# https://squarecog.wordpress.com/2008/10/19/splitting-words-joined-into-a-single-string/
#
# Required modules: Data::Munge, Const::Fast and those listed in PhonEng.pm.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Cwd 'abs_path';
use Data::Munge;
use File::Basename 'dirname';
use Const::Fast;

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

const my $IN_FILE  => 'phonetic-dict.txt';
const my $OUT_FILE => 'phonetic-dict-candidates.csv';

# Special markers used in %$candidate_parts
const my $WORD   => '_WORD';
const my $PREFIX => '_PREFIX';
const my $SUFFIX => '_SUFFIX';

my $CSV = new_csv_out;

# read_dict: Reads the original phonetic dict into a hash. Returns a mapping
# from words (e.g. 'yeld', 'hectometre', 'detail') to the corresponding raw
# values (e.g. ': ye°ld', ':> hectometer', '/n: di°täl; v: ditä°l').
sub read_dict {
    open my $file, '<', $IN_FILE or die "Unable to open $IN_FILE: $!";
    my %dict;

    while (my $line = <$file>) {
        $line =~ m{^(['\w]+)([:/].*)$} or die "Invalid line: $line";
        my $word = $1;
        my $value = $2;
        # Only add words with two or more letters as well as 'a'
        $dict{$word} = $value if length $word > 1 || $word eq 'a';
    }

    close $file;
    return \%dict;
}

# redirect_target $value: Resolves the redirect if $value is a redirect.
# Returns undef otherwise.
sub redirect_target {
    my ($value) = @_;
    return $value =~ /^:>\s+(.*)$/ ? $1 : undef;
}

# is_variant $entry: Check whether $entry is a variant target. Variant targets start with ':'.
sub is_variant {
    my ($entry) = @_;
    return $entry =~ /^:/;
}

# add_variant_if_new_or_shorter $variant, $variant_target, $hashref:
# Add a $variant_target to $hashref if no entry for $variant exists so far or if the old
# entry is an alternative variant target that is longer than the new one.
# For example, 'grippe' is replaced by 'grip' as variant target for 'gripp'.
sub add_variant_if_new_or_shorter {
    my ($variant, $variant_target, $hashref) = @_;
    my $old_entry = $hashref->{$variant};
    # Variant targets are prefixed by ':'
    $hashref->{$variant} = ":$variant_target" if (not defined $old_entry) ||
        (is_variant ($old_entry) && length $old_entry > 1 + length $variant);
}

# add_entries_from_file: $filename, $value, $hashref, $force, $skiplist: Reads lines from
# $filename and adds each of them to as key to $hashref. If $force is true, any existing
# value is overwritten. Otherwise existing values are only overwritten if they are
# autogenerated variants. Entries listed in the $skiplist array are skipped altogether.
# The value of each newly added entry is set to $value.
sub add_entries_from_file {
    my ($filename, $value, $hashref, $force, $skiplist) = @_;
    open my $file, '<', $filename or die "Unable to open $filename: $!";

    while (my $line = <$file>) {
        chomp $line;
        next if elem $line, $skiplist;
        my $oldval = $hashref->{$line};
        $hashref->{$line} = $value if $force || !(defined $oldval && $oldval !~ /^:/);
    }

    close $file;
}

# is_consonant $letter: Returns a true value if $letter is a single consonant,
# a false value otherwise.
sub is_consonant {
    my ($letter) = @_;
    return length $letter == 1 && index('bcdfghjklmnpqrstvwxyz', $letter) >= 0;
}

# is_vowel $letter: Returns a true value if $letter is a single vowel,
# a false value otherwise.
sub is_vowel {
    my ($letter) = @_;
    return length $letter == 1 && index('aeiou', $letter) >= 0;
}

# find_variant $word: Returns a variant of $word that may be used in
# compounds. The following variants are considered, provided that at least
# two characters remain:
#
# * Final 'e' after a consonant is dropped, e.g. 'judg' from 'judge'
# * Final 'y' after a consonant becomes 'i', e.g. 'happi' from 'happy'
# * A final consonant (excluding 'y') is doubled, e.g. 'acquitt' from 'acquit'
#
# Otherwise undef is returned.
sub find_variant {
    my ($word) = @_;
    my $last_char = substr $word, -1;
    my $result = undef;

    if ($last_char eq 'e' || $last_char eq 'y') {
        chop $word;
        my $next_to_last_char = substr $word, -1;

        if (!is_vowel $next_to_last_char) {
            $result = $word;
            $result .= 'i' if $last_char eq 'y';
        }
    } elsif (is_consonant $last_char) {
        $result = $word . $last_char;
    }

    $result = undef if (defined $result && length $result < 2);
    return $result;
}

# find_candidate_parts $dict: Build hash of candidate word parts.
# Add words with 2 or more letters are added to the hash, as well as all
# entries listed in 'prefix.list' and 'suffix.list'.
sub find_candidate_parts {
    my ($dict) = @_;
    my %candidate_parts;

    while (my ($word, $value) = each %$dict) {
        next if length $word <= 1; # skip single-letter entries
        my $redirect_target = redirect_target $value;
        my $kind = $redirect_target // $WORD;
        $candidate_parts{$word} = $kind;
        my $variant = find_variant $word;
        add_variant_if_new_or_shorter $variant, $redirect_target // $word,  \%candidate_parts
            if $variant;
    }

    my $hashref = \%candidate_parts;
    # If a word is listed as suffix and as regular word, we treat it as suffix -- except "ant"
    add_entries_from_file 'suffix.list', $SUFFIX, $hashref, 1, ["ant"];
    add_entries_from_file 'prefix.list', $PREFIX, $hashref, 0, [];
    return $hashref;
}

# open_outfile_and_write_header: Opens output file in CSV format and writes
# the header file. Returns the opened file handle.
sub open_outfile_and_write_header {
    rename_to_backup_file_if_exists $OUT_FILE;
    open my $outfh, '>', $OUT_FILE or die "Unable to open $OUT_FILE for writing: $!";
    $CSV->print($outfh, ['Traditional', 'POS', 'Phonetic', 'Redirect', 'Alternatives']);
    return $outfh;
}

# is_valid_candidate $part, $candidate_parts, $words_sofar, $prev_kind:
# Checks whether $part is a word part that is valid in the current position.
# The accepted sequence is:
#
# * any number of prefixes
# * any number of normal word parts
# * any number of variants
# * any number of suffixes
#
# Moreover, $part is always rejected if two (or more) parts have been been found and the
# $rest of the string is non-empty. Thus no more than three parts will be identified in
# total -- such compact parses are usually best.
sub is_valid_candidate {
    my ($part, $candidate_parts, $words_sofar, $prev_kind, $rest) = @_;
    # Accept no more than 3 parts in total
    return 0 if @$words_sofar >= 2 && $rest;
    my $current_kind = $candidate_parts->{$part};
    return 0 unless $current_kind;
    # If last word part is a $PREFIX, anything is valid
    return 1 if $prev_kind eq $PREFIX;
    # If the last word part is a $SUFFIX, only $SUFFIXes are valid
    return 0 if $prev_kind eq $SUFFIX && $current_kind ne $SUFFIX;
    # If the last word is a variant, only further variants and $SUFFIXes are valid
    return is_variant ($current_kind) || $current_kind eq $SUFFIX if (is_variant $prev_kind);
    # Otherwise, anything except $PREFIXes is valid
    return $current_kind ne $PREFIX;
}

# find_matches_rec $candidate_parts, $string, $words_sofar, $prev_kind, $found_parses:
# Recursive match function.
sub find_matches_rec {
    my ($candidate_parts, $string, $words_sofar, $prev_kind, $found_parses) = @_;
    if ($string eq '') {
        push @$found_parses, $words_sofar if @$words_sofar > 1;
        return;
    }

    my $length = length $string;
    for my $i (1..$length) {
        my $part = substr($string, 0, $i);
        my $rest = substr($string, $i, $length-$i);

        if (is_valid_candidate $part, $candidate_parts, $words_sofar, $prev_kind, $rest) {
            # If $part redirects to another word, we use that one instead
            my $part_kind = $candidate_parts->{$part};
            my $actual_part = $part_kind =~ /^_/ ? $part : $part_kind;
            find_matches_rec($candidate_parts, $rest, [@$words_sofar, $actual_part],
                $part_kind, $found_parses);
        }
    }
}

sub find_matches {
    my ($candidate_parts, $string) = @_;
    my $found_parses = [];
    find_matches_rec $candidate_parts, $string, [], $PREFIX, $found_parses;
    return $found_parses;
}


# find_word_seq_score $words, $candidate_parts: Scores a possible compound
# sequence (higher is better).
# We simply subtract the number of parts from 0 to reward shorter parses.
# 0.01 points are subtracted for every character in every candidate part in order to prefer
# the shorter variant in case of tie (e.g. "abdicate-s" over "abdicate-es").
# Half an extra point is added as a tie breaker if the sequence ends with a suffix.
sub find_word_seq_score {
    my ($words, $candidate_parts) = @_;
    my $score = 0 - @$words - length (join '', @$words) / 100;
    my $last_kind = $candidate_parts->{$words->[-1]} // '';
    $score += 0.5 if $last_kind eq $SUFFIX;
    return $score;
}

# join_combo $comboref: Join an arrayref containing a list of word parts into
# a '-'-separated string. ':' (marking variants) is stripped.
sub join_combo {
    my ($comboref) = @_;
    my $result = join '-', @$comboref;
    $result =~ s/://g;
    return $result;
}

# find_matches_and_write_entry $outfh, $word, $dict, $candidate_parts: Finds
# any possible compounds and writes CSV entries for a word. If the
# pronunciation of the word depends on its POS tag, several CSV entries will
# be written, otherwise just one. If a word is a redirect, no compound
# analysis is performed. Otherwise, each possible compound analysis is
# written into a separate field, starting with the fifth.
sub find_matches_and_write_entry {
    my ($outfh, $word, $dict, $candidate_parts) = @_;
    my $value = $dict->{$word};
    my $redirect_target = redirect_target $value;
    my $phonetic = '';

    if (defined $redirect_target) {
        # Redirect
        $CSV->print($outfh, [$word, '', $phonetic, "$redirect_target"]);
    } else {
        my $parts = find_matches $candidate_parts, $word;
        my @sorted_parts = sort { find_word_seq_score($b, $candidate_parts)
                              <=> find_word_seq_score($a, $candidate_parts)
                              } @$parts;
        my @flattened_parts = map { join_combo($_) } @sorted_parts;

        if ($value =~ /^:\s+(.*)$/) {
            # Simple entry
            my $fields = @flattened_parts ? [$word, '', $1, '', @flattened_parts]
                                          : [$word, '', $1];
            $CSV->print($outfh, $fields);
        } elsif ($value =~ m{^/(.*)$}) {
            # Tagged entries
            for my $tagged_pron (split /;\s*/, $1) {
                if ($tagged_pron =~ /^(.*):\s*(.*)$/) {
                    my $fields = @flattened_parts ? [$word, $1, $2, '', @flattened_parts]
                                                  : [$word, $1, $2];
                    $CSV->print($outfh, $fields);
                } else {
                    die "Invalid line: $word$value";
                }
            }
        } else {
            die "Invalid line: $word$value";
        }

    }
}

# Main block
my $dict = read_dict;
my $candidate_parts = find_candidate_parts $dict;
my $outfh = open_outfile_and_write_header;
find_matches_and_write_entry $outfh, $_, $dict, $candidate_parts
    for sort { lc $a cmp lc $b } keys %$dict;
close $outfh;
