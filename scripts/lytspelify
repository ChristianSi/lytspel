#!/usr/bin/perl -CA
# Convert phonetic SAMPA spellings into Lytspel.
#
# Copyright (c) 2016-18 Christian Siefkes
# See accompanying LICENSE.txt file for licensing information.
#
# Required modules: Const::Fast, Text::LevenshteinXS, and those listed in PhonEng.pm.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Const::Fast;
use Cwd 'abs_path';
use File::Basename 'dirname';
use List::Util qw(min max);
use Text::LevenshteinXS 'distance';

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

const my $IN_FILE         => 'phonetic-dict.csv';
const my $OUT_FILE        => 'lytspel-dict.csv';
const my $COMPOUNDS       => 'compounds.csv';
const my $CUSTOM          => 'custom.csv';
const my $COMPOUND_STRESS => 'compound-stress.csv';
const my $PHONEME_MAP     => 'phoneme-map.csv';

# Vowel letters in SAMPA and Lytspel
const my $SAMPA_VOWELS   => '@:#3aAeEiIoOQuUV';
const my $LYTSPEL_VOWELS => 'aeiouY';
# Class of consonant letters, with /j/ always a consonant
const my $SAMPA_SIMPLE_CONSONANT_CLS => '[`bdDfghklmnNprsStTvwzZj#]';
# Class of consonant letters, with /j/ only considered a consonant if it's not followed
# by /u:/ or /Ur/ («iu, iur» spellings)
const my $SAMPA_CONSONANT_CLS => "(?:[`bdDfghklmnNprStTvwzZ]|s#?|j(?!'?(?:u:|Ur)))";
# Pattern fragment matching an optional stress marker
const my $OPT_STRESS_MARKER => "(?:=')?";

# Pattern fragment matching a Lytspel consonant
const my $LYTSPEL_CONSONANT => '(?:(?:[bcdfghjklmnprstvxz]h?|(?<![ao])[wy]|nn?g|qu)=?)';
# Ditto, after original casing has been restored: «y» is only considered a consonant if a
# vowel follows (use with /i flag)
const my $LYTSPEL_CONSONANT_POST_PROC => '(?:(?:[bcdfghjklmnprstvwxz]h?|y(?=[aeiou])|nn?g|qu))';
# Pattern fragment matching the vowel «e» (excluding «er» and digraphs such as «ee, ue»,
# but accepting «e» after digraphs such as «ee, oe, ue, iu, qu»)
const my $PLAIN_E => "(?:[eou]ee|[iq]ue|(?<![eu])e)(?!(e|'?r))";

# Stress the second part of a compound if the first part is listed here.
my %STRESS_AFTER = map { $_ => 1 } qw/arch best chemo chromo co com con crypt crypto dynamo ego
    ere ex extra fibro helio here hetero hydro hypo infra magneto mal mon nitro peri psycho
    pyro supra thence there thio ultra where/;

# Stress the second part of a compound if listed here.
my %STRESS_IF_SECOND = map { $_ => 1 } qw/air aldehyde angular basic centric chemical chemistry
    decagon east eastern eastward eastwards ever forward genesis genic graphic logic metric
    optic phobia phobic phonic self selves sexual therapy tropic west western westward
    westwards/;

# Stress the first part of a compound if the second part is listed here. Entries here are
# only needed if the second part contains its own stress marker (which will be stripped).
my %STRESS_BEFORE = map { $_ => 1 } qw/about around away/;

# If the first part of a compound is listed here, either part may be stressed (we check
# the pronunciation to find out).
my %STRESS_VARIES_IF_FIRST = map { $_ => 1 } qw/ante auto contra electro homo meta mono para
    photo poly pro proto radio retro stereo tetra/;

# XXX Move list into external CSV file.
# If a derived word is listed here, a short vowel preceding the stress
# marker won't be converted to «e».
my %DONT_CONVERT_E_BEFORE_STRESS = map { $_ => 1 } qw/absolutory acrogenous acronymous
    albuminous allonymous ammonic ammonify animality antinomian antonymous apostrophic
    appositive atomic bacchantic balladic basophilic bestiality bitonality Brabantine Brythonic
    canonic catastrophic civility coevality colonic communality congeniality councilmanic
    criminality cryptogamous cryptonymous ctenophoran demonic diaphaneity eosinophilous
    equality external fibrinogenous frivolity geniality gnomonic halogenous homonymous
    matrimonial Miltonic monomeric monomerous monostrophic nebulosity originality partiality
    personification pseudonymity planktonic prebendal puritanical quadrantal quadratic
    quadrupedal reclusive renewal sabbatical satanic shamanic sinistrality stomachic
    subordinative sultanic sycophantic synodic synodical synonymous talismanic testimonial
    tribadic tympanic/;

# XXX Switch to Upper_Camel_Case for file-scoped variables
my $CSV_IN  = new_csv_in;
my $CSV_OUT = new_csv_out;

# The following variables are globals for simplicity
my $SUMMED_DIST             = 0;
my $WORD_COUNT              = 0;
my $COMPOUND_DICT_REF       = build_lc_map($COMPOUNDS, 0);
my $CUSTOM_DICT_REF         = build_lc_map($CUSTOM, 1);
my $PRE_STRESSED_VOWEL_DREF = build_lc_map('pre-stressed-vowel.csv', 1);

# List of compounds which are stressed differently from our regular rules.
# Values indicate which part is the stressed one ('1' or '2').
my $Compound_Stress_Dict_Ref = build_lc_map($COMPOUND_STRESS, 1);

my $UNCONVERTED_DICT_REF;
my $CONVERTED_DICT_REF;
my $CASE_REDIRECT_REF;

# Mapping from SAMPA to the standard Lytspel spellings.
my $Map_Ref;

# The maximum length of keys that may occur in $Map_Ref.
my $Max_Key_Len;

# Set of Lytspel spellings.
my %Lytspel_Set;

# Set to which all processed custom entries are added (entries are lower-case and may be
# POS-tagged as per the 'gen_key' function).
my %PROCESSED_CUSTOM_SET;

# Ditto, for compounds.
my %PROCESSED_COMPOUND_SET;

# Mapping from prefixes to their Lytspel spellings and stress hints (1: stress prefix;
# 2: stress main word; 'A': let PhonEng determine stress). Values are two-element
# array references.
my %PREFIXES;

# Mapping from suffixes to their Lytspel spellings.
my %SUFFIXES;

# XXX Adapt decompose to use prefix|suffix.csv instead of .list (note that some prefixes,
# e.g. ‹di›, are NOT auto-recognized but have been added manually in compounds-manual.csv)

# build_mapping: Create and return a mapping from SAMPA to the standard Lytspel spellings.
# Also returns the length of the longest key in the map and populates %Lytspel_Set.
sub build_mapping {
    my %dict;
    my $maxkeylen = 0;
    open my $fh, '<', $PHONEME_MAP or die "Unable to open $PHONEME_MAP: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $sampa   = $colref->[0];
        my $lytspel = $colref->[4];

        # Skip if SAMPA or Lytspel entry is missing or if SAMPA is '-'
        next unless valid_key($sampa) && $lytspel;

        $maxkeylen = max $maxkeylen, length($lytspel);
        $dict{$sampa}          = $lytspel;
        $Lytspel_Set{$lytspel} = 1;

        if ($lytspel =~ /r$/) {
            # If the spellings ends in «r», add a variant with a stress marker before the
            # final «r» to %Lytspel_Set
            my $stress_marked = substr($lytspel, 0, -1) . "'" . substr($lytspel, -1);
            $Lytspel_Set{$stress_marked} = 1;
        }

        # Add stressed variant if phoneme is a consonant followed by a vowel
        if ($sampa =~ /^${SAMPA_SIMPLE_CONSONANT_CLS}[$SAMPA_VOWELS]/) {
            my $stressed_key = substr($sampa, 0, 1) . "'" . substr($sampa, 1);
            my $stressed_val = "'$lytspel";
            $maxkeylen = max $maxkeylen, length($stressed_val);
            $dict{$stressed_key} = $stressed_val;
        }
    }

    close $fh;

    # Add context-specific spellings to %Lytspel_Set
    $Lytspel_Set{$_} = 1 for qw/al aw ay c eh n'g nn ow oy si ss s's ti uh ah oh/;
    return \%dict, $maxkeylen;
}

# build_unconverted_dict_and_case_redirects: Returns references to two hashes:
# 1. From keys (see 'gen_key' function) to the complete $IN_FILE entries describing them
# 2. From lower-cased forms of words containing capital letters to their cased form
#    (e.g. 'europe' -> 'Europe')
sub build_unconverted_dict_and_case_redirects {
    open my $infh, '<', $IN_FILE or die "Unable to open $IN_FILE: $!\n";
    my $colref = $CSV_IN->getline($infh);  # Skip header line
    my %unconverted_dict;
    my %case_redirect;

    while ($colref = $CSV_IN->getline($infh)) {
        my $word = $colref->[0];
        my $pos  = $colref->[1];
        my $key  = gen_key $word, $pos;
        $unconverted_dict{$key} = $colref;
        $case_redirect{lc $word} = $word if $word =~ /[A-Z]/;
    }

    close $infh;
    return \%unconverted_dict, \%case_redirect;
}

# delsep $str, $hyphens_too: Delete any occurrences of '=' (used as separator) from a string.
# If the second argument is true, hyphens ('-') are deleted as well.
sub delsep {
    my ($str, $hyphens_too) = @_;
    $str =~ s/=//g;
    $str =~ s/-//g if $hyphens_too;
    return $str;
}

# dist $str1, $str2: Calculate the Levenshtein edit distance between two strings, ignoring case.
# Separators and hyphens are deleted from both strings before doing the conversion:
sub dist {
    my ($str1, $str2) = @_;
    return distance(lc(delsep $str1, 1), lc(delsep $str2, 1));
}

# e_or_u_or_other $other, $left, $right, $tradspell: Return 'e', 'u', or $other depending on which
# is most similar to $tradspell. In case of a tie, 'e' is preferred over 'u' and $other is
# preferred over both. $other is ignored if it's is undefined or empty.
sub e_or_u_or_other {
    my ($other, $left, $right, $tradspell) = @_;

    # Schwa before vowels is always spelled «e»
    return 'e' if $right && $right !~ /^$SAMPA_CONSONANT_CLS/;

    my $result =
        dist($tradspell, "${left}e$right") <= dist($tradspell, "${left}u$right") ? 'e' : 'u';

    if ($other) {
        $result =
            dist($tradspell, "$left$other$right") <= dist($tradspell, "$left$result$right")
            ? $other
            : $result;
    }

    return $result;
}

# lookup_tagged_dict_entry $dict_ref, $tradspell, $pos: Look up a potentially POS-tagged
# word in a dictionary reference. $tradspell is converted to lower case prior to lookup.
# If no value is found, '' is returned.
sub lookup_tagged_dict_entry {
    my ($dict_ref, $tradspell, $pos) = @_;
    my $lower = lc $tradspell;
    return $dict_ref->{gen_key($lower, $pos)} // $dict_ref->{$lower} // '';
}

# any_short_vowel $left, $right, $tradspell, $pos: Return any of the five vowel letters
# depending on which is most similar to $tradspell. Ties are resolved by preferring the
# left-most match from the following list: e, u, a, o, i. ('e' and 'u' are generally
# preferred because their sound is close to a schwa sound, the other vowel letters are
# ranked by how often they represent a schwa in tradspell.)
#
# If a $tradspell/$pos entry exists in $PRE_STRESSED_VOWEL_DREF, the value listed there
# is always used instead of the above heuristic. This is used to overwrite entries
# where the Levenshtein similarity score gets it wrong or where a specific value (most
# often 'e') is required for consistency with related words.
sub any_short_vowel {
    my ($left, $right, $tradspell, $pos) = @_;
    my $specific = lookup_tagged_dict_entry $PRE_STRESSED_VOWEL_DREF, $tradspell, $pos;

    if ($specific) {
        die "Invalid entry in pre-stressed-vowel.csv for $tradspell($pos): $specific"
            unless $specific =~ /^[aeiou]$/;
        return $specific;
    }

    my $chosen  = '';
    my $olddist = 1000;

    for my $vowel (qw/e u a o i/) {
        my $newdist = dist($tradspell, "$left$vowel$right");

        if ($newdist < $olddist) {
            $chosen  = $vowel;
            $olddist = $newdist;
        }
    }

    return $chosen;
}

# combine $left, $right: Combine two strings into one.
# Except when $left ends with a stress marker ("'") or either string is empty, the strings are
# separated by '='.
sub combine {
    my ($left, $right) = @_;
    return $left =~ /'$/ || !$right || !$left ? "$left$right" : "$left=$right";
}

# combine_and_adjust $val, $left, $right, $tradspell, $pos: Combine $left and $val into
# a joined string, applying context-specific rules to the resulting spelling as suitable.
sub combine_and_adjust {
    my ($val, $left, $right, $tradspell, $pos) = @_;

    if ($right eq '') {
        # End-of-word spellings

        if (($val eq '@' || $val eq 'a#') && $tradspell ne 'the') {
            # Final schwa becomes «er» if tradspell ends in ‹r› (typical for non-rhotic RP),
            # otherwise «a» (except in the article 'the')
            $val = $tradspell =~ /r$/ ? 'er' : 'a';
        } elsif ($val eq 'a') {
            # Final /a/ may be spelled «ah» (but shoudn't usually occur)
            $val = 'ah';
        } elsif ($val eq 'e') {
            # Final «e» /E/ becomes «eh»
            $val = 'eh';
        } elsif ($val eq 'ee' && $tradspell =~ /^(h|sh|w|m)e$/) {
            # Pronouns ‹he, she, we, me› are written irregularly
            $val = 'i';
        } elsif ($val eq 'er' && $left =~ /Y$/) {
            # Final /aI@`/ is written «yr», e.g. «fyr, in'spyr» ‹fire, inspire›
            $val = 'r';
        } elsif ($val eq 'o') {
            # Final /Q/ may be spelled «oh» (but shoudn't usually occur)
            $val = 'oh';
        } elsif ($val eq 'u') {
            # Final /V/ is spelled «uh»
            $val = 'uh';
        } elsif ($val eq 'k' && $left =~ /(?<!['aeiou])[ai]$/) {
            # «c» is used at the end of words ending in unstressed /ak/ or /Ik/
            $val = 'c';
        } elsif ($val eq 'l' && $left =~ /au$/) {
            # Final /O:l/ is written «all», e.g. «ball»
            $left =~ s/au$/al/;
        } elsif ($left !~ /([fkpt]|th)$/) {
            # Final /s/ becomes «ss» and /z/ becomes «s» except after /f, k, p, t, T/
            if ($val eq 's') {
                $val = 'ss';
            } elsif ($val eq 'z') {
                $val = 's';
            }
        }
    }

    if ($val eq '@' && $right eq 'l' && $left =~ /[bpdtfgksz]$/) {
        # Schwa is omitted between any of /b, p, d, t, f, g, k/ and final /l/
        $val = '';

        # Final /s@l/ is written «ssl» and final /z@l/ is written «sl»
        if ($left =~ /s$/) {
            $left .= 's';
        } elsif ($left =~ /z$/) {
            chop $left;
            $left .= 's';
        }

    } elsif ($val eq '@' && $right eq 'm' && $left =~ /z$/) {
        # Final /z@m/ is written «sm»
        $val = '';
        chop $left;
        $left .= 's';
    } elsif ($val eq '@' && $right eq 'm' && $left =~ /dh$/) {
        # Schwa is also omitted between /D/ and final /m/
        $val = '';
    } elsif ($val eq '@' && $right eq 'n' && $left =~ /[sz]h$/) {
        # Final /S@n/ becomes «tion» and /Z@n/ becomes «sion»
        $val = 'o';
        $left =~ s/sh$/ti/;
        $left =~ s/zh$/si/;
    } elsif ($val eq 'I#' && $left eq 'd') {
        # Initial /dI#/ is written «di» (for consistency with the «di» ‹de› prefix)
        $val = 'i';
    } elsif (($val =~ /^(@|a#|I#)$/ && $right =~ /^$SAMPA_SIMPLE_CONSONANT_CLS*'/)
        || $val eq '@#')
    {
        # Any schwa followed by a stressed vowel can become «e/u/a/o/i» (in preference order);
        # some custom spellings use '@#' to request this (for consistency with related words)
        $val = any_short_vowel $left, $right, $tradspell, $pos;
    } elsif ($val eq '@') {
        if ($right eq 's' && $tradspell =~ /eous$/) {
            # Final ‹eous› becomes «uss» for consistency with other words ending in ‹ous›
            $val = 'u';
        } else {
            # /@/ becomes «e/u» depending on what's more similar to tradspell
            # (in preference order)
            $val = e_or_u_or_other('', $left, $right, $tradspell);
        }
    } elsif ($val eq 'a#') {
        # /a#/ becomes «a/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('a', $left, $right, $tradspell);
    } elsif ($val eq 'I#') {
        # /I#/ becomes «i/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('i', $left, $right, $tradspell);
    } elsif ($val eq 'ai' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «ai» /eI/ becomes «ay» at the end of words and before other vowels
        $val = 'ay';
    } elsif ($val eq 'au' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «au» /O:/ becomes «aw» at the end of words and before other vowels
        $val = 'aw';
    } elsif ($val eq 'ee' && $right !~ /^$SAMPA_CONSONANT_CLS/ && $left !~ /'$/) {
        # Unstressed «ee» /i:/ becomes «i» at the end of words and before other vowels
        $val = 'i';
    } elsif ($val eq 'oa'
        && $right !~ /^$SAMPA_CONSONANT_CLS/
        && $tradspell !~ /^(know|owe|sew|sow)$/)
    {
        # «oa» /oU/ becomes «o» at the end of words and before other vowels
        # (except in a few irregular words)
        $val = 'o';
    } elsif (
        $val eq 'Y'
        && (   ($right && $right !~ /^($SAMPA_CONSONANT_CLS|@`$)/)
            || ($right eq '' && $left =~ /[$LYTSPEL_VOWELS]$/))
        )
    {
        # «y» /aI/ becomes «ai» before and (at the end of words) after other vowels
        # (except before final /@`/ -- that combination becomes «yr»)
        $val = 'ai';
    } elsif ($val eq 'Y' && $tradspell eq 'eye') {
        # 'eye' remains irregular
        $val = 'eY';
    } elsif ($val eq 'oi' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «oi» /OI/ becomes «oy» at the end of words and before other vowels
        $val = 'oy';
    } elsif ($val eq 'ou' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «ou» /aU/ becomes «ow» at the end of words and before other vowels
        $val = 'ow';
    } elsif ($val eq 'uu' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «uu» /u:/ becomes «u» at the end of words and before other vowels
        $val = 'u';
    } elsif ($val =~ /^ng?$/ && $right =~ /^k/ && $left !~ /^('?[eiu]|[cn]='?o)$/) {
        # Before /k/, «n» is pronounced /N/ rather then /n/, unless the word starts with
        # «con, en, in, non, un»; /n/ becomes «nn» in this position
        $val = $val eq 'n' ? 'nn' : 'n';
    } elsif ($val eq 'r' && $left =~ /r$/) {
        # Eliminate double «r»
        $val = '';
    }

    if ($val =~ /^[aou]/) {
        # /s/ becomes «ss» between any vowel and a vowel starting with «a, o, u»
        $left =~ s/([$LYTSPEL_VOWELS]=)s($OPT_STRESS_MARKER)$/$1ss$2/;
    } elsif ($val =~ /^'?[eiY]/) {
        # /s/ becomes «c» between any vowel and a vowel starting with «e, i, y»
        $left =~ s/([$LYTSPEL_VOWELS]=)s($OPT_STRESS_MARKER)$/$1c$2/;
    }

    if ($val !~ /^['eiYyh]/) {
        # Non-final /k/ becomes «c» unless followed by any of «e, i, y» or «h»
        $left =~ s/k($OPT_STRESS_MARKER)$/c$1/;
    }

    if ($val =~ /^[$LYTSPEL_VOWELS]/) {
        # /z/ becomes «s» between two vowels
        $left =~ s/([$LYTSPEL_VOWELS]=)z($OPT_STRESS_MARKER)$/$1s$2/;

    }

    return combine($left, $val);
}

# insert_at_start $consonants: Insert a stress at the start of a consonant sequence (separated
# by '='). Also restores the final '='.
sub insert_at_start {
    my ($consonants) = @_;
    return "'$consonants=";
}

# insert_after_first $cons_pair: Insert a stress marker after the first consonant of a sequence.
# Also restores the final '='.
sub insert_after_first {
    my ($cons_pair) = @_;
    $cons_pair =~ s/=/='/;
    return "$cons_pair=";
}

# insert_after_second $consonants: Insert a stress marker after the second consonant of a sequence.
# If the sequence contains just one or two consonants, it's inserted at the end instead.
# Also restores the final '='.
sub insert_after_second {
    my ($consonants) = @_;
    $consonants .= '=';
    return $consonants =~ s/(.*?=.*?=)/$1'/r;
}

# insert_at_end $consonants: Insert a stress at the end of a consonant sequence (separated by '=').
# Also restores the final '='.
sub insert_at_end {
    my ($consonants) = @_;
    return "$consonants='";
}

# insert_stress_marker_among_multiple_consonants $consonants, $tradspell, $sep_count:
# Insert a stress marker in the proper place in a sequence of three or more consonants.
sub insert_stress_marker_among_multiple_consonants {
    my ($consonants, $tradspell, $sep_count) = @_;
    my @cons     = split /=/, $consonants;
    my $left     = '';
    my $left_sep = '';

    # Break before last three consonants, e.g. «di'scription, e'spresso, in'struction,
    # converrsaa'tsyoneh» ‹description, espresso, instruction, conversazione›
    if (   $consonants =~ /(f=r=w|s=c=[^=]+|s=p=[lry]|s=t=r|t=s=y)$/
        && $tradspell !~ /^(dy|mi|Go|juri)sp/)
    {
        return $sep_count == 2 ? insert_at_start $consonants : insert_after_first $consonants;
    }

    # Break after second consonant, e.g. «temp'taition, punc'tiliass, pont'leviss,
    # Burg'soanian, dipart'mentl, disp'noic, poast'limeni, Fits'patric» ‹temptation,
    # punctilious, pontlevis, Bergsonian, departmental, dyspnoic, postliminy, Fitzpatrick›
    return insert_after_second $consonants
        if $consonants =~
        /^( l=c=m | l=f=[cw] | m=p=t | n=c=[nt] | n=s=h | n=t=[cghlp] | r=c=[mt] | r=d=[nv]
          | r=g=s | r=m=w | r=n=[mw] | r=p=[nst] | r=s=f | r=t=[fms] | r=th=w | s=p=n
          | s=t=[fml] | t=s=[jpr] )$/x
        || $tradspell eq 'Kaiserslautern';

    # Otherwise break after first of three consonants, or after second of four
    return insert_after_first $consonants if $sep_count == 2;
    return insert_after_second $consonants;
}

# insert_stress_marker $consonants, $tradspell: Insert a stress marker in the proper place
# in the sequence of $consonants before a stressed vowel.
sub insert_stress_marker {
    my ($consonants, $tradspell) = @_;
    my $just_consonants = $consonants =~ s/=//gr;

    $consonants =~ s/=$//;  # drop final '='
    my $sep_count = () = $consonants =~ /=/g;

    # Move stress marker before whole consonant sequence ...
    return insert_at_start $consonants
        # if the «sf» in ‹spher› is stressed
        if ($consonants =~ /s=f/ && $tradspell =~ /spher/)
        # e.g. «bi'smurch, bi'spred» ‹besmirch, bespread›
        || ($consonants =~ /^s=/ && $tradspell =~ /^bes[mp]/)
        # fixes a few special cases
        || $tradspell =~ '^(respir|Samothracian|Venezuela$)';

    # Break after 'ns', if $tradspell contains 'trans' followed by certain combinations
    return insert_after_second $consonants
        if $just_consonants =~ /^(ns)(.*)/
        && $tradspell =~ /trans(ca|d|p[aou]|[gflmnv])/i
        && $tradspell ne 'transponder';

    # Three or more consonants
    return insert_stress_marker_among_multiple_consonants $consonants, $tradspell, $sep_count
        if $sep_count > 1;

    # Some special cases
    return insert_at_end $consonants if $tradspell eq 'Antarctica';
    return insert_after_first $consonants
        # e.g. «eg'zact, ang'zaieti, lug'zhueriass» ‹exact, anxiety, luxurious›
        if $consonants =~ /g=z/
        || ($consonants =~ /^s=/
        && $tradspell =~
        /^(dis[^ps]|dys|ascosporous$|casca|chastise$|descant$|extrasystolic$|testosterone$)/i)
        # Break s'c, s'k in the middle of most proper nouns, e.g. «Wis'consin» ‹Wisconsin›
        || ($consonants =~ /^s=[ck]$/
        && $tradspell =~ /^[A-Z]/
        && $tradspell !~ /^([AI]sca|Esc[ou]|Misk|Sask|Tele)/)
        # Break s'l in the middle of most proper nouns and a few other words,
        # e.g. «Is'laam, lejis'laition» ‹Islam, legislation›
        || ($consonants eq 's=l' && $tradspell =~ /^([A-BD-X]|cisl|legis|mouss)/)
        || ($consonants eq 'b=r' && $tradspell =~ /^subr/i)
        || ($consonants eq 'c=l' && $tradspell =~ /^Ma?cL/i)
        || ($consonants eq 'n=s' && $tradspell =~ /^cons/i)
        || ($consonants eq 'p=l' && $tradspell =~ /^popl/i)
        || ($consonants eq 'p=r' && $tradspell =~ /^upr/i)
        || ($consonants eq 't=r' && $tradspell =~ /^outr/i);

    # Break before both consonants if the first is 's' (not followed by certain combinations),
    # if the second is 'l' (not preceeded by d|m|n|r|t|v|?h), 'r' (not preceeded by l|m|n|z),
    # and in case of a few combinations ending in 'w' or 'y'
    return insert_at_start $consonants
        if $consonants =~ /^s=(?![ct]h|[bdfjmn])|[^dmnrtvh]=l|[^lmnz]=r|[fgstv]=w|sh=w$/
        # Likewise in final ‹tlan›, e.g. «Maassaa'tlaan» ‹Mazatlán›
        || ($consonants =~ /^t=l$/ && $tradspell =~ /tlan$/)
        # And usually in the rare «ts» combination
        || ($consonants =~ /^t=s$/ && $tradspell !~ /^(etcetera|Fitzsimmons)$/);

    # Likewise before combinations ending in 'y' (not preceeded by 'r'), though there are
    # a few exceptions
    return insert_at_start $consonants
        if $consonants =~ /[^r]=y$/
        && $tradspell !~ /^(goli|pallia)|(iority|yang|yatta|yuan)$/;

    # Otherwise break in middle
    return insert_after_first $consonants;
}

# move_stress_marker $word, $tradspell: Move stress marker before the stressed syllable,
# omitting it if the first vowel is the stressed one.
sub move_stress_marker {
    my ($word, $tradspell) = @_;

    # Return word unchanged if it doesn't contain a stress marker and in a handful of
    # quasi-compounds where the marker is aready properly placed before the vowel,
    # e.g. «sub'ordinaitiv» ‹subordinative›
    return $word
        if $word !~ /'/
        || $tradspell =~ /^( abampere$ | abaxial$ | abirrita | abohm$ | aboral$ | antalkali$
          | circumamb | enactory$ | Finsteraarhorn$ | inordinacy$ | permalloy$ | Oberammergau$
          | subordinat | supererogate$ )/x;

    # If the compound contains two stress markers, we keep just the first one
    $word =~ s/('.*)'/$1/ if $word =~ /'.*'/;

    if ($word =~ /(.*?)($LYTSPEL_CONSONANT*)'/) {
        my $pre_match                = $1;
        my $consonants_before_marker = $2;

        if ($pre_match eq '') {
            # First vowel is the stressed one
            $word =~ s/'//;
        } elsif ($consonants_before_marker eq '') {
            # Stressed vowel is preceded by another vowel: nothing to do
        } elsif ($consonants_before_marker =~ /^(rr|ss)=$/) {
            # «rr, ss» are separated by the marker, e.g. «as'sault, hor'rific»
            $word =~ s/(.)='/'$1=/;
        } elsif ($consonants_before_marker =~ /^nng/) {
            # "nng..." becomes "n'g..."
            $word =~ s/nn(g=.*?)'/n'$1/;
        } elsif ($consonants_before_marker =~ '^[^=]+=$') {
            # Move stress marker before the single consonant
            $word =~ s/$consonants_before_marker'/'$consonants_before_marker/;
        } else {
            # Use custom heuristics
            my $stressed_cons = insert_stress_marker $consonants_before_marker, $tradspell;
            $word =~ s/$consonants_before_marker'/$stressed_cons/;
        }
    } else {
        # This shouldn't happen
        warn "Don't know how to move stress in '$word' ($tradspell)\n";
    }

    return $word;
}

# insert_hyphens_as_needed $converted, $tradspell: Insert hyphens where necessary to prevent
# misreadings in words such as «co-orde'naition» ‹coordination›. Returns the converted word
# with hyphens added as needed.
sub insert_hyphens_as_needed {
    my ($converted, $tradspell) = @_;

    # Skip words from which separators have already been stripped (or which don't contain any)
    return $converted if $converted !~ /=/;

    # Eliminate repeated separators
    $converted =~ s/==/=/g;

    my $rest          = delsep $converted;
    my $rest_with_sep = $converted;
    my $reconstructed = '';

    # Try placing separators after each possible longest multigraph
OUTER: while ($rest && $rest_with_sep) {
        if ($rest =~ /^'/ && $rest_with_sep =~ /^'/) {
            # Stress marker encountered
            $reconstructed .= "'";
            $rest          = substr $rest,          1;
            $rest_with_sep = substr $rest_with_sep, 1;
            next OUTER;
        }

        my $charcount = min 4, length $rest;
        # Which char sequence do we expected (until first separator)?
        (my $expected, $rest_with_sep) = split /=/, $rest_with_sep, 2;

        while ($charcount) {
            my $start = substr $rest, 0, $charcount;
            my $inner_rest = substr $rest, $charcount;

            if (exists $Lytspel_Set{$start}) {

                if ($charcount > length $expected) {
                    # Match was too long, insert hyphen for disambiguation
                    $reconstructed .= "$expected-";
                    die "Sanity check failed multigraph disambiguation of '$converted' "
                        . "($tradspell): $expected... != $rest"
                        if $expected ne substr($rest, 0, length $expected);
                    $rest = substr $rest, length $expected;
                    next OUTER;
                } elsif ($start eq $expected) {
                    # Correct sequence matched
                    $reconstructed .= "$expected=";
                    $rest = $inner_rest;
                    next OUTER;
                } else {
                    die "Divergent matches during multigraph disambiguation of '$converted' "
                        . "($tradspell): $start+$inner_rest vs. $expected+$rest_with_sep\n";
                }
            }

            $charcount--;
        }

        die "Unexpected multigraph sequence found in '$converted' ($tradspell), "
            . "unexpected rest: '$rest'\n";
    }

    # Check that both have been consumed
    die "Unexpected rest '$rest' after multigraph disambiguation of
        . '$converted' ($tradspell)\n"
        if $rest;
    die "Unexpected separated rest '$rest_with_sep' after multigraph disambiguation of "
        . "'$converted' ($tradspell)\n"
        if $rest_with_sep;

    # Strip trailing separator and remove unnecessary hyphens
    $reconstructed =~ s/=$//;
    $reconstructed =~ s/-('?r)/=$1/g;       # not needed before «r»
    $reconstructed =~ s/a-([lw])/a=$1/g;    # not needed for «al, aw»
    $reconstructed =~ s/([aeou])-h/$1=h/g;  # not needed for «ah, eh, oh, uh»
    $reconstructed =~ s/i-er/i=er/g;        # not needed for «ier»
    $reconstructed =~ s/u-err/u=err/g;      # not needed for «uerr»
    $reconstructed =~ s/s-sh/s=sh/g;        # not needed for «ssh» (rarely in foreign words)
    $reconstructed =~ s/o-e(?!e)/o=e/g;     # not used for «oe»
    $reconstructed =~ s/o-i=c$/o=i=c/;      # not used for final «oic»
    $reconstructed =~ s/([st])-i/$1=i/g;    # not needed for «si, ti»
    $reconstructed =~ s/([iu])-a/$1=a/g;    # not used for «ia, iai, ua, uai»
    $reconstructed =~ s/-'/'/g;             # not needed before stress marker
    $reconstructed =~ s/a-i$/ai/;           # not needed in final «ai» (only used in an abbrev.)

    # Treat ‹bio..., micro...› as compound, even if the 2nd part isn't listed
    $reconstructed =~ s/o-a/o=a/ if $tradspell =~ /^(bio|micro)/;
    # Likewise words ending in «ism» after «o»
    $reconstructed =~ s/o-i=s=m$/o=i=s=m/;

    return $reconstructed;
}

# restore_capitalization $converted, $tradspell: Restore the proper capitalization of a converted
# word. This functions also does a few more tasks:
#
# * Insert hyphens where necessary to prevent misreadings in words such as
#   «am'neesi-ak» ‹amnesiac›
# * Delete separators ('=')
# * Handle the placement of contraction markers that haven't been handled before (such as
#   «ma'm» ‹ma'am›).
sub restore_capitalization {
    my ($converted, $tradspell) = @_;

    $converted = insert_hyphens_as_needed $converted, $tradspell;
    # Delete separators ('=') and convert capital letters to lower case (vowel «Y» as
    # distinguished from consonant «y»)
    $converted = lc(delsep $converted);

    if ($tradspell =~ /[A-Z].*[A-Z]/) {
        # Handle word with two or more uppercase letters

        if ($tradspell =~ /^Ma?c[A-Z]/) {
            if ($converted =~ /^m[ae]c?'/) {
                # Write names starting with ‹Mc› or ‹Mac› /m@k/ followed by a stressed and
                # capitalized syllable as «Mc» + capital letter (dropping the stress marker)
                $converted =~ s/.*'(.)/Mc\U$1/;
                # Fix ‹MacArthur› and similar words
                $converted =~ s/^McCa/McA/ if $tradspell =~ /^Ma?cA/;
            } elsif ($converted =~ /^mc/) {
                # Fix derivates of already converted words (e.g. plural forms)
                $converted =~ s/^mc(.)/Mc\U$1/;
            }
        } elsif ($tradspell eq 'NutraSweet') {
            # Fix some words with inner capitalization
            $converted =~ s/s/S/;
        } elsif ($tradspell eq 'MeV') {
            $converted =~ s/v/V/;
        }
    }

    # Capitalize first letter (if not yet done)
    $converted = ucfirst($converted) if $tradspell =~ /^[A-Z]/ && $converted =~ /^[a-z]/;

    if ($tradspell =~ /'/) {
        # Handle contractions

        if ($tradspell =~ /'(er|en|am)$/ && $converted !~ /'/) {
            # Place contraction marker in front of the last letter
            $converted =~ s/(.)$/'$1/;
        } elsif ($tradspell =~ /O'/ && $converted =~ /Oa'/) {
            # Retain capitalized ‹O'› /oU/ in Irish names (the first letter after the
            # apostrophe becomes capitalized as well)
            $converted =~ s/Oa'(.)/O'\U$1/;
        } elsif ($tradspell =~ /y'/) {
            # ‹y'all›: keep marker after first vowel
            $converted =~ s/(.)/$1'/;
        }
    }

    # Move stress marker to the right in a few contractions
    $converted =~ s/'r/r'/ if $tradspell =~ /^(nor'easter|where'er)$/;
    return $converted;
}

# convert_pron $pron, $tradspell, $pos: Convert a pronunciation.
sub convert_pron {
    my ($pron, $tradspell, $pos) = @_;
    return '' unless $pron;  # Empty input

    my $unconverted = $pron;
    my $converted   = '';

OUTER: while ($unconverted) {
        my $charcount = min $Max_Key_Len, length $unconverted;

    INNER: while ($charcount) {
            my $start = substr $unconverted, 0, $charcount;
            my $rest = substr $unconverted, $charcount;

            # No sound starts with '`' or ':'
            if ($rest =~ /^[`:]/) {
                $charcount--;
                next INNER;
            }

            my $val = $Map_Ref->{$start};
            if (defined $val) {  # Match found
                $converted = combine_and_adjust $val, $converted, $rest, $tradspell, $pos;
                $unconverted = $rest;
                next OUTER;
            }

            $charcount--;
        }

        die "No match found for converting /$pron/ ($tradspell), "
            . "unconverted part: /$unconverted/\n";
    }

    $converted = move_stress_marker $converted,     $tradspell;
    $converted = restore_capitalization $converted, $tradspell;
    return $converted;
}

# build_prefix_dict: Populate the prefix dictionary.
sub build_prefix_dict {
    my $filename = 'prefix.csv';

    open my $fh, '<', $filename or die "Unable to open $filename: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        unless (scalar @$colref == 3) {
            warn "$filename lines should have 3 columns but got: ", join(',', @$colref), "\n";
            next;
        }

        my ($word, $pron, $stress_hint) = @$colref[0 .. 2];

        warn "Duplicate key '$word' in $filename\n" if exists($PREFIXES{$word});
        warn "Unexpected stress hint for prefix $word: '$stress_hint'\n"
            unless $stress_hint =~ /^[12A]$/;

        my $converted = convert_pron $pron, $word, '';

        # Final «ss» becomes just «s», e.g. «dis»
        $converted =~ s/ss$/s/;
        # Final schwa should be «e» rather than «a» because other letters will follow
        $converted =~ s/(?<![a])a$/e/;

        $PREFIXES{$word} = [$converted, $stress_hint];
    }

    close $fh;
}

# build_suffix_dict: Populate the suffix dictionary.
sub build_suffix_dict {
    my $filename = "suffix.csv";

    open my $fh, '<', $filename or die "Unable to open $filename: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        unless (scalar @$colref == 2) {
            warn "$filename lines should have 2 columns but got: ", join(',', @$colref), "\n";
            next;
        }

        my ($word, $pron) = @$colref[0 .. 1];
        warn "Duplicate key '$word' in $filename\n" if exists($SUFFIXES{$word});
        my $suffix = convert_pron $pron, $word, '';
        # If the first vowel of the suffix is stressed, the whole suffix should always
        # be stressed, hence we prepend a stress marker in such cases
        $suffix = "'$suffix" if $pron =~ /'/ && $suffix !~ /'/;
        $SUFFIXES{$word} = $suffix;
    }

    close $fh;
}

# prepare_pron $pron: Fix the pronunication of a word by normalizing non-standard forms.
sub prepare_pron {
    my $pron = shift;
    # Normalize alternative forms of the r-colored schwa
    $pron =~ s/(?<![ei])\@r|\@`r|a#r/\@`/g;
    # If there are multiple stress markers, remove all but the last one
    $pron =~ s/'(?=.*')//g;
    return $pron;
}

# handle_custom_entry $custom_entry, $colref, $tradspell, $pos: Handle a word listed in
# the custom.csv file. The $custom_entry may have one of the following values:
#
# * B: use British (RP) pronunciation
# * A: use American (GA) pronunciation
# * P: use the PhonEng pronunciation
# * D: don't add the word to the output dictionary (used for rare foreign words or names)
# * O: leave the spelling of the word unchanged
#
# Alternatively, a custom pronunciation may be given which is then used to generate the
# final spelling (assumed to have at least two characters, otherwise a warning is printed
# and the entry is ignored).
sub handle_custom_entry {
    my ($custom_entry, $colref, $tradspell, $pos) = @_;
    $PROCESSED_CUSTOM_SET{gen_key(lc $tradspell, $pos)} = 1;

    return $tradspell if $custom_entry eq 'O';  # Leave word unchanged
    return '' if $custom_entry eq 'D';          # Skip word altogether

    my $pron = '';

    if ($custom_entry eq 'B') {
        $pron = $colref->[3];
    } elsif ($custom_entry eq 'A') {
        $pron = $colref->[4];
    } elsif ($custom_entry eq 'P') {
        $pron = $colref->[5];
    } elsif (length($custom_entry) > 1) {
        $pron = $custom_entry;
    }

    if ($pron) {
        $pron = prepare_pron $pron;
        return convert_pron $pron, $tradspell, $pos;
    } else {
        warn "Unexpected custom entry for $tradspell: $custom_entry\n";
    }
}

# Unify a sound that may be pronounced differently in two accents. Arguments:
#
# * $rp: British pronunciation
# * $ga: American pronunciation
# * $phoneng: PhonEng pronunciation (optional)
# * $alt1: how the vowel is pronounced in RP (treated as a regex)
# * $alt2: how it is pronounced in GA (treated as a regex)
# * $winner: the pronouncation that should be used
# * $tradspell: the traditional spelling (used for debugging/logging)
# * $suppress_warning: set to a true value to suppresss a warning if unification isn't possible
#   (useful for unreliable latterns)
sub unify_sound {
    my ($rp, $ga, $phoneng, $alt1, $alt2, $winner, $tradspell, $suppress_warning) = @_;

    my $rp_alt1_count = () = $rp =~ /$alt1/g;
    my $ga_alt2_count = () = $ga =~ /$alt2/g;

    return $rp, $ga, $phoneng unless $rp_alt1_count && $ga_alt2_count;  # Nothing to do

    # Split on either alternative (NOT matching if /`/ as in /@`/ follows)
    my @rp_split      = split /($alt1|$alt2)(?!`)/, $rp;
    my @ga_split      = split /($alt1|$alt2)(?!`)/, $ga;
    my @phoneng_split = split /($alt1|$alt2)(?!`)/, $phoneng;
    my $rp_elem_count = scalar @rp_split;

    unless ($rp_elem_count == scalar @ga_split) {
        warn "Note: Cannot unify $tradspell pronouncations re $alt1/$alt2\n"
            unless $suppress_warning;
        return $rp, $ga, $phoneng;
    }

    # PhonEng handles «er» /@`/ correctly hence we don't modify it
    my $unify_phoneng_too = $rp_elem_count == scalar @phoneng_split && $winner ne '@`';

    for my $i (0 .. $rp_elem_count - 1) {
        if ($rp_split[$i] =~ /^$alt1$/ && $ga_split[$i] =~ /^$alt2$/) {
            $rp_split[$i] = $winner;
            $ga_split[$i] = $winner;

            $phoneng_split[$i] = $winner
                if $unify_phoneng_too && $phoneng_split[$i] =~ /^($alt1|$alt2)$/;
        }
    }

    $rp = join '', @rp_split;
    $ga = join '', @ga_split;

    $phoneng = join '', @phoneng_split if $unify_phoneng_too;

    return $rp, $ga, $phoneng;
}

# Unify the sound used in different pronunciations in cases where a specific vowel
# pronunciation should "win". Generally, unification is only attempted if RP and GA differ;
# otherwise the given pronunciations are returned unchanged. Redundant pronunciations
# (identical to an earlier one) are eliminated in any case.
sub unify_sounds {
    my ($rp, $ga, $phoneng, $tradspell) = @_;
    $rp      = prepare_pron $rp;
    $ga      = prepare_pron $ga;
    $phoneng = prepare_pron $phoneng;

    # Discard GA if identical to RP
    $ga = '' if $ga eq $rp;

    # If PhonEng has /Nk/ where RP/GA have /nk/, use the former as it's usually correct
    if ($phoneng =~ /Nk/ && $rp =~ /nk/) {
        ($rp, $phoneng) = unify_sound $rp, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0;
        ($ga, $phoneng) = unify_sound $ga, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0
            if $ga;
    }

    return $rp, $ga, $phoneng unless $ga;  # Nothing more to unify

    # Unify vowels:
    # pair, share, variation -> «air»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'e@', 'Er', 'e@', $tradspell, 0;
    # cheer, year, peculiar -> «eer»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'i:?@', 'Ir', 'i@', $tradspell, 0;
    # poor, tour -> «oor»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'U@', 'Ur', 'Ur', $tradspell, 1;
    # number, modern -> «er» (schwa vs. r-colored schwa)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, '(?<![ei])@', '@`', '@`', $tradspell, 1;
    # port, ignore, keyboard, floral -> «oar»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'or', 'or', $tradspell, 1;
    # sorry, tomorrow -> «orr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Qr', 'O:r', 'Qr', $tradspell, 0;
    # for, dinosaur -> «or»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'O:r', 'O:r', $tradspell, 0;
    # encourage, current -> «urr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Vr', '3:r?', 'Vr', $tradspell, 0;
    # due, neutral, tune -> «ue»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'u:", "(?<![j])'u:", "'U:",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "ju:", "(?<![j'])u:", "U:",
        $tradspell, 0;
    # during, neural -> «uer» (/ju:r/ or /jUr/ in RP, /Ur/ in GA)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'(?:u:|U)r", "(?<![j])'Ur", "'U:r",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j(?:u:|U)r", "(?<![j'])Ur", "U:r",
        $tradspell, 0;

    return $rp, $ga, $phoneng;
}

# choose_nearer_or_shorter $first, $second, $tradspell: Choose and return $first or $second
# depending on which one is more similar to $tradspell.
# If both are equally similar, the shorter one is returned.
# If there is still a tie, $second is returned.
# If $second is undefined or empty, $first is returned without further checks.
sub choose_nearer_or_shorter {
    my ($first, $second, $tradspell) = @_;
    return $first unless $second;

    my $comp = dist($first, $tradspell) <=> dist($second, $tradspell);
    $comp = length($first) <=> length($second) unless $comp;
    return ($comp < 0) ? $first : $second;
}

# select_best: Select the best among the three converted spellings the and return it.
# $converted_ga and $ga may be empty. Generally PhonEng is preferred, unless it contains
# vowels where it's know to be unreliable.
sub select_best {
    my ($converted_rp, $converted_ga, $converted_phoneng, $rp, $ga, $phoneng, $tradspell) = @_;

    # Select the spelling that's nearest to tradspell
    my $nearest = choose_nearer_or_shorter $converted_rp, $converted_ga, $tradspell;
    $nearest = choose_nearer_or_shorter $nearest, $converted_phoneng, $tradspell;

    # If PhonEng is the nearest spelling, return it immediately
    return $converted_phoneng if $converted_phoneng eq $nearest;

    # If the nearest spelling is similar to PhonEng, return it in some cases where it's
    # clearly preferably
    if ($tradspell =~ /^a/i && $nearest =~ /^a/i && $converted_phoneng =~ /^e/i) {
        # Keep initial 'a', e.g. «abreevi'aition» ‹abbreviation›, not «ebreevi'aition»
        return $nearest if substr($nearest, 0, 1) . substr($converted_phoneng, 1) eq $nearest;
    }
    # Except in proper nounds, keep final 'ed' instead of 'id', e.g. «a'cursed« ‹accursed›
    return $nearest if $converted_phoneng =~ s/id$/ed/r eq $nearest && $tradspell =~ /^[a-z]/;
    # Keep 'e' if PhonEng has 'i' instead, e.g. «e'xentric» ‹eccentric›
    return $nearest if $converted_phoneng =~ s/(?<![ao])i(?![aeu])/e/r eq $nearest;
    # Keep 'ess' if PhonEng has 'iss' instead, e.g. «sorseress» ‹sorceress›
    return $nearest if $converted_phoneng =~ s/iss/ess/r eq $nearest;
    # Keep 'i' if PhonEng has 'e' instead, e.g. «abdicait» ‹abdicate›, not «abdecait»
    return $nearest if $converted_phoneng =~ s/e(?!'?r)/i/r eq $nearest;
    # Keep 'i' if PhonEng has 'ee' instead, e.g. «is'tablish» ‹establish›
    return $nearest if $converted_phoneng =~ s/ee/i/r eq $nearest;
    # Keep 'tion' if PhonEng has 'chen' instead, e.g. «in'tention» ‹intention›
    return $nearest if $converted_phoneng =~ s/chen/tion/r eq $nearest;

    my $use_phoneng = $converted_phoneng ? 1 : 0;

    if ($use_phoneng) {
        my $nearest_pron = $nearest eq $converted_rp ? $rp : $ga;

        for my $vowel (qw/A O: Q/) {
            # Heuristic: PhonEng often confuses these tree vowels, hence we don't prefer it
            # if it has one of them but the nearest pronunciation hasn't
            if ($phoneng =~ $vowel && $nearest_pron !~ $vowel) {
                $use_phoneng = 0;
                last;
            }
        }
    }

    return $use_phoneng ? $converted_phoneng : $nearest;
}

# postprocess_suffixed ...: Postprocess a suffixed words, restoring original end-of-word spellings
# (e.g. final "tion" in derived words such as «options, tra'ditionel, imoatio'naliti»
# ‹...traditional, emotionality›.
sub postprocess_suffixed {
    # XXX Split function into shorter parts
    my ($converted, $base, $suffix, $pos_hint, $tradspell) = @_;
    # Some suffixes are usually derived from a certain POS tag
    $pos_hint = 'n'  if $tradspell eq 'contractor';
    $pos_hint = 'aj' if $tradspell =~ /^(augustness|frequented|live[ns])$/;
    $pos_hint ||= 'v'
        if $tradspell =~ /^(contently|inversely)$/
        || $suffix =~ /^(able|ed|e?s|ing|or)$/;
    $pos_hint ||= 'aj' if $suffix =~ /^(ize|[lr]y)$/;
    $pos_hint ||= 'n'
        if $tradspell =~ /^(essayist|internist|presentist|progressist|teary)$/
        || $suffix =~ /^(ful|less)$/;
    my $conv_base_colref = lookup_part_entry($base, $tradspell, $pos_hint);
    my $conv_base = restore_capitalization $conv_base_colref->[3], $tradspell;
    my $conv_suffix = $SUFFIXES{$suffix};

    # XXX Eliminate regex
    # For suffixes where that's possible, simply append the suffix to the converted base word
    if (
        $suffix =~ /^(.bility|able|ance|ant|ary|ative|ate|atory|dom|ed|en|ence|es|ent|er|ess
        |est|ful|ing|ise|ish|ism|ist|ize|kinesis|l|less|ly|ment|morphism|ness|nik|n|oid|or
        |up|ry|s|y)$/x
        )
    {
        # ‹ate› is spoken in two different ways (/eIt/ or /It/) so we check which one to use
        $conv_suffix = 'ait' if $suffix eq 'ate' && $converted =~ /ait$/;

        # Before suffixes starting with e/i/y, final «c» becomes «k»
        # (e.g. «practikebl» ‹practicable›)
        $conv_base =~ s/c$/k/ if $conv_suffix =~ /^[eiy]/;

        # «d» (past tense) becomes «ed» after «d, t»
        $conv_suffix = 'ed' if $conv_suffix eq 'd' && $conv_base =~ /[dt]$/;

        # Final «ment» becomes stressed before some suffixes
        if ($conv_base =~ /ment$/ && $suffix =~ /^(able|ative)$/) {
            $conv_base =~ s/'//;
            $conv_base =~ s/ment$/'ment/;
        }

        # An additional /g/ might become audible between final /N/ and some suffixes
        # (e.g. «longger, stronggest» ‹longer, strongest›)
        if (   $suffix =~ /^(ate|er|est|ish|oid)$/
            && $conv_base =~ /ng$/
            && $converted =~ /ngg$conv_suffix$/)
        {
            $conv_suffix = "g$conv_suffix";
        }

        # «s» (plural or third person singular) is written «es« after sibilants
        $conv_suffix = 'es' if $conv_suffix eq 's' && $conv_base =~ /([jsxz]|[csz]h)$/;

        # «tys» ‹tise› becomes stressed before «ment»
        # (e.g. «adver'tysment» ‹advertisement›)
        if ($conv_base =~ /tys$/ && $suffix eq 'ment') {
            $conv_base =~ s/'//;
            $conv_base =~ s/tys$/'tys/;
        }

        # Suffix «n» becomes «en» after some consonants
        $conv_suffix = 'en' if $conv_suffix eq 'n' && $conv_base =~ /[djkhlpstv]$/;

        # Omitted schwa before final «l» or «m» is restored in front of «ait/it, erri, ism,
        # ist, oid, ys» ‹ate, ary, ..., ise/ize› (as well as some irregular suffixes,
        # cf. below), unless the schwa is not spoken
        $conv_base =~ s/(${LYTSPEL_CONSONANT})ssl$/$1sel/
            || $conv_base =~ s/cl$/kel/
            || $conv_base =~ s/(.)$/e$1/
            if $conv_suffix =~ /^(a?it|erri|ism|ist|oid|ys)$/
            && $conv_base =~ /([bpdtfgcksz]l|(dh|s)m)$/
            && $base !~ /^(cycle|simple)$/;

        # Rules for single-consonant suffix such as «d, n, s»
        if ($conv_suffix =~ /^[^$LYTSPEL_VOWELS]$/) {
            # Final «i» /i:/ becomes «ie» to prevent misreadings
            $conv_base .= 'e' if $conv_base =~ /i$/;
            # Final «o» /oU/ is restored to «oa»
            $conv_base .= 'a' if $conv_base =~ /(?<!o)o$/;
            # Final «u» /u:/ is restored to «uu»
            $conv_base .= 'u' if $conv_base =~ /(?<!i)u$/;
        }

        # Schwa at the start of suffixes is written «a» if the base word ends in /i:/ or /u:/
        substr $conv_suffix, 0, 1, 'a'
            if $conv_suffix =~ /^e[^er]/
            && $conv_base =~ /(ee|i|[^i]u)$/;

        # The suffix ‹ary› is spoken «eri» /s@`i/ in some words (most of them are listed as
        # non-compounds, but after final «ss» they must be treated as compounds to ensure
        # proper conversion)
        $conv_suffix = 'eri' if $tradspell =~ /^(dispensary|glossary)$/;

        # Likewise ‹ry›
        $conv_suffix = 'eri'
            if $conv_suffix eq 'ri'
            && $conv_base =~ /[bdfgjklnprsv]$/
            && $tradspell =~ /([^g]ery|dgery)$/
            && $tradspell !~ /(comradery|enginery|riflery)/;

        # Strip stress marker from base word if the suffix contains another one
        $conv_base =~ s/'// if $conv_suffix =~ /'/;

        return "$conv_base$conv_suffix";
    }

    # Restore end-of-word spellings in potentially irregular suffixed forms.
    # Note: Some cases seem never to occur with these suffixes (or only in irregular words
    # that don't allow restoration) and hence haven't been added.
    # Not anchored to end of word because of indirect derivates such as ‹emotionality,
    # expressionistic›
    if ($conv_base =~ /tion/) {
        # Restore «tion» (shen), e.g. «tra'ditionel» ‹traditional›
        $converted =~ s/(.*)shen/$1tion/
            || $converted =~ s/(.*)sho'n/$1tio'n/
            || warn "No match: $converted ($tradspell) from $conv_base";
    } elsif ($conv_base =~ /sion/) {
        # Restore «sion» (zhen), e.g. «o'caisionel» ‹occasional›
        $converted =~ s/(.*)[zs]hen/$1sion/
            || $converted =~ s/(.*)zho'n/$1sio'n/
            || warn "No match: $converted ($tradspell) from $conv_base";
    }

    if ($conv_base =~ /all$/) {
        # Restore final «all», e.g. «spal'laition» ‹spallation› from «spall»
        $converted =~ s/(.*)aa('?)l/$1al$2l/;
    } elsif ($conv_base =~ /k$/ && ($conv_suffix !~ /^[eiY]/ || $suffix eq 'al')) {
        # Restore final «k», e.g. «embar'kaition« ‹embarkation›
        $converted =~ s/(.*)c/$1k/ || warn "No match: $converted ($tradspell) from $conv_base";
    } elsif ($conv_base =~ /[^o]o$/ && $conv_base !~ /oa/ && $suffix ne 'an') {
        # Restore final «o» /oU/, e.g. «heelio'taxiss» ‹heliotaxis›
        $converted =~ s/(.*)oa/$1o/;
    } elsif ($conv_base =~ /s$/ && $converted =~ /z(ian|icl)$/) {
        # Restore final «s», e.g. «Hobsian» ‹Hobbesian›
        $converted =~ s/(.*)z/$1s/;
    } elsif ($conv_base =~ /sh$/ && $converted =~ /tion$/) {
        # Restore final «sh»: «Sailishen» ‹Salishan›
        $converted =~ s/tion$/shen/;
    } elsif ($conv_base =~ /ss$/) {
        # Restore final «ss», e.g «ri'sponssebl, puls'saition» ‹responsible, pulsation›
        if ($converted !~ /ss|tion$|shel$/ || $converted =~ /caition$/) {
            my $suffix_start = $1;
            $converted =~ s/(.*)[cs]([eiY])/$1ss$2/
                || warn "No match: $converted ($tradspell) from $conv_base";
            $converted =~ s/'ss/s's/;  # Fix stress marker, if needed
        } elsif ($converted =~ /[^s]'saition$/) {
            $converted =~ s/'saition$/s'saition/;
        }
    } elsif ($conv_base =~ /ssl$/ && $suffix eq 'ation') {
        # Restore final «ssl», e.g. «canss'laition» ‹cancellation›
        $converted =~ s/se'laition/ss'laition/;
    } elsif ($conv_base =~ /[^ao]y$/) {
        # Restore final «y», e.g. «di'nyel» ‹denial›
        $converted =~ s/(.*)ai/$1y/ || warn "No match: $converted ($tradspell) from $conv_base";
    } elsif ($conv_base =~ /s'?s/ && $converted !~ /s'?s/) {
        # Restore «ss» in the middle of words (including some special cases), e.g.
        # «classicl» ‹classical›
               $converted =~ s/('?)c([eiY])/s$1s$2/
            || $converted =~ s/counsil/counssl/
            || $converted =~ s/Ys/Yss/
            || $converted =~ s/n('?)si/ns$1si/;
    } elsif ($conv_base =~ /kw/ && $converted !~ /k'?w/) {
        # Restore «kw» in the middle of words: «Pik'wikian» ‹Pickwickian›
        $converted =~ s/(')qu/k$1w/ || warn "No match: $converted ($tradspell) from $conv_base";
    } elsif ($conv_base =~ /oic/ && $converted =~ /o-i/) {
        # Restore «oic», e.g. «stoicl« ‹stoical›
        $converted =~ s/(.*)o-i/$1oi/;
    } elsif ($conv_base =~ /msi/ && $converted !~ /m'?si/) {
        # Restore «msi» in the middle of words: «wimsi'caliti» ‹whimsicality›
        $converted =~ s/mzi/msi/ || warn "No match: $converted ($tradspell) from $conv_base";
    }
    # If the derived word starts with «e» (not «er») and the base word with another short
    # vowel (except «i»), use the latter, e.g. «conside'raition» ‹consideration› from
    # «con'sider»
    if ($converted =~ /^$LYTSPEL_CONSONANT_POST_PROC*e(?!'?[er])/i) {
        my ($pre_cons, $first_base_vowel) =
            $conv_base =~ /^($LYTSPEL_CONSONANT*)([$LYTSPEL_VOWELS]+)/i;

        if ($first_base_vowel !~ /^[ei]$/i) {
            if ($pre_cons =~ /c$/) {
                # Also change «k» preceding the vowel back to «c»
                $converted =~ s/ke/c$first_base_vowel/;
            } else {
                $converted =~ s/e/$first_base_vowel/;
            }
        }
    }

    # Schwa before stressed vowel may be represented by any short vowel, but if it's written
    # «e» in the base word, it shouldn't become a different vowel in a stress-shifted
    # derived form, hence we correct such cases (except for blacklisted words)
    if (
        $converted =~ /(ss|c|qu|[$LYTSPEL_VOWELS]{1,2})? ([aiou]) ((?!'?r)
                          $LYTSPEL_CONSONANT_POST_PROC*')/x
        && !exists($DONT_CONVERT_E_BEFORE_STRESS{$tradspell})
        && $tradspell !~ /ographic$/
        )
    {
        my $pre_vowel = $1 || '';

        # Skip if the vowel is just the second letter of a digraph
        unless ($pre_vowel =~ /^[$LYTSPEL_VOWELS]$/) {
            my $vowel        = $2;
            my $post_vowel   = $3;
            my $conv_e_count = () = $converted =~ /$PLAIN_E/g;
            my $base_e_count = () = $conv_base =~ /$PLAIN_E/g;

            # Subtract 1 'e' if occurs in the suffix
            --$conv_e_count if $conv_suffix =~ /$PLAIN_E/ && $converted =~ /$conv_suffix$/;

            if ($base_e_count > $conv_e_count) {
                my $pre_mod = $pre_vowel;

                # «ss» before «a/o/u» becomes «c» before «e», while «c» becomes «k»
                unless ($vowel eq 'i') {
                    $pre_mod = 'c' if $pre_vowel eq 'ss';
                    $pre_mod = 'k' if $pre_vowel eq 'c';
                }

                # Replace the short vowel by «e»
                $converted =~ s/$pre_vowel$vowel$post_vowel/${pre_mod}e$post_vowel/
                    || warn
                    "Cannot normalize schwa before stressed vowel in $converted ($tradspell)";
            }
        }
    }

    return $converted;
}

# convert_row $colref, $tradspell: Convert a row (CSV line) from $IN_FILE style to $OUT_FILE.
# Any listed pronunciations are converted using the Lytspel rules and the resulting spelling
# that's nearest to the traditional spelling is selected and appended to the resulting output
# row. Also handles compounds correctly and updates the global $SUMMED_DIST and WORD_COUNT
# variables.
sub convert_row {
    my ($colref, $tradspell) = @_;
    my $parts = $COMPOUND_DICT_REF->{lc $tradspell};
    my $pos   = $colref->[1];
    my $converted;

    # First check if it's a compound
    my $compound = handle_compound($colref, $parts, $tradspell);

    if (!$compound || $compound =~ /^!/) {
        # It's a base or a suffixed word (the latter requires postprocessing)
        my $custom_entry = $CUSTOM_DICT_REF->{gen_key(lc $tradspell, $pos)}
            // $CUSTOM_DICT_REF->{lc $tradspell} // '';

        if ($custom_entry) {
            $converted = handle_custom_entry $custom_entry, $colref, $tradspell, $pos;
        } elsif ($tradspell =~ /^[A-Z]+$/
            && $tradspell !~ /^(COBOL|FORTRAN|IMAX|UNESCO|UNICEF)$/)
        {
            $converted = '';  # Skip most all-caps words (abbreviations)
        } else {
            my ($rp, $ga, $phoneng) = unify_sounds $colref->[3], $colref->[4], $colref->[5],
                $tradspell;
            my $converted_rp      = convert_pron $rp,      $tradspell, $pos;
            my $converted_ga      = convert_pron $ga,      $tradspell, $pos;
            my $converted_phoneng = convert_pron $phoneng, $tradspell, $pos;

            # Omit GA if identical to RP
            $converted_ga = '' if $converted_ga eq $converted_rp;
            $converted = select_best $converted_rp, $converted_ga, $converted_phoneng,
                $rp, $ga, $phoneng, $tradspell;
        }
    } else {
        # Return compound after discarding a spurious hyphen that might have been added before
        # the stress marker
        $compound =~ s/-'/'/;
        $converted = $compound;
    }

    return '' unless $converted;

    if ($compound && $compound =~ /^!(.*)=(.*)/) {
        # Postprocess suffixed word
        my $base   = $1;
        my $suffix = $2;
        $converted = postprocess_suffixed $converted, $base, $suffix, $pos, $tradspell;
    }

    $SUMMED_DIST += dist $converted, $tradspell;
    $WORD_COUNT++;
    my $conv_colref = [@$colref[0 .. 2], $converted];
    return $conv_colref;
}

# lookup_part_entry $part, $tradspell, $pos_hint: Look up the entry for a word part of a
# compound, taking case redirects and POS-tagged word parts into account. Returns the converted
# entry row -- if the word hasn't been processed before, it will be converted.
sub lookup_part_entry {
    my ($part, $tradspell, $pos_hint) = @_;
    my $cased         = $CASE_REDIRECT_REF->{$part};
    my $key           = $cased ? $cased : $part;
    my $unconv_colref = $UNCONVERTED_DICT_REF->{$key};

    unless ($unconv_colref) {
        # Must be a POS-tagged word -- use the provided $pos_hint or else 'v', since it's the
        # most frequent POS tag
        my $pos = $pos_hint || 'v';

        # Some heuristics to pick the correct POS tag use
        unless ($pos_hint) {
            # XXX Remove unnecessary parts (such as able, ing)
            # Most words ending in -ate are adjectives (e.g. ‹agglutinate›).
            # Most ‹close...› combinations use the adjective.
            $pos = 'aj'
                if ($part =~ /ate$/
                && $tradspell !~ /(able|^de.*minate|^predesignate|^supersaturate|agglutinate)$/)
                || ($part eq 'close' && $tradspell !~ /^close(down|out|ing|d|s)$|.close$/)
                || $tradspell =~
                /^(airmobile|infrequent|live(bearer|stock)|ungallant|wordperfect)$/;
            $pos = 'n'
                if ($part =~ /^(alloy|concave|congress|dove|house|lead|transfer|transfer|wind)$/
                && $tradspell !~ /(able|^(${part}e?r|fairlead|mislead|leadoff|unwind))$/)
                || ($part eq 'concert' && $tradspell =~ /er$/)
                || ($part =~ /^mou(se|th)$/ && $tradspell !~ /^$part(ed|e?r|ing|y)$/)
                || $tradspell =~ /^(discounter|fluidextract|internship|rebeldom|omnipresent|
                    subcompact|teardrop|semidesert)$/x;
        }

        $key = gen_key $part, $pos;
        $unconv_colref = $UNCONVERTED_DICT_REF->{$key};

        # XXX Simplify this code
        unless ($unconv_colref) {
            # Use 'n' or else 'aj' as fallback
            $key = gen_key $part, 'n';
            $unconv_colref = $UNCONVERTED_DICT_REF->{$key};

            unless ($unconv_colref) {
                $key = gen_key $part, 'aj';
                $unconv_colref = $UNCONVERTED_DICT_REF->{$key};
                die "No entry found for $key\n" unless $unconv_colref;
            }
        }
    }

    my $conv_colref = $CONVERTED_DICT_REF->{$key};
    unless ($conv_colref) {
        # Convert word now
        $conv_colref = convert_row $unconv_colref, $cased || $part;
        $CONVERTED_DICT_REF->{$key} = $conv_colref;
    }

    return $conv_colref;
}

# hyphen_needed $first, $second: Check if a hyphen should be inserted between the parts
# of a compound to prevent misreading.
sub hyphen_needed {
    my ($first, $second) = @_;
    return ($first =~ /o$/i && $second =~ /^[aiou]/i) || ($first =~ /i$/i && $second =~ /^u/i);
}

# handle_compound $colref, $parts, $tradspell: Handle a compound or derived form. Contractions
# derived from another word in a regular fashion (such as ‹it'd, she'll, shouldn't› are handled
# by this method has well.
#
# The return value is one of the following:
#
# * the spelling to use if the word is a compound or a prefixed form
# * "!mainword=suffix" if it's a suffixed word (for later postprocessing)
# * undef otherwise
sub handle_compound {
    # XXX Refactor this function into shorter ones
    my ($colref, $parts, $tradspell) = @_;
    my $pos = $colref->[1];
    $PROCESSED_COMPOUND_SET{gen_key(lc $tradspell, $pos)} = 1;
    my ($first_lytspel, $second_lytspel, $compound);

    # Check whether compound should stressed irregularly
    my $compound_stress = $Compound_Stress_Dict_Ref->{gen_key(lc $tradspell, $pos)}
        // $Compound_Stress_Dict_Ref->{lc $tradspell};

    if (defined $compound_stress) {
        warn "Invalid stress '$compound_stress' defined in $COMPOUND_STRESS for $tradspell"
            if $compound_stress !~ /^[12]$/;
    } else {
        $compound_stress = '';
    }

    if ($tradspell =~ /^(.*)('(d|ll|re|ve)|n't)$/ || $tradspell =~ /^(I)('m)$/) {
        # Handle regular contractions (and a few irregular ones)
        my $first  = $1;
        my $second = $2;

        if ($first =~ /^(ai|ha|sha)$/) {
            # «ain't, han't, shan't» remain unchanged
            $first_lytspel = $first;
        } elsif ($first =~ /^[dw]o$/) {
            # ‹don't, won't» becomes «doan't, woan't»
            $first_lytspel = "${first}a";
        } else {
            my $first_conv_colref = lookup_part_entry lc($first), $tradspell, $pos;
            $first_lytspel = $first_conv_colref->[3];
            # The last consonant of «must» is not spoken in contractions
            $first_lytspel = substr $first_lytspel, 0, -1 if $first_lytspel eq 'must';
        }

        # ‹'ll, 're, 've› lose their second letter, other contractions remain unchanged
        $second_lytspel = $second =~ /^'..$/ ? substr($second, 0, -1) : $second;
        return "$first_lytspel$second_lytspel";
    }

    return undef unless $parts;

    if ($parts =~ /-/) {
        # It's a compound made of two parts (separated by '-')
        my ($first, $second) = split /-/, $parts;
        my $first_conv_colref  = lookup_part_entry $first,  $tradspell, $pos;
        my $second_conv_colref = lookup_part_entry $second, $tradspell, $pos;
        die "First part $first of compound $tradspell not found\n"   unless $first_conv_colref;
        die "Second part $second of compound $tradspell not found\n" unless $second_conv_colref;
        $first_lytspel = restore_capitalization $first_conv_colref->[3], $tradspell;
        $second_lytspel = lc $second_conv_colref->[3];

        # Capitalize second part of words with inner capitalization
        $second_lytspel = ucfirst($second_lytspel) if $tradspell =~ /^[A-Z][a-z]+[A-Z]/;
        $first_lytspel = "$first_lytspel-" if hyphen_needed($first_lytspel, $second_lytspel);
        $compound = "$first_lytspel$second_lytspel";

        # If the compound contains two stress markers, we keep just the second one
        $compound =~ s/'// if $compound =~ /'.*'/;

        if ($compound =~ /'/) {
            # Compound already contains a stress marker

            if ($compound_stress eq '1' || exists($STRESS_BEFORE{$second})) {
                # Strip stress marker from 2nd part
                $second_lytspel =~ s/'//;
                return "$first_lytspel$second_lytspel";
            } elsif ($compound_stress eq '2'
                || exists($STRESS_IF_SECOND{$second})
                || exists($STRESS_AFTER{$first}))
            {
                # Strip stress marker from 1st part
                $first_lytspel =~ s/'//;
                # Add marker before 2nd part (unless it already contains one)
                return $second_lytspel =~ /'/
                    ? "$first_lytspel$second_lytspel"
                    : "$first_lytspel'$second_lytspel";
            } else {
                # Retain marker and consider stress settled (unless the first part is
                # «i'lectro» ‹electro› -- check below which part carries the main stress)
                return $compound unless $first eq 'electro';
            }
        }

        # If this word is listed as a special case, we return it and are done
        return $compound if $compound_stress eq '1';

        # Insert stress marker before second part if appropriate
        $compound = "$first_lytspel'$second_lytspel"
            if exists($STRESS_AFTER{$first})
            || exists($STRESS_IF_SECOND{$second})
            || $compound_stress eq '2';

        if (exists($STRESS_VARIES_IF_FIRST{$first})) {
            # Check pronunciation to find out which part to stress
            my $pron = $colref->[5] || $colref->[3];  # prefer PhonEng, use RP as fallback

            # In ‹electro...› combinations, we discard the first sound (vowel), since it's
            # never stressed
            $pron = substr($pron, 1) if $first eq 'electro';

            if ($pron =~ /[$SAMPA_VOWELS].*'/) {
                # If a vowel occurs before the stress marker, we assume that the 2nd part is
                # stressed (in case of ‹electro...› combinations, it may already contain a
                # stress marker)
                $first_lytspel =~ s/'//;  # convert «i'lectro» to «ilectro»
                $compound = "$first_lytspel'$second_lytspel" unless $second_lytspel =~ /'/;
            }
        }

        return $compound;
    } else {
        # Otherwise it should be a prefixed or suffixed word (separated by '=')
        my ($first, $second) = split /=/, $parts;
        my $stress_hint;
        my $suffixed = 0;

        unless ($second) {
            warn "Invalid compound definition for $tradspell: $parts\n";
            return undef;
        }

        # Second may be a suffix and/or first may be a prefix
        if (exists $SUFFIXES{$second}) {
            $second_lytspel = $SUFFIXES{$second};
            $suffixed       = 1;
        }

        if (exists $PREFIXES{$first}) {
            $first_lytspel = restore_capitalization $PREFIXES{$first}->[0], $tradspell;
            $stress_hint = $PREFIXES{$first}->[1];
        }

        # The part not yet defined must be a regular entry
        unless ($first_lytspel) {
            my $first_conv_colref = lookup_part_entry $first, $tradspell, $pos;
            die "Part $first not found while processing $tradspell\n"
                unless $first_conv_colref && $first_conv_colref->[3];
            $first_lytspel = restore_capitalization $first_conv_colref->[3], $tradspell;
        }

        if (!$second_lytspel || ($second eq 'able' && $stress_hint)) {
            # Lookup second part in regular dictionary if it's not a suffix or in case
            # of prefix='able' combinations such as 'unable'
            my $second_conv_colref = lookup_part_entry $second, $tradspell, $pos;
            die "Part $second not found while processing $tradspell\n"
                unless $second_conv_colref && $second_conv_colref->[3];
            $second_lytspel = lc $second_conv_colref->[3];
        }

        # /aI/ is written «ai» before vowels: adjust at the end of prefixes such as
        # «by» ‹bi›
        $first_lytspel =~ s/y$/ai/
            if $stress_hint
            && $first_lytspel =~ /[^ao]y$/
            && $second_lytspel !~ /^$LYTSPEL_CONSONANT_POST_PROC/;

        # Prefixes ending in «ay/oy» are written «ai/oi» before consonants, e.g. «ai» ‹a›
        $first_lytspel =~ s/y$/i/
            if $stress_hint
            && $first_lytspel =~ /[ao]y$/
            && $second_lytspel =~ /^$LYTSPEL_CONSONANT_POST_PROC/;

        # The Prefix «ir» becomes just «i» before another «r»
        $first_lytspel = 'i' if $first_lytspel eq 'ir' && $second_lytspel =~ /^r/ && $stress_hint;

        if ($stress_hint && $suffixed && $first =~ /^(out|post)$/) {
            # Combination of "out" or "post" with a suffix are converted like non-compounds
            return undef;
        }

        if ($stress_hint && $first eq 'a') {
            # The prefix 'a' may be pronounced /eI/ or /a/ -- we check the pronunciation and
            # fix if it's the latter
            my $pron = $colref->[5] || $colref->[3];  # prefer PhonEng, use RP as fallback
            $first_lytspel = 'a' if $pron =~ /^[a@]/ || $tradspell eq 'asea';
        }

        if ($suffixed && !$stress_hint) {
            # Main word=suffix combination: return for later postprocessing
            return "!$first=$second";
        }

        $first_lytspel = "$first_lytspel-" if hyphen_needed($first_lytspel, $second_lytspel);
        $compound = "$first_lytspel$second_lytspel";

        if ($stress_hint eq '1' || $compound_stress eq '1') {
            $second_lytspel =~ s/'//;  # delete stress marker from 2nd part, if any
            $compound = "$first_lytspel$second_lytspel";
        } elsif ($stress_hint eq '2' || $compound_stress eq '2') {
            # Insert stress marker before 2nd part (unless it already contains one)
            $compound = "$first_lytspel'$second_lytspel" unless $second_lytspel =~ /'/;
        } elsif ($stress_hint eq 'A') {
            # Check pronunciation to find out which part to stress
            my $pron = $colref->[5] || $colref->[3];  # prefer PhonEng, use RP as fallback

            if ($pron =~ /[$SAMPA_VOWELS].*'/) {
                # If a vowel occurs before the stress marker, we assume that the 2nd part is
                # stressed
                $compound = "$first_lytspel'$second_lytspel" unless $second_lytspel =~ /'/;
            } else {
                $second_lytspel =~ s/'//;  # delete stress marker from 2nd part, if any
                $compound = "$first_lytspel$second_lytspel";
            }
        } else {
            warn "Entry '$tradspell' has invalid stress hint: '$stress_hint'\n";
        }

        return $compound;
    }

}

# warn_unprocessed_entries $filename, $dictref, $processed_dictref
# Warn if $dictref contains any entries not listed in $processed_dictref (the latter may
# also be POS-tagged).
sub warn_unprocessed_entries {
    my ($filename, $dictref, $processed_dictref) = @_;
    for my $key (sort keys %$dictref) {
        warn "Unused $filename entry: $key\n"
            unless exists $processed_dictref->{$key}
            || exists $processed_dictref->{gen_key($key, 'v')}
            || exists $processed_dictref->{gen_key($key, 'aj')};
    }
}

# convert_dict: Convert SAMPA spellings to Lytspel.
sub convert_dict {
    ($Map_Ref, $Max_Key_Len) = build_mapping;
    build_prefix_dict;
    build_suffix_dict;
    ($UNCONVERTED_DICT_REF, $CASE_REDIRECT_REF) = build_unconverted_dict_and_case_redirects;
    my $outfh = open_outfile_and_write_header $OUT_FILE, [qw(Traditional POS Redirect Lytspel)];

    for my $key (sort { lc $a cmp lc $b } keys %$UNCONVERTED_DICT_REF) {
        my $colref = $UNCONVERTED_DICT_REF->{$key};

        if (scalar @$colref < 4) {
            # Nothing to convert, just output and store line as is
            $CSV_OUT->print($outfh, $colref);
            $CONVERTED_DICT_REF->{$key} = $colref;
            next;
        }

        my $conv_colref = $CONVERTED_DICT_REF->{$key};
        if ($conv_colref) {
            # Word has already been converted
            $CSV_OUT->print($outfh, $conv_colref);
            next;
        }

        $conv_colref = convert_row $colref, $colref->[0];
        $CONVERTED_DICT_REF->{$key} = $conv_colref;
        $CSV_OUT->print($outfh, $conv_colref) if $conv_colref;

    }

    close $outfh;

    warn_unprocessed_entries $CUSTOM,          $CUSTOM_DICT_REF,          \%PROCESSED_CUSTOM_SET;
    warn_unprocessed_entries $COMPOUND_STRESS, $Compound_Stress_Dict_Ref, \%PROCESSED_COMPOUND_SET;

    my $avg_dist = $SUMMED_DIST / $WORD_COUNT;
    say "Average distance between tradspell and Lytspel: $avg_dist";
}

# Main block
convert_dict;
