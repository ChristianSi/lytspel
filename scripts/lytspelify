#!/usr/bin/perl -CA
# Convert phonetic SAMPA spellings into Lytspel.
#
# Copyright (c) 2016-2020 Christian Siefkes
# See accompanying LICENSE.txt file for licensing information.
#
# Required modules: Const::Fast, Text::LevenshteinXS, and those listed in PhonEng.pm.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Const::Fast;
use Cwd 'abs_path';
use File::Basename 'dirname';
use List::Util qw(min max);
use Text::LevenshteinXS 'distance';

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

const my $IN_FILE         => 'phonetic-dict.csv';
const my $OUT_FILE        => 'lytspel-dict.csv';
const my $COMPOUNDS       => 'compounds.csv';
const my $CUSTOM          => 'custom.csv';
const my $COMPOUND_STRESS => 'compound-stress.csv';
const my $PHONEME_MAP     => 'phoneme-map.csv';

# Vowel letters in SAMPA and Lytspel
const my $SAMPA_VOWELS   => '@:#3aAeEiIoOQuUV';
const my $LYTSPEL_VOWELS => 'aeiouY';
# Class of consonant letters, with /j/ always a consonant
const my $SAMPA_SIMPLE_CONSONANT_CLS => '[`bdDfghklmnNprsStTvwzZj#]';
# Class of consonant letters, with /j/ only considered a consonant if it's not followed
# by /u:/ or /Ur/ («ue, uer» spellings)
const my $SAMPA_CONSONANT_CLS => "(?:[`bdDfghklmnNprStTvwzZ]|s#?|j(?!'?(?:u:|Ur)))";
# Pattern fragment matching an optional stress marker
const my $OPT_STRESS_MARKER => "(?:=')?";

# Pattern fragment matching a Lytspel consonant
const my $LYTSPEL_CONSONANT => '(?:(?:[bcdfghjklmnprstvxz]h?|(?<![ao])[wy]|nn?g|qu)=?)';
# Ditto, after original casing has been restored: «y» is only considered a consonant if a
# vowel follows (use with /i flag)
const my $LYTSPEL_CONSONANT_POST_PROC => '(?:(?:[bcdfghjklmnprstvwxz]h?|y(?=[aeiou])|nn?g|qu))';
# Pattern fragment matching the vowel «e» (excluding «er» and digraphs such as «ee, ue»,
# but accepting «e» after digraphs such as «ee, oe, ue, qu»)
const my $PLAIN_E => "(?:[eou]ee|que|(?<![eu])e)(?!(e|'?r))";
# Pattern fragment matching a lowercase acute accent
const my $Acute_Accent => '[áéíóúý]';
# Pattern fragment matching a lowercase acute accent or diaereses
const my $Acute_Accent_or_Diaereses => '[áéíóúýäëïöü]';
# Regex matching a vowel in a converted word (lower-case, accents excluded)
const my $CONV_VOWEL =>
    qr/ ((?:all | (?<!q)[iu]a(?![aiy]) | a[aiuwy]? | ee? | (?<=[st])ion | iy(?=[aeiou,]|$) |
        i(?:er)? | oa(?![ai]) | o[eiouwy]? | (?<!q)u[eu]? | y(?![aeiouy,]))r{0,2})/x;

# XXX Switch all file-scoped variables to Upper_Camel_Case.
# Stress the second part of a compound if the first part is listed here.
my %STRESS_AFTER = map { $_ => 1 } qw/arch best chemo chromo co com con crypt crypto dynamo ego
    ere ex extra fibro helio hemi here hetero hydro hypo infra magneto mal mon nitro peri psycho
    pyro supra thence there thio ultra where/;

# Stress the second part of a compound if listed here.
my %STRESS_IF_SECOND = map { $_ => 1 } qw/air aldehyde angular basic centric chemical chemistry
    decagon east eastern eastward eastwards ever forward genesis genic graphic logic metric
    optic phobia phobic phonic self selves sexual therapy tropic west western westward
    westwards/;

# Stress the first part of a compound if the second part is listed here. Entries here are
# only needed if the second part contains its own stress marker (which will be stripped).
my %STRESS_BEFORE = map { $_ => 1 } qw/about around away/;

# If the first part of a compound is listed here, either part may be stressed (we check
# the pronunciation to find out).
my %STRESS_VARIES_IF_FIRST = map { $_ => 1 } qw/ante auto contra electro homo meta mono para
    photo poly pro proto radio retro stereo tetra/;

# Words that should be treated as prefixes if they occur as first part of a compound.
my %Treat_As_Prefix = map { $_ => 1 } qw/afro allo alpha alto azo extra ethyl infra ultra/;

# Words in which /D/ should be spelled 'th' (some not automatically recognized compounds
# and some borderline cases -- where both sounds occur -- are also added here)
my %Use_Th = map { $_ => 1 } qw/although than that the their them then there they this though
    thus farthest furthest leatherette nevertheless nonetheless these those with withdrew
    within without withy/;

# Mappings from plain vowels to those with acute accents on them.
my %AcuteAccents = (
    a => 'á',
    e => 'é',
    i => 'í',
    o => 'ó',
    u => 'ú',
    y => 'ý',
);

my $CSV_IN  = new_csv_in;
my $CSV_OUT = new_csv_out;

# The following variables are globals for simplicity
my $SUMMED_DIST             = 0;
my $WORD_COUNT              = 0;
my $COMPOUND_DICT_REF       = build_lc_map($COMPOUNDS, 0);
my $CUSTOM_DICT_REF         = build_lc_map($CUSTOM, 1);
my $PRE_STRESSED_VOWEL_DREF = build_lc_map('pre-stressed-vowel.csv', 1);

# If a derived word is listed here, a short vowel preceding the stress
# marker won't be converted to «e».
my $DONT_CONVERT_E_BEFORE_STRESS_SREF = build_lc_map('dont-convert-pre-stressed-e.csv', 0, 1);

# List of compounds which are stressed differently from our regular rules.
# Values indicate which part is the stressed one ('1' or '2').
my $Compound_Stress_Dict_Ref = build_lc_map($COMPOUND_STRESS, 1);

my $Start_Pattern_Aref = build_standard_patterns('startpron.csv', 1);
my $End_Pattern_Aref   = build_standard_patterns('endpron.csv',   0);

my $UNCONVERTED_DICT_REF;
my $CONVERTED_DICT_REF;
my $CASE_REDIRECT_REF;

# Mapping from SAMPA to the standard Lytspel spellings.
my $Map_Ref;

# The maximum length of keys that may occur in $Map_Ref.
my $Max_Key_Len;

# Set of Lytspel spellings.
my %Lytspel_Set;

# Set to which all processed custom entries are added (entries are lower-case and may be
# POS-tagged as per the 'gen_key' function).
my %PROCESSED_CUSTOM_SET;

# Ditto, for compounds.
my %PROCESSED_COMPOUND_SET;

# Mapping from prefixes to their Lytspel spellings, stress hints (1: stress prefix;
# 2: stress main word; 'A': let PhonEng determine stress), and a boolean stating whether the
# prefix is short (= it has just one syllable). Values are three-element array references.
my %PREFIXES;

# Mapping from suffixes to their Lytspel spellings.
my %SUFFIXES;

# A mapping from the final version if each word to it's stress-marked equivalent, e.g.
# seven -> séven.
my %Stress_Marked_Dict;

# build_standard_patterns $filename, $start: Create an array of leading (set $start = 1) or
# trailing (set $start = 0) pronunciations that should be standardized. Returns a reference to
# that array. Each array element is a hashref with tree entries:
#
# * trad (field 1): pattern matching the traditional spelling
# * pron_pattern (field 2): pattern matching the current pronunciation
# * fixed_pron (field 3): the pronunciation to use instead
#
# While in the CSV file, the first two fields are just simple strings, this function converts
# them into suitable regex strings that are anchored at the begin or end and also prevents
# accidental matches. For example, {trad => 'ate', pron_pattern => 'It$', fixed_pron => '@t'}
# would mean that words starting with 'ate' should be pronounced /@t/ instead of /It/. But the
# actually generated 'pron_pattern' is more complex to prevent /aI, eI, OI/ from accidentally
# matching.
sub build_standard_patterns {
    my ($filename, $start) = @_;
    my $pattern_aref = [];
    open my $fh, '<', $filename or die "Unable to open $filename $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $trad_pattern = $colref->[0];
        my $pron_pattern = $colref->[1];

        # /I/ is sometimes written /I#/
        $pron_pattern =~ s/(?<![aeO])I/I#?/g;

        if ($start) {
            $trad_pattern = "^$trad_pattern";
            $pron_pattern = "^$pron_pattern";
        } else {
            $trad_pattern .= '$';

            # Final /i:/ is occasionally written [I]
            $pron_pattern =~ s/i:$/(?:i:|I)/;
            $pron_pattern .= '$';

            # Prevent vowels from matching if stressed or if they are the second letter of a
            # digraph
            if (starts_with($pron_pattern, 'I')) {
                $pron_pattern = "(?<!['aeO])$pron_pattern";
            } elsif (starts_with($pron_pattern, 'oU')) {
                # Protect /oU/ after /I/ since /I@/ has a special meaning
                $pron_pattern = "(?<!['I])$pron_pattern";
            } elsif (starts_with($pron_pattern, '@')) {
                # Note: the combination /i:@/ @ «ia» is also prevented from accidentally
                # matching and must be listed separately if desired
                $pron_pattern = "(?<!['eiI:])$pron_pattern";
            }

            # Protect vowels at start of tradspell from certain digraph combinations
            if (starts_with($trad_pattern, 'i')) {
                $trad_pattern = "[^ae]$trad_pattern";
            }
        }

        push @$pattern_aref,
            {
            trad_pattern => $trad_pattern,
            pron_pattern => $pron_pattern,
            fixed_pron   => $colref->[2]
            };
    }

    return $pattern_aref;
}

# build_mapping: Create and return a mapping from SAMPA to the standard Lytspel spellings.
# Also returns the length of the longest key in the map and populates %Lytspel_Set.
sub build_mapping {
    my %dict;
    my $maxkeylen = 0;
    open my $fh, '<', $PHONEME_MAP or die "Unable to open $PHONEME_MAP: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $sampa   = $colref->[0];
        my $lytspel = $colref->[4];

        # Skip if SAMPA or Lytspel entry is missing or if SAMPA is '-'
        next unless valid_key($sampa) && $lytspel;

        $maxkeylen = max $maxkeylen, length($lytspel);
        $dict{$sampa}          = $lytspel;
        $Lytspel_Set{$lytspel} = 1;

        if ($lytspel =~ /r$/) {
            # If the spellings ends in «r», add a variant with a stress marker before the
            # final «r» to %Lytspel_Set
            my $stress_marked = substr($lytspel, 0, -1) . "'" . substr($lytspel, -1);
            $Lytspel_Set{$stress_marked} = 1;
        }

        # Add stressed variant if phoneme is a consonant followed by a vowel
        if ($sampa =~ /^${SAMPA_SIMPLE_CONSONANT_CLS}[$SAMPA_VOWELS]/) {
            my $stressed_key = substr($sampa, 0, 1) . "'" . substr($sampa, 1);
            my $stressed_val = "'$lytspel";
            $maxkeylen = max $maxkeylen, length($stressed_val);
            $dict{$stressed_key} = $stressed_val;
        }
    }

    close $fh;

    # Add context-specific spellings to %Lytspel_Set
    $Lytspel_Set{$_} = 1 for qw/al aw ay c eh iY n'g nn ow oy si ss s's ti uea uh ah oh/;
    return \%dict, $maxkeylen;
}

# build_unconverted_dict_and_case_redirects: Returns references to two hashes:
# 1. From keys (see 'gen_key' function) to the complete $IN_FILE entries describing them
# 2. From lower-cased forms of words containing capital letters to their cased form
#    (e.g. 'europe' -> 'Europe')
sub build_unconverted_dict_and_case_redirects {
    open my $infh, '<', $IN_FILE or die "Unable to open $IN_FILE: $!\n";
    my $colref = $CSV_IN->getline($infh);  # Skip header line
    my %unconverted_dict;
    my %case_redirect;

    while ($colref = $CSV_IN->getline($infh)) {
        my $word = $colref->[0];
        my $pos  = $colref->[1];
        my $key  = gen_key $word, $pos;
        $unconverted_dict{$key} = $colref;
        $case_redirect{lc $word} = $word if $word =~ /[A-Z]/;
    }

    close $infh;

    # Also add all prefixes followed by hyphen. This allows recognizing and handling them
    # in hyphenated forms, e.g. "re-elect".
    for my $prefix (keys %PREFIXES) {
        # We don't need a filled row here, since prefixes have already been converted
        $unconverted_dict{"$prefix-"} = [];
    }

    return \%unconverted_dict, \%case_redirect;
}

# standardize_begin_and_end_of_pron $pron, $tradspell: Possibly standardize the beginning
# and ending of a pronunciation based on the rules listed in 'startpron.csv' and
# 'endpron.csv' in order to reach consistency between similar-sounding words.
# If there is nothing to standardize, the word is returned unchanged.
sub standardize_begin_and_end_of_pron {
    my ($pron, $tradspell) = @_;
    my $ts_lower  = lc $tradspell;
    my $orig_pron = $pron;

    # Check if one of the start patterns matches
    for my $rule (@$Start_Pattern_Aref) {
        if ($ts_lower =~ $rule->{trad_pattern}) {
            # Check if rule can be applied -- if yes, we're done here, since only one can match
            last if $pron =~ s/$rule->{pron_pattern}/$rule->{fixed_pron}/;
        }
    }

    # Ditto end patterns
    for my $rule (@$End_Pattern_Aref) {
        if ($ts_lower =~ $rule->{trad_pattern}) {
            # Check if rule can be applied
            if ($pron =~ s/$rule->{pron_pattern}/$rule->{fixed_pron}/) {
                if ($pron =~ /^s:/) {
                    $pron = $orig_pron;  # Revert, since leading /s:/ is not allowed
                }
                last;                    # We're done since only one pattern can match
            }
        }
    }

    return $pron;
}

# delsep $str, $hyphens_too: Delete any occurrences of '=' (used as separator) from a string.
# If the second argument is true, hyphens ('-') are deleted as well.
sub delsep {
    my ($str, $hyphens_too) = @_;
    $str =~ s/=//g;
    $str =~ s/-//g if $hyphens_too;
    return $str;
}

# delsep $str: Delete any apostrophes (') from a string.
sub delapo {
    my ($str, $hyphens_too) = @_;
    $str =~ s/'//g;
    return $str;
}

# strip_acute_accents $word: Strip any acute accents from a word.
sub strip_acute_accents {
    my ($word) = @_;
    $word =~ s/á/a/g;
    $word =~ s/Á/A/g;
    $word =~ s/é/e/g;
    $word =~ s/É/E/g;
    $word =~ s/í/i/g;
    $word =~ s/Í/I/g;
    $word =~ s/ó/o/g;
    $word =~ s/Ó/O/g;
    $word =~ s/ú/u/g;
    $word =~ s/Ú/U/g;
    $word =~ s/ý/y/g;
    $word =~ s/Ý/Y/g;
    return $word;
}

# strip_leading_acute_accent $word: Strip the acute accent from the first letter of a word,
# if it starts with one. Otherwise the word is returned unchanged.
sub strip_leading_acute_accent {
    my ($word) = @_;
    if ($word =~ /^$Acute_Accent/i) {
        my $first_stripped = strip_acute_accents(substr $word, 0, 1);
        return $first_stripped . substr($word, 1);
    } else {
        return $word;
    }
}

# strip_all_accents $word: Strip any acute accents and diaereses from a word.
sub strip_all_accents {
    my ($word) = @_;
    $word =~ s/[áä]/a/g;
    $word =~ s/[Áä]/A/g;
    $word =~ s/[éë]/e/g;
    $word =~ s/[Éë]/E/g;
    $word =~ s/[íï]/i/g;
    $word =~ s/[Íï]/I/g;
    $word =~ s/[óö]/o/g;
    $word =~ s/[Óö]/O/g;
    $word =~ s/[úü]/u/g;
    $word =~ s/[Úü]/U/g;
    return $word;
}

# restore_apostrophe_and_strip_accents $word: Restore the apostrophe originally used in
# front of the stressed vowel and strip all acute accents and diaereses.
sub restore_apostrophe_and_strip_accents {
    my ($word) = @_;
    return $word if !$word;

    # Retrieve fully stress-marked version of word
    my $marked = $Stress_Marked_Dict{$word};
    if (!defined($marked)) {
        warn "No stress-marked version found for $word\n";
        $marked = $word;
    }

    # Don't add a stress marker at the very start of a word
    $marked =~ s/(.)($Acute_Accent)/$1'$2/gi;
    $marked = strip_all_accents $marked;
    return $marked;
}

# split_parts_basic $word: Helper function called by split_parts to do the actual work.
sub split_parts_basic {
    my ($word) = @_;
    $word = strip_acute_accents $word;
    my @parts = split $CONV_VOWEL, $word;

    # Postprocess parts to split some vowel sequences into two parts
    my $partstr = join '=', @parts;
    $partstr =~ s/\b([aeiou])([aeiou]rr)\b/$1==$2/g;
    $partstr =~ s/\b([iu])ar\b/$1==ar/g;
    $partstr =~ s/\boer\b/o==er/g;
    $partstr =~ s/^=aw=(,?)=/=a=w$1=/;               # leading «aw» before vowel is /aw/, not /O:/
    $partstr =~ s/\boi$/o==i/;                       # final «oi» is read as two vowels
    $partstr =~ s/\boi=c$/o==i=c/;                   # likewise in final «oic»
    ##print "$partstr\n";
    @parts = split '=', $partstr;
    return @parts;
}

# split_parts $word: Split a word into a list of parts that are other consonants or
# vowels and return this list.
#
# Elements (0, 2 etc.) are consonants, odd ones (1, 3 etc.) are vowels. Consonant parts
# may be empty. The word must contain only lowercase letters.
#
# An acute accent in the word (indicating the stressed syllable) will be converted into a
# unaccented vowel in the list of parts. It is, however, possible, that the accent changes
# the way in which parts are split – e.g. «oáiciss» (oasis) should be parsed as =o==ai=c=i=ss,
# not =oa==i=c=i=ss (using = to separate parts). In such cases, a comma will be inserted
# before the accented vowel to indicate that some kind of accent (acute or diaeresis) is
# needed to get the correct reading.
sub split_parts {
    my ($word) = @_;
    # Insert comma before accented vowel to check if that makes a difference in parsing
    my $word_with_comma  = $word =~ s/($Acute_Accent)/,$1/r;
    my @parts            = split_parts_basic $word;
    my @parts_with_comma = split_parts_basic $word_with_comma;
    my $partstr          = join '=', @parts;
    my $alt_partstr      = join '=', @parts_with_comma;

    # No comma is needed in the middle of the two-vowel sequences ia, ua, ion, oe
    $alt_partstr =~ s/\b([iu])=,=a\b/$1a/;
    $alt_partstr =~ s/\bi=,=o=n\b/ion=/;
    $alt_partstr =~ s/\bo=,=e\b/oe/;

    # Delete the comma to see if the alternative parsing looks nevertheless different
    # and hence must be used
    my $alt_partstr_wo_comma = $alt_partstr =~ s/,//r;

    # Preserve comma if needed
    @parts = split '=', $alt_partstr if $partstr ne $alt_partstr_wo_comma;
    return @parts;
}

# dist $str1, $str2: Calculate the Levenshtein edit distance between two strings, ignoring case.
# Separators and hyphens are deleted from both strings before doing the conversion;
# accented vowels are converted to their non-accented version.
sub dist {
    my ($str1, $str2) = @_;
    return distance(lc(strip_all_accents(delsep $str1, 1)), lc(strip_all_accents(delsep $str2, 1)));
}

# e_or_u_or_other $other, $left, $right, $tradspell: Return 'e', 'u', or $other depending on which
# is most similar to $tradspell. In case of a tie, 'e' is preferred over 'u' and $other is
# preferred over both. $other is ignored if it's is undefined or empty.
sub e_or_u_or_other {
    my ($other, $left, $right, $tradspell) = @_;

    # Schwa before vowels is always spelled «e»
    return 'e' if $right && $right !~ /^$SAMPA_CONSONANT_CLS/;

    my $result =
        dist($tradspell, "${left}e$right") <= dist($tradspell, "${left}u$right") ? 'e' : 'u';

    if ($other) {
        $result =
            dist($tradspell, "$left$other$right") <= dist($tradspell, "$left$result$right")
            ? $other
            : $result;
    }

    return $result;
}

# lookup_tagged_dict_entry $dict_ref, $tradspell, $pos: Look up a potentially POS-tagged
# word in a dictionary reference. $tradspell is converted to lower case prior to lookup.
# If no value is found, '' is returned.
sub lookup_tagged_dict_entry {
    my ($dict_ref, $tradspell, $pos) = @_;
    my $lower = lc $tradspell;
    return $dict_ref->{gen_key($lower, $pos)} // $dict_ref->{$lower} // '';
}

# any_short_vowel $left, $right, $tradspell, $pos, $allow_overwrite: Return any of the
# five vowel letters depending on which is most similar to $tradspell. Ties are resolved
# by preferring the left-most match from the following list: e, u, a, o, i. ('e' and 'u'
# are generally preferred because their sound is close to a schwa sound, the other vowel
# letters are ranked by how often they represent a schwa in tradspell.)
#
# If $allow_overwrite is true and a $tradspell/$pos entry exists in
# $PRE_STRESSED_VOWEL_DREF, the value listed there is always used instead of the above
# heuristic. This is used to overwrite entries where the Levenshtein similarity score gets
# it wrong or where a specific value (most often 'e') is required for consistency with
# related words.
sub any_short_vowel {
    my ($left, $right, $tradspell, $pos, $allow_overwrite) = @_;

    if ($allow_overwrite) {
        my $specific = lookup_tagged_dict_entry $PRE_STRESSED_VOWEL_DREF, $tradspell, $pos;

        if ($specific) {
            die "Invalid entry in pre-stressed-vowel.csv for $tradspell($pos): $specific"
                unless $specific =~ /^[aeiou]$/;
            return $specific;
        }
    }

    my $chosen  = '';
    my $olddist = 1000;

    for my $vowel (qw/e u a o i/) {
        my $newdist = dist($tradspell, "$left$vowel$right");

        if ($newdist < $olddist) {
            $chosen  = $vowel;
            $olddist = $newdist;
        }
    }

    return $chosen;
}

# combine $left, $right: Combine two strings into one.
# Except when $left ends with a stress marker ("'") or either string is empty, the strings are
# separated by '='.
sub combine {
    my ($left, $right) = @_;
    return $left =~ /'$/ || !$right || !$left ? "$left$right" : "$left=$right";
}

# combine_and_adjust $val, $left, $right, $tradspell, $pos: Combine $left and $val into
# a joined string, applying context-specific rules to the resulting spelling as suitable.
sub combine_and_adjust {
    my ($val, $left, $right, $tradspell, $pos) = @_;

    if ($val =~ /^'./) {
        # If $val is a stressed vowel (occurs only with «'ue» and its variants),
        # we invoke this method twice
        my $rest = substr($val, 1);
        return combine_and_adjust($rest,
            combine_and_adjust("'", $left, $rest . $right, $tradspell, $pos),
            $right, $tradspell, $pos);
    }

    if ($right eq '') {
        # End-of-word spellings

        if (($val eq '@' || $val eq 'a#') && $tradspell ne 'the') {
            # Final schwa becomes «er» if tradspell ends in ‹r› (typical for non-rhotic RP),
            # otherwise «a» (except in the article 'the')
            $val = $tradspell =~ /r$/ ? 'er' : 'a';
        } elsif ($val eq 'uee') {
            # Final «uee» becomes «uea» (just like schwa in general)
            $val = 'uea';
        } elsif ($val eq 'a') {
            # Final /a/ may be spelled «ah» (but shoudn't usually occur)
            $val = 'ah';
        } elsif ($val eq 'e') {
            # Final «e» /E/ becomes «eh»
            $val = 'eh';
        } elsif ($val eq 'ee' && $tradspell =~ /^(h|sh|w|m)e$/) {
            # Pronouns ‹he, she, we, me› are written irregularly
            $val = 'i';
        } elsif ($val eq 'er' && $left =~ /Y$/) {
            # Final /aI@`/ is written «yr», e.g. «fyr, in'spyr» ‹fire, inspire›
            $val = 'r';
        } elsif ($val eq 'er' && $left =~ /thh$/) {
            # Final /T@`/ is written «thur»
            chop $left;
            $val = 'ur';
        } elsif ($val eq 'o') {
            # Final /Q/ may be spelled «oh» (but shoudn't usually occur)
            $val = 'oh';
        } elsif ($val eq 'u') {
            # Final /V/ is spelled «uh»
            $val = 'uh';
        } elsif ($val eq 'k' && $left =~ /(?<!['aeiou])[ai]$/) {
            # «c» is used at the end of words ending in unstressed /ak/ or /Ik/
            $val = 'c';
        } elsif ($val eq 'l' && $left =~ /au$/) {
            # Final /O:l/ is written «all», e.g. «ball»
            $left =~ s/au$/al/;
        } elsif ($val eq 'x' && $left =~ /i$/ && $tradspell =~ /ics$/) {
            # Final ‹ics› /Iks/ remains unchanged for consistency with plural forms (ic=s)
            $val = 'c=s';
        } elsif ($left !~ /([fkpt]|th)$/) {
            # Final /s/ becomes «ss» and /z/ becomes «s» except after /f, k, p, t, T/
            if ($val eq 's') {
                $val = 'ss';
            } elsif ($val eq 'z') {
                $val = 's';
            }
        }
    }

    if ($val eq '@' && $right eq 'l' && $left =~ /[bkp]$/) {
        # Schwa is omitted between and of /b, k, p/ and final /l/
        $val = '';
    } elsif ($val eq '@' && $right eq 'm' && $left =~ /z$/) {
        # Final /z@m/ is written «sm»
        $val = '';
        chop $left;
        $left .= 's';
    } elsif ($val eq '@' && $right eq 'n' && $left =~ /[sz]h$/) {
        # Final /S@n/ becomes «tion» and /Z@n/ becomes «sion»
        $val = 'o';
        $left =~ s/sh$/ti/;
        $left =~ s/zh$/si/;
    } elsif ($val eq 'I#' && $left eq 'd') {
        # Initial /dI#/ is written «di» (for consistency with the «di» ‹de› prefix)
        $val = 'i';
    } elsif ($val =~ /^(@|a#|I#)$/ && $right =~ /^$SAMPA_SIMPLE_CONSONANT_CLS*'/) {
        # Any schwa followed by a stressed vowel can become «e/u/a/o/i» (in preference order)
        $val = any_short_vowel $left, $right, $tradspell, $pos, 1;
    } elsif ($val eq '@#') {
        # Some custom spellings use '@#' to request that the original vowel be retained
        # (for consistency with related words)
        $val = any_short_vowel $left, $right, $tradspell, $pos, 0;
    } elsif ($val eq '@') {
        if ($right eq 's' && $tradspell =~ /eous$/) {
            # Final ‹eous› becomes «uss» for consistency with other words ending in ‹ous›
            $val = 'u';
        } else {
            # /@/ becomes «e/u» depending on what's more similar to tradspell
            # (in preference order)
            $val = e_or_u_or_other('', $left, $right, $tradspell);
        }
    } elsif ($val eq 'a#') {
        # /a#/ becomes «a/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('a', $left, $right, $tradspell);
    } elsif ($val eq 'I#') {
        # /I#/ becomes «i/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('i', $left, $right, $tradspell);
    } elsif ($val eq 'ai' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «ai» /eI/ becomes «ay» at the end of words and before other vowels
        $val = 'ay';
    } elsif ($val eq 'au' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «au» /O:/ becomes «aw» at the end of words and before other vowels
        $val = 'aw';
    } elsif ($val eq 'ee' && $right !~ /^$SAMPA_CONSONANT_CLS/ && $left !~ /'$/) {
        # Unstressed «ee» /i:/ becomes «i» at the end of words and before other vowels
        $val = 'i';
    } elsif ($val eq 'oa'
        && $right     !~ /^$SAMPA_CONSONANT_CLS/
        && $tradspell !~ /^(know|owe)$/)
    {
        # «oa» /oU/ becomes «o» at the end of words and before other vowels
        # (except in a few irregular words)
        $val = 'o';
    } elsif (
        $val eq 'Y'
        && (   ($right && $right !~ /^($SAMPA_CONSONANT_CLS|@`$)/)
            || ($right eq '' && $left =~ /[$LYTSPEL_VOWELS]$/))
        )
    {
        # «y» /aI/ becomes «iy» before and (at the end of words) after other vowels
        # (except before final /@`/ -- that combination becomes «yr»)
        $val = 'iY';
    } elsif ($val eq 'Y' && $tradspell =~ /^(eye|eyeleteer)$/) {
        # 'eye' (and its irregular derivates) remains irregular
        $val = 'e=y';
    } elsif ($val eq 'oi' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «oi» /OI/ becomes «oy» at the end of words and before other vowels
        $val = 'oy';
    } elsif ($val eq 'ou' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «ou» /aU/ becomes «ow» at the end of words and before other vowels
        $val = 'ow';
    } elsif ($val eq 'uu' && $right !~ /^$SAMPA_CONSONANT_CLS/ && $tradspell !~ /^t[ow]o$/) {
        # «uu» /u:/ becomes «u» at the end of words and before other vowels
        # (except in ‹too, two›)
        $val = 'u';
    } elsif ($val eq 'ng' && $right =~ /^k/) {
        # Before /k/, «n» is pronounced /N/ rather then /n/
        $val = 'n';
    } elsif ($val eq 'n' && $right =~ /^k/ && $left !~ /^('?[eiu]|[cn]='?o)$/) {
        # Before /k/, «n» becomes «nn» to distinguish it from /N/, unless the word starts with
        # «con, en, in, non, un»
        $val = 'nn';
    } elsif ($val eq 'nng' && $left =~ /^('?[eiu]|[cn]='?o)$/) {
        # «nng» becomes just «ng» in words starting with «con, en, in, non, un»
        $val = 'ng';
    } elsif ($val eq 'th' && $right eq '@`') {
        # Change 'th' before final 'er' – it will become 'thur' in the next step
        $val = 'thh';
    } elsif ($val eq 'dh' && (exists $Use_Th{$tradspell} || $right eq '@`')) {
        # 'dh' becomes 'th' in a handful of words and in those ending in /D@`/
        $val = 'th';
    } elsif ($val eq 'r' && $left =~ /r$/) {
        # Eliminate double «r»
        $val = '';
    }

    if ($val =~ /^[aou]/) {
        # /s/ becomes «ss» between any vowel and a vowel starting with «a, o, u»
        $left =~ s/([$LYTSPEL_VOWELS]=)s($OPT_STRESS_MARKER)$/$1ss$2/;
    } elsif ($val =~ /^'?[eiY]/) {
        # /s/ becomes «c» between any vowel and a vowel starting with «e, i, y»
        $left =~ s/([$LYTSPEL_VOWELS]=)s($OPT_STRESS_MARKER)$/$1c$2/;
    }

    if ($val !~ /^['eiYyh]/) {
        # Non-final /k/ becomes «c» unless followed by any of «e, i, y» or «h»
        $left =~ s/k($OPT_STRESS_MARKER)$/c$1/;
    }

    if ($val =~ /^[$LYTSPEL_VOWELS]/) {
        # /z/ becomes «s» between two vowels
        $left =~ s/([$LYTSPEL_VOWELS]=)z($OPT_STRESS_MARKER)$/$1s$2/;
    }

    return combine($left, $val);
}

# starts_with $haystack, $needle: Compares two strings, checking if $haystack starts with $needle.
sub starts_with {
    my ($haystack, $needle) = @_;
    return substr($haystack, 0, length $needle) eq $needle;
}

# ends_with $haystack, $needle: Compares two strings, checking if $haystack ends with $needle.
sub ends_with {
    my ($haystack, $needle) = @_;
    return substr($haystack, -(length $needle)) eq $needle;
}

# insert_hyphens_as_needed $converted, $tradspell: Insert hyphens where necessary to prevent
# misreadings in words such as «co-orde'naition» ‹coordination›. Returns the converted word
# with hyphens added as needed.
sub insert_hyphens_as_needed {
    my ($converted, $tradspell) = @_;

    # Skip words from which separators have already been stripped (or which don't contain any)
    return $converted if $converted !~ /=/;

    # Eliminate repeated separators
    $converted =~ s/==/=/g;
    my $rest          = delsep $converted;
    my $rest_with_sep = $converted;
    my $reconstructed = '';

    # Try placing separators after each possible longest multigraph
OUTER: while ($rest && $rest_with_sep) {
        if ($rest =~ /^'/ && $rest_with_sep =~ /^'/) {
            # Stress marker encountered
            $reconstructed .= "'";
            $rest          = substr $rest,          1;
            $rest_with_sep = substr $rest_with_sep, 1;
            next OUTER;
        }

        my $charcount = min 4, length $rest;
        # Which char sequence do we expected (until first separator)?
        (my $expected, $rest_with_sep) = split /=/, $rest_with_sep, 2;

        while ($charcount) {
            my $start      = substr $rest, 0, $charcount;
            my $inner_rest = substr $rest, $charcount;

            if (exists $Lytspel_Set{$start}) {

                if ($charcount > length $expected) {
                    # Match was too long, insert hyphen for disambiguation
                    $reconstructed .= "$expected-";
                    die "Sanity check failed multigraph disambiguation of '$converted' "
                        . "($tradspell): $expected... != $rest"
                        if $expected ne substr($rest, 0, length $expected);
                    $rest = substr $rest, length $expected;
                    next OUTER;
                } elsif ($start eq $expected) {
                    # Correct sequence matched
                    $reconstructed .= "$expected=";
                    $rest = $inner_rest;
                    next OUTER;
                } else {
                    die "Divergent matches during multigraph disambiguation of '$converted' "
                        . "($tradspell): $start+$inner_rest vs. $expected+$rest_with_sep\n";
                }
            }

            $charcount--;
        }

        die "Unexpected multigraph sequence found in '$converted' ($tradspell), "
            . "unexpected rest: '$rest'\n";
    }

    # Check that both have been consumed
    die "Unexpected rest '$rest' after multigraph disambiguation of
        . '$converted' ($tradspell)\n"
        if $rest;
    die "Unexpected separated rest '$rest_with_sep' after multigraph disambiguation of "
        . "'$converted' ($tradspell)\n"
        if $rest_with_sep;

    # Strip trailing separator and remove unnecessary hyphens
    $reconstructed =~ s/=$//;
    $reconstructed =~ s/-('?r)/=$1/g;       # not needed before «r»
    $reconstructed =~ s/a-([lw])/a=$1/g;    # not needed for «al, aw»
    $reconstructed =~ s/([aeou])-h/$1=h/g;  # not needed for «ah, eh, oh, uh»
    $reconstructed =~ s/ee-i/ee=i/g;        # not needed for «eei» (only used in a quasi-compound)
    $reconstructed =~ s/i-er/i=er/g;        # not needed for «ier»
    $reconstructed =~ s/ue-([ea])/ue=$1/g;  # not needed for «uee» and «uea»
    $reconstructed =~ s/u-err/u=err/g;      # not needed for «uerr»
    $reconstructed =~ s/s-sh/s=sh/g;        # not needed for «ssh» (rarely in foreign words)
    $reconstructed =~ s/o-(a[ai])/o=$1/g;   # not used for «oaa, oai»
    $reconstructed =~ s/o-e(?!e)/o=e/g;     # not used for «oe»
    $reconstructed =~ s/o-i=c$/o=i=c/;      # not used for final «oic»
    $reconstructed =~ s/o-i=c=([li])/o=i=c=$1/;  # nor in its derivates «oicl(li), oicism»
    $reconstructed =~ s/o-i$/o=i/;               # not needed for final «oi»
    $reconstructed =~ s/([st])-i/$1=i/g;         # not needed for «si, ti»
    $reconstructed =~ s/([iu])-a/$1=a/g;  # not used for «ia, iaa, iai, iay, uaa, ua, uai, uay»
    $reconstructed =~ s/a-i$/ai/;         # not needed in final «ai» (only used in an abbrev.)
    $reconstructed =~ s/^a=d-h/a=d=h/;    # not used in initial «adh»
                                          # «iy» before consonant doesn't need a hyphen
    $reconstructed =~ s/i-Y=('|$LYTSPEL_CONSONANT)/iY=$1/g;

    # Treat ‹bio..., micro...› as compound, even if the 2nd part isn't listed
    $reconstructed =~ s/o-a/o=a/ if $tradspell =~ /^(bio|micro)/;
    # Likewise words ending in «ism» after «o»
    $reconstructed =~ s/o-i=s=m$/o=i=s=m/;

    # Add hyphen before 'w' and 'y’ where needed to distinguish them from the second vowel
    # of «aw/ow/ay/iy/oy»
    $reconstructed =~ s/=a=w\b/=a-w/g;        # «aw» on the start of words doesn't need a hyphen
    $reconstructed =~ s/\bo=w\b/o-w/g;
    $reconstructed =~ s/\b([aio]=)y\b/$1-y/g;

    return $reconstructed;
}

# restore_capitalization $converted, $tradspell: Restore the proper capitalization of a converted
# word. This functions also does a few more tasks:
#
# * Insert hyphens where necessary to prevent misreadings in words such as
#   «am'neesi-ak» ‹amnesiac›
# * Delete separators ('=')
# * Handle the placement of contraction markers that haven't been handled before (such as
#   «ma'm» ‹ma'am›).
sub restore_capitalization {
    my ($converted, $tradspell) = @_;

    $converted = insert_hyphens_as_needed $converted, $tradspell;
    # Delete separators ('=') and convert capital letters to lower case (vowel «Y» as
    # distinguished from consonant «y»)
    $converted = lc(delsep $converted);
    if ($tradspell =~ /[A-Z].*[A-Z]/) {
        # Handle word with two or more uppercase letters

        if ($tradspell =~ /^Ma?c[A-Z]/) {
            if ($converted =~ /^m[ae]c?$LYTSPEL_CONSONANT_POST_PROC*'/i) {
                # Write names starting with ‹Mc› or ‹Mac› /m@k/ followed by a stressed and
                # capitalized syllable as «Mc» + capital letter (dropping the stress marker)
                $converted =~ s/'//;

                if ($tradspell =~ /[CK](?!n)/) {
                    # If the original word contains a capitalized C or K, we repeated the
                    # capitalized /k/ sound, e.g. «McCoy, McCay» ‹...McKay› – but not
                    # ‹McKnight›
                    $converted =~ s/m[ae](.)/Mc\U$1/;
                } else {
                    $converted =~ s/m[ae]c?(.)/Mc\U$1/;
                }
            } elsif ($converted =~ /^mc/) {
                # Fix derivates of already converted words (e.g. plural forms)
                $converted =~ s/^mc(.)/Mc\U$1/;
            }
        } elsif ($tradspell eq 'NutraSweet') {
            # Fix some words with inner capitalization
            $converted =~ s/s/S/;
        } elsif ($tradspell eq 'MeV') {
            $converted =~ s/v/V/;
        }
    }

    # Capitalize first letter after optional stress marker (if not yet done)
    if ($tradspell =~ /^[A-Z]/) {
        if ($converted =~ /^\p{Ll}/) {
            $converted = ucfirst($converted);
        } elsif ($converted =~ /^'\p{Ll}/) {
            $converted =~ s/(.)(.)/$1\u$2/;
        }
    }

    # Or very occasionally the second letter
    if ($tradspell =~ /^[a-z][A-Z]/ && $converted =~ /^'?\p{Ll}/) {
        $converted =~ s/('?\p{Ll})(.)/$1\u$2/;
    }

    if ($tradspell =~ /'/) {
        # Handle contractions

        if ($tradspell =~ /'(er|en|am)$/ && $tradspell !~ /^where/) {
            # Place contraction marker in front of the last letter
            $converted =~ s/'//;
            $converted =~ s/(.)$/'$1/;
        } elsif ($tradspell =~ /'c/) {
            # Move before corresponding consonant in converted word
            $converted =~ s/'//;
            $converted =~ s/c/'c/;
        } elsif ($tradspell =~ /'p/) {
            $converted =~ s/'//;
            $converted =~ s/p/'p/;
        } elsif ($tradspell =~ /O'/ && $converted =~ /O[ar]$LYTSPEL_CONSONANT_POST_PROC*'/i) {
            # Retain capitalized ‹O'› /oU/ in Irish names before a stessed syllable
            # (the stress marker is dropped and the first letter after the apostrophe is
            # capitalized as well)
            $converted =~ s/'//;
            $converted =~ s/Oa?(.)/O'\U$1/;
        }
    }

    return $converted;
}

# accentify $text: Add an acute accent on top of the first letter in $text, which must be
# a lower-case vowel.
sub accentify {
    my ($text) = @_;
    my $first = substr $text, 0, 1;
    my $rest  = substr $text, 1;
    my $first_acc = $AcuteAccents{$first};
    die "'$text' doesn't start with lower-case vowel\n" unless defined $first_acc;
    return $first_acc . $rest;
}

# is_short $vowel: Return a true value if $vowel is a short vowel, a false value otherwise.
# The vowel sequence must be lower-case.
sub is_short {
    my ($vowel) = @_;
    return $vowel =~ /^([aeiou](rr)?|[ei]r|ion|oor?)$/;
}

# is_short_or_unstressed $vowel: Return a true value if $vowel is a short vowel or one of
# the sequences «ia, ier, oe, ua» or a vowel sequence ending in «rr», as these are considered
# typically unstressed.
sub is_short_or_unstressed {
    my ($vowel) = @_;
    return is_short($vowel) || $vowel =~ /^(ier|[iu]a|oe)$/ || $vowel =~ /rr$/;
}

# is_two_vowels $text: Return a true value if $text is one of the sequence «ia, ier, ion, oe, ua»
# which represent two vowels.
sub is_two_vowels {
    my ($text) = @_;
    return $text =~ /^(ier|ion|[iu]a|oe)$/;
}

# accentify_last $text: Add an acute accent on top on the last vowel in $text, which
# must be a lower-case vowel or vowel combination. The sequences «ia, ier, ion, oe, ua»
# represent **two* vowels -- in these cases, the second of them gets the accent.
# Otherwise the accent is added to the first letter.
sub accentify_last {
    my ($text) = @_;
    if (is_two_vowels $text) {
        my $first = substr $text, 0, 1;
        my $rest  = substr $text, 1;
        return $first . accentify($rest);
    }

    return accentify $text;
}

# accentify_before_final_combis @parts: If the word given by @parts (an array of
# non-vowel/vowel parts) ends in certain combinations such as «tion» or «ic», the vowel
# before this combination (or sometimes in this combination) is marked with an accent as
# likely stressed.
#
# Otherwise undef is returned.
sub accentify_before_final_combis {
    my @parts   = @_;
    my $wordstr = join('=', @parts);

    if ($wordstr =~ /=ee$/) {
        # Final ee is stressed
        $parts[-1] = accentify($parts[-1]);
        return join('', @parts);
    } elsif ($wordstr =~ /[st]=ion$/) {
        # Vowel before tion, sion is stressed
        $parts[-3] = accentify_last($parts[-3]);
        return join('', @parts);
    } elsif ($wordstr =~ /=i=c[ls]?$/) {
        # ic, icl, ics
        $parts[-4] = accentify_last($parts[-4]);
        return join('', @parts);
    } elsif (scalar @parts >= 5 && $wordstr =~ /(gr=e=f=i|=i=(cll|t)=i|l=e=j=i)$/) {
        # grefi, iclli (derivated of icl), iti, leji
        $parts[-5] = accentify_last($parts[-5]);
        return join('', @parts);
    } elsif (scalar @parts >= 6 && $wordstr =~ /l=e=j=i=st$/) {
        # lejist (derivate of leji)
        $parts[-6] = accentify_last($parts[-6]);
        return join('', @parts);
    } elsif (scalar @parts == 4 && $wordstr =~ /=[ai]$/ && !is_two_vowels($parts[1])) {
        # If a word ends in -a or -i and has just two syllables, the first one is stressed
        $parts[1] = accentify_last($parts[1]);
        return join('', @parts);
    }

    return undef;
}

# accentify_first_long_vowel @parts: Add an acute accent on the first long vowel in @parts
# If the word doesn't have any long vowels, undef is returned instead.
# However, a few long vowels occuring at the end of words with certain endings such as
# «ait» are excepted – if the stress would fall on such a vowel, undef is returned instead.
sub accentify_first_long_vowel {
    my @parts   = @_;
    my $partstr = join('=', @parts);
    my $len     = scalar @parts;

    for (my $i = 1 ; $i < $len ; $i += 2) {
        if (!is_short_or_unstressed($parts[$i])) {
            $parts[$i] = accentify($parts[$i]);

            if ($i == $len - 2 && $partstr =~ /=(ai=t|y=[st])$/) {
                # Final ait, ys, yt are considered unstressed
                return undef;
            } elsif ($i == $len - 1 && $partstr =~ /(=y|th=ur)$/) {
                # Ditto final y and the vowel in final "thur", which is actually an r-colored schwa
                return undef;
            } else {
                return join('', @parts);
            }
        }
    }

    return undef;
}

# accentify_second_if_needed @parts: If a word starts with a short vowel or 'di' or 'ri',
# add the accent on the second vowel. But if that vowel is 'er' or, otherwise, if the
# first vowel is 'er', an accent is added to the first vowel that is NOT 'er'.
#
# If neither case applied, undef is returned instead.
sub accentify_second_if_needed {
    my @parts          = @_;
    my $partstr        = join('=', @parts);
    my $part_to_stress = 1;
    my $len            = scalar @parts;

    if ((!$parts[0] && is_short $parts[1]) || $partstr =~ /^[dr]=i/) {
        # Skip initial short vowel and di, ri at start of vowel
        $part_to_stress = 3;
    }

    for (my $i = $part_to_stress ; $i < $len ; $i += 2) {
        # Skip the vowel 'er'
        if ($parts[$i] eq 'er') {
            $part_to_stress = $i + 2;
        } else {
            last;
        }
    }

    # Add an accent only if it doesn't fall on the first vowel anyway
    if ($part_to_stress > 1 && $part_to_stress < $len) {
        $parts[$part_to_stress] = accentify($parts[$part_to_stress]);
        return join('', @parts);
    }

    return undef;
}

# find_default_stress $word: Find the vowel that is assumed to be stressed.
# An acute accent is placed on this vowel.
# The word MUST be lower-case.
sub find_default_stress {
    my ($word) = @_;

    # Split in vowel/non-vowel sequences
    my @parts = split_parts $word;

    # If there are no vowels, return word as is
    return $word if @parts <= 1;

    # If there is just one vowel, it's the stressed one
    if (@parts <= 3) {
        $parts[1] = accentify($parts[1]);
        return join('', @parts);
    }

    # Stress vowel before certain final combinations
    my $accentified = accentify_before_final_combis @parts;
    return $accentified if defined $accentified;

    # Stress the first long vowel, if any (with certain exceptions)
    $accentified = accentify_first_long_vowel @parts;
    return $accentified if defined $accentified;

    # If a word starts with a short vowel, the next one is assumed to be stressed;
    # if the vowel to be accentified would be 'er', the next one gets the accent instead
    $accentified = accentify_second_if_needed @parts;
    return $accentified if defined $accentified;

    # Default case: Assume that first vowel is the stressed one
    $parts[1] = accentify($parts[1]);
    return join('', @parts);
}

# strip_or_adjust_accent_as_needed $word, $lc_word, $default_stress: Strip the acute
# accent from a word if it is not needed to indicate stress, or change it to a diaeresis
# if needed.
#
# $lc_word is the lowercase version of the word; $default_stress is the same but with the
# vowel which takes the stress by default accented, and optionally with a comma inserted
# before the ACTUALLY stressed vowel to indicate that some kind of diacritic is needed to
# parse the vowel sequence correctly. For example, "o,áiciss" (oasis) signals that a break
# is needed there as otherwise the word would be read as "oa-i-c-i-ss".
#
# If $lc_word and $default_stress, the accent will simply be stripped because it is not
# needed. If they differ only by the presence of a comma, the acute accent will be
# changed to a diaeresis which should be preserved even if stress marking is turned off
# -- e.g. "oäiciss" indicates the correct pronunciation regardless of whether or not
# stress markers are used.
sub strip_or_adjust_accent_as_needed {
    my ($word, $lc_word, $default_stress) = @_;
    my $orig_word = $word;

    if ($lc_word eq $default_stress) {
        $word = strip_acute_accents $word;
    } elsif ($default_stress =~ /,/) {
        $default_stress =~ s/,//;
        if ($lc_word eq $default_stress) {
            # Change acute accent to diaeresis
            $word =~ s/á/ä/;
            $word =~ s/Á/Ä/;
            $word =~ s/é/ë/;
            $word =~ s/É/Ë/;
            $word =~ s/í/ï/;
            $word =~ s/Í/Ï/;
            $word =~ s/ó/ö/;
            $word =~ s/Ó/Ö/;
            $word =~ s/ú/ü/;
            $word =~ s/Ú/Ü/;
        }
    }

    # Special cases: «ey» ‹eye› has just one vowel and so doesn't need an accent;
    # «Tyyaan» ‹Taiyuan› is stressed regularly but our algorithm cannot detect it
    $word = strip_acute_accents $word if $word =~ /^(éy$|týy)/i;

    $Stress_Marked_Dict{$word} = $orig_word;
    return $word;
}

# do_mark_stress $word: Helper function that removes the acute accent from the stressed
# vowel if this vowel is assumed to be stressed by default.
sub do_mark_stress {
    my ($word) = @_;
    # Delete stressed vowel if there is no need for it, or change it to a diaereses
    my $lc_word        = lc $word;
    my $default_stress = find_default_stress $lc_word;
    return strip_or_adjust_accent_as_needed $word, $lc_word, $default_stress;
}

# mark_stress $converted, $tradspell: Replace the stress marker with an acute accent over
# the stressed vowel. When this accent falls to the vowel assumed to be stressed by default,
# it is removed.
sub mark_stress {
    my ($converted, $tradspell) = @_;

    if ($tradspell =~ /'/ && $tradspell !~ /^N'D/) {
        # $tradspell already has an apostrophe, so we assume it's a contraction marker,
        # not a stress marker, and return the word unchanged
        $Stress_Marked_Dict{$converted} = $converted;
        return $converted;
    }

    # Convert stress marker into stressed vowel
    $converted =~ s/'a/á/;
    $converted =~ s/'A/Á/;
    $converted =~ s/'e/é/;
    $converted =~ s/'E/É/;
    $converted =~ s/'i/í/;
    $converted =~ s/'I/Í/;
    $converted =~ s/'o/ó/;
    $converted =~ s/'O/Ó/;
    $converted =~ s/'u/ú/;
    $converted =~ s/'U/Ú/;
    $converted =~ s/'y/ý/;
    $converted =~ s/'Y/Ý/;

    return do_mark_stress $converted;
}

# has_long_vowel $word: Return true iff $word contains at least one long vowel.
# Long vowels typically considered unstressed don't count.
sub has_long_vowel {
    my ($word)      = @_;
    my $word_simple = strip_acute_accents(lc $word);
    my @parts       = split_parts $word_simple;
    my $len         = scalar @parts;

    for (my $i = 1 ; $i < $len ; $i += 2) {
        if (!is_short_or_unstressed($parts[$i])) {
            return 1;
        }
    }

    return 0;
}

# stress_first_vowel $word, $pos: Add an acute accent on vowel number $pos in $word.
# $pos is 0-indexed, so the first vowel is 0!
sub stress_vowel {
    my ($word, $pos) = @_;
    my $lc_word = lc $word;
    my @parts   = split_parts $lc_word;
    $parts[$pos * 2 + 1] = accentify($parts[$pos * 2 + 1]);
    my $result = join('', @parts);

    # Restore case if needed
    $result = ucfirst $result if $lc_word ne $word;
    return $result;
}

# convert_hyphens_to_diaereses $word: Replace hyphens followed by vowels by a diaeresis
# placed on top of the vowel, e.g. "po-it" becomes "poït".
sub convert_hyphens_to_diaereses {
    my ($word) = @_;
    $word =~ s/-a/ä/g;
    $word =~ s/-e/ë/g;
    $word =~ s/-i/ï/g;
    $word =~ s/-o/ö/g;
    $word =~ s/-u/ü/g;
    return $word;
}

# convert_pron $pron, $tradspell, $pos: Convert a pronunciation.
sub convert_pron {
    my ($pron, $tradspell, $pos) = @_;
    return '' unless $pron;  # Empty input
    $pron = standardize_begin_and_end_of_pron $pron, $tradspell;

    my $unconverted = $pron;
    my $converted   = '';

OUTER: while ($unconverted) {
        my $charcount = min $Max_Key_Len, length $unconverted;

    INNER: while ($charcount) {
            my $start = substr $unconverted, 0, $charcount;
            my $rest  = substr $unconverted, $charcount;

            # No sound starts with '`' or ':'
            if ($rest =~ /^[`:]/) {
                $charcount--;
                next INNER;
            }

            my $val = $Map_Ref->{$start};
            if (defined $val) {  # Match found
                $converted   = combine_and_adjust $val, $converted, $rest, $tradspell, $pos;
                $unconverted = $rest;
                next OUTER;
            }

            $charcount--;
        }

        die "No match found for converting /$pron/ ($tradspell), "
            . "unconverted part: /$unconverted/\n";
    }

    $converted = restore_capitalization $converted, $tradspell;
    $converted = mark_stress $converted,            $tradspell;
    return $converted;
}

# XXX Adapt decompose to use prefix|suffix.csv instead of .list (note that some prefixes,
# e.g. ‹di›, are NOT auto-recognized but have been added manually in compounds-manual.csv)

# build_prefix_dict: Populate the prefix dictionary.
sub build_prefix_dict {
    my $filename = 'prefix.csv';

    open my $fh, '<', $filename or die "Unable to open $filename: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        unless (scalar @$colref == 3) {
            warn "$filename lines should have 3 columns but got: ", join(',', @$colref), "\n";
            next;
        }

        my ($word, $pron, $stress_hint) = @$colref[0 .. 2];

        warn "Duplicate key '$word' in $filename\n" if exists($PREFIXES{$word});
        warn "Unexpected stress hint for prefix $word: '$stress_hint'\n"
            unless $stress_hint =~ /^[12A]$/;

        my $converted = convert_pron $pron, $word, '';

        # Final «ss» becomes just «s», e.g. «dis»
        $converted =~ s/ss$/s/;
        # Final schwa should be «e» rather than «a» because other letters will follow
        $converted =~ s/(?<![a])a$/e/;
        # Prefixes are written without an accent of the first letter
        $converted = strip_leading_acute_accent $converted;
        # Short prefixes have just one syllable
        my @parts    = split_parts $converted;
        my $is_short = @parts <= 3 && !is_two_vowels($parts[1]);

        $PREFIXES{$word} = [$converted, $stress_hint, $is_short];
    }

    close $fh;
}

# build_suffix_dict: Populate the suffix dictionary.
sub build_suffix_dict {
    my $filename = "suffix.csv";

    open my $fh, '<', $filename or die "Unable to open $filename: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        unless (scalar @$colref == 2) {
            warn "$filename lines should have 2 columns but got: ", join(',', @$colref), "\n";
            next;
        }

        my ($word, $pron) = @$colref[0 .. 1];
        warn "Duplicate key '$word' in $filename\n" if exists($SUFFIXES{$word});
        my $suffix = convert_pron $pron, $word, '';
        $SUFFIXES{$word} = $suffix;
    }

    close $fh;
}

# prepare_pron $pron: Fix the pronunication of a word by normalizing non-standard forms.
sub prepare_pron {
    my $pron = shift;
    # Normalize alternative forms of the r-colored schwa
    $pron =~ s/(?<![ei])\@r|\@`r|a#r/\@`/g;
    # If there are multiple stress markers, remove all but the last one
    $pron =~ s/'(?=.*')//g;
    return $pron;
}

# handle_custom_entry $custom_entry, $colref, $tradspell, $pos: Handle a word listed in
# the custom.csv file. The $custom_entry may have one of the following values:
#
# * B: use British (RP) pronunciation
# * A: use American (GA) pronunciation
# * P: use the PhonEng pronunciation
# * D: don't add the word to the output dictionary (used for rare foreign words or names)
# * O: leave the spelling of the word unchanged
# * /...: Use the spelling printed after the slash. This is necessary in a few cases
#   to handle abbreviations correctly (e.g. ‹kWh› should become «kWo», for «kilewot-our»)
#
# Alternatively, a custom pronunciation may be given which is then used to generate the
# final spelling (assumed to have at least two characters, otherwise a warning is printed
# and the entry is ignored).
sub handle_custom_entry {
    my ($custom_entry, $colref, $tradspell, $pos) = @_;
    $PROCESSED_CUSTOM_SET{gen_key(lc $tradspell, $pos)} = 1;

    return $tradspell if $custom_entry eq 'O';  # Leave word unchanged
    return '' if $custom_entry eq 'D';          # Delete word

    my $pron = '';

    if ($custom_entry eq 'B') {
        $pron = $colref->[3];
    } elsif ($custom_entry eq 'A') {
        $pron = $colref->[4];
    } elsif ($custom_entry eq 'P') {
        $pron = $colref->[5];
    } elsif ($custom_entry =~ m#/(.*)#) {
        return $1;                              # use custom spelling given after '/'
    } elsif (length($custom_entry) > 1) {
        $pron = $custom_entry;
    }

    if ($pron) {
        $pron = prepare_pron $pron;
        return convert_pron $pron, $tradspell, $pos;
    } else {
        warn "Unexpected custom entry for $tradspell: $custom_entry\n";
    }
}

# Unify a sound that may be pronounced differently in two accents. Arguments:
#
# * $rp: British pronunciation
# * $ga: American pronunciation
# * $phoneng: PhonEng pronunciation (optional)
# * $alt1: how the vowel is pronounced in RP (treated as a regex)
# * $alt2: how it is pronounced in GA (treated as a regex)
# * $winner: the pronouncation that should be used
# * $tradspell: the traditional spelling (used for debugging/logging)
# * $suppress_warning: set to a true value to suppresss a warning if unification isn't possible
#   (useful for unreliable latterns)
sub unify_sound {
    my ($rp, $ga, $phoneng, $alt1, $alt2, $winner, $tradspell, $suppress_warning) = @_;

    my $rp_alt1_count = () = $rp =~ /$alt1/g;
    my $ga_alt2_count = () = $ga =~ /$alt2/g;

    return $rp, $ga, $phoneng unless $rp_alt1_count && $ga_alt2_count;  # Nothing to do

    # Split on either alternative (NOT matching if /`/ as in /@`/ follows)
    my @rp_split      = split /($alt1|$alt2)(?!`)/, $rp;
    my @ga_split      = split /($alt1|$alt2)(?!`)/, $ga;
    my @phoneng_split = split /($alt1|$alt2)(?!`)/, $phoneng;
    my $rp_elem_count = scalar @rp_split;

    unless ($rp_elem_count == scalar @ga_split) {
        warn "Note: Cannot unify $tradspell pronouncations re $alt1/$alt2\n"
            unless $suppress_warning;
        return $rp, $ga, $phoneng;
    }

    # PhonEng handles «er» /@`/ correctly hence we don't modify it
    my $unify_phoneng_too = $rp_elem_count == scalar @phoneng_split && $winner ne '@`';

    for my $i (0 .. $rp_elem_count - 1) {
        if ($rp_split[$i] =~ /^$alt1$/ && $ga_split[$i] =~ /^$alt2$/) {
            $rp_split[$i] = $winner;
            $ga_split[$i] = $winner;

            $phoneng_split[$i] = $winner
                if $unify_phoneng_too && $phoneng_split[$i] =~ /^($alt1|$alt2)$/;
        }
    }

    $rp = join '', @rp_split;
    $ga = join '', @ga_split;

    $phoneng = join '', @phoneng_split if $unify_phoneng_too;

    return $rp, $ga, $phoneng;
}

# Unify the sound used in different pronunciations in cases where a specific vowel
# pronunciation should "win". Generally, unification is only attempted if RP and GA differ;
# otherwise the given pronunciations are returned unchanged. Redundant pronunciations
# (identical to an earlier one) are eliminated in any case.
sub unify_sounds {
    my ($rp, $ga, $phoneng, $tradspell) = @_;
    $rp      = prepare_pron $rp;
    $ga      = prepare_pron $ga;
    $phoneng = prepare_pron $phoneng;

    # Discard GA if identical to RP
    $ga = '' if $ga eq $rp;

    # If PhonEng has /Nk/ where RP/GA have /nk/, use the former as it's usually correct
    if ($phoneng =~ /Nk/ && $rp =~ /nk/) {
        ($rp, $phoneng) = unify_sound $rp, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0;
        ($ga, $phoneng) = unify_sound $ga, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0
            if $ga;
    }

    return $rp, $ga, $phoneng unless $ga;  # Nothing more to unify

    # Unify vowels:
    # pair, share, variation -> «air»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'e@', 'Er', 'e@', $tradspell, 0;
    # cheer, year, peculiar -> «eer»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'i:?@', 'Ir', 'i@', $tradspell, 0;
    # poor, tour -> «oor»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'U@', 'Ur', 'Ur', $tradspell, 1;
    # number, modern -> «er» (schwa vs. r-colored schwa)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, '(?<![ei])@', '@`', '@`', $tradspell, 1;
    # port, ignore, keyboard, floral -> /or/ (once «oar», now simply «or»)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'or', 'or', $tradspell, 1;
    # sorry, tomorrow -> «orr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Qr', 'O:r', 'Qr', $tradspell, 0;
    # for, dinosaur -> «or»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'O:r', 'O:r', $tradspell, 0;
    # encourage, current -> «urr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Vr', '3:r?', 'Vr', $tradspell, 0;
    # due, neutral, tune -> «ue»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'(?:u:|U)", "(?<![j])'u:", "'U:",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j(?:u:|U)", "(?<![j'])u:", "U:",
        $tradspell, 0;
    # during, neural -> «uer» (/ju:r/ or /jUr/ in RP, /Ur/ in GA)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'(?:u:|U)r", "(?<![j])'Ur", "'U:r",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j(?:u:|U)r", "(?<![j'])Ur", "U:r",
        $tradspell, 0;

    return $rp, $ga, $phoneng;
}

# choose_nearer_or_shorter $first, $second, $tradspell: Choose and return $first or $second
# depending on which one is more similar to $tradspell.
# If both are equally similar, the shorter one is returned.
# If there is still a tie, $second is returned.
# If $second is undefined or empty, $first is returned without further checks.
sub choose_nearer_or_shorter {
    my ($first, $second, $tradspell) = @_;
    return $first unless $second;

    my $comp = dist(delapo($first), $tradspell) <=> dist(delapo($second), $tradspell);
    $comp = length($first) <=> length($second) unless $comp;
    return ($comp < 0) ? $first : $second;
}

# select_best: Select the best among the three converted spellings the and return it.
# $converted_ga and $ga may be empty. Generally PhonEng is preferred, unless it contains
# vowels where it's know to be unreliable.
sub select_best {
    my ($converted_rp, $converted_ga, $converted_phoneng, $rp, $ga, $phoneng, $tradspell) = @_;
    my $stripped_rp      = restore_apostrophe_and_strip_accents $converted_rp;
    my $stripped_ga      = restore_apostrophe_and_strip_accents $converted_ga;
    my $stripped_phoneng = restore_apostrophe_and_strip_accents $converted_phoneng;

    # Select the spelling that's nearest to tradspell
    my $nearest = choose_nearer_or_shorter $stripped_rp, $stripped_ga, $tradspell;
    $nearest = choose_nearer_or_shorter $nearest, $stripped_phoneng, $tradspell;

    # If PhonEng is the nearest spelling, return it immediately
    return $converted_phoneng if $stripped_phoneng eq $nearest;

    my $nearest_w_accents = $nearest eq $stripped_rp ? $converted_rp : $converted_ga;

    # If the nearest spelling is similar to PhonEng, return it in some cases where it's
    # clearly preferably
    if ($tradspell =~ /^a/i && $nearest =~ /^a/i && $stripped_phoneng =~ /^e/i) {
        # Keep initial 'a', e.g. «abreeviaition» ‹abbreviation›, not «ebreeviaition»
        return $nearest_w_accents
            if substr($nearest, 0, 1) . substr($stripped_phoneng, 1) eq $nearest;
    }
    # Except in proper nounds, keep final 'ed' instead of 'id', e.g. «acursed« ‹accursed›
    return $nearest_w_accents
        if $stripped_phoneng =~ s/id$/ed/r eq $nearest && $tradspell =~ /^[a-z]/;
    # Keep 'e' if PhonEng has 'i' instead, e.g. «exentric» ‹eccentric›
    return $nearest_w_accents if $stripped_phoneng =~ s/(?<![ao])i(?![aeu])/e/r eq $nearest;
    # Keep 'ess' if PhonEng has 'iss' instead, e.g. «sorseress» ‹sorceress›
    return $nearest_w_accents if $stripped_phoneng =~ s/iss/ess/r eq $nearest;
    # Keep 'i' if PhonEng has 'e' instead, e.g. «ábdicait» ‹abdicate›, not «abdecait»
    return $nearest_w_accents if $stripped_phoneng =~ s/e(?!'?r)/i/r eq $nearest;
    # Keep 'i' if PhonEng has 'ee' instead, e.g. «istablish» ‹establish›
    return $nearest_w_accents if $stripped_phoneng =~ s/ee/i/r eq $nearest;
    # Keep 'tion' if PhonEng has 'chen' instead, e.g. «intention»
    return $nearest_w_accents if $stripped_phoneng =~ s/chen/tion/r eq $nearest;

    my $use_phoneng = $stripped_phoneng ? 1 : 0;

    if ($use_phoneng) {
        my $nearest_pron = $nearest eq $stripped_rp ? $rp : $ga;

        for my $vowel (qw/A O: Q/) {
            # Heuristic: PhonEng often confuses these tree vowels, hence we don't prefer it
            # if it has one of them but the nearest pronunciation hasn't
            if ($phoneng =~ $vowel && $nearest_pron !~ $vowel) {
                $use_phoneng = 0;
                last;
            }
        }
    }

    return $use_phoneng ? $converted_phoneng : $nearest_w_accents;
}

# postprocess_suffixed ...: Postprocess a suffixed words, restoring original end-of-word spellings
# (e.g. final "tion" in derived words such as «options, traditionel, imoationaliti»
# ‹...traditional, emotionality›.
sub postprocess_suffixed {
    # XXX Split function into shorter parts
    my ($converted, $base, $suffix, $pos_hint, $tradspell) = @_;
    # Some suffixes are usually derived from a certain POS tag
    $pos_hint = 'n'  if $tradspell =~ /^(abusage|contractor|mopeds)$/;
    $pos_hint = 'aj' if $tradspell =~ /^(augustness|frequented|live[ns])$/;
    $pos_hint ||= 'v'
        if $tradspell =~ /^(contently|inversely)$/
        || $suffix =~ /^(able|ed|e?s|ing|or)$/;
    $pos_hint ||= 'aj' if $suffix =~ /^(ize|[lr]y)$/ || $tradspell =~ /edness$/;
    $pos_hint ||= 'n'
        if $tradspell =~ /^(essayist|internist|presentist|progressist|teary)$/
        || $suffix =~ /^(ful|less)$/;
    my $conv_base_colref = lookup_part_entry($base, $tradspell, $pos_hint);
    my $conv_base        = restore_capitalization $conv_base_colref->[3], $tradspell;
    my $conv_suffix      = $SUFFIXES{$suffix};
    my $orig_conv_base   = $conv_base;
    my $orig_conv_suffix = $conv_suffix;

    # XXX Eliminate regex
    # For suffixes where that's possible, simply append the suffix to the converted base word
    if (
        $suffix =~ /^(.bility|able|age|aholic|ance|ant|ary|ative|ate|atory|dom|en|ence|es|ent|er
        |ess|est|ful|ing|ise|ish|ism|ist|ize|l|less|let|ly|ment|morphism|ness|nik|n|oid
        |or|up|ry|s|shire|ward|y|zygous)$/x
        # ‹-ed› is irregular for non-verbs (e.g. «aj: blessed, v: blessd» ‹blessed›)
        || $suffix eq 'ed' && $pos_hint eq 'v'
        )
    {
        # ‹ate› is spoken in two different ways (/eIt/ or /It/) so we check which one to use
        $conv_suffix = 'ait' if $suffix eq 'ate' && $converted =~ /[aá]it$/;

        # Before suffixes starting with e/i/y, final «c» becomes «k»
        # (e.g. «practikebl» ‹practicable›)
        if ($conv_suffix =~ /^[eiy]/) {
            $conv_base =~ s/c$/k/;
        }

        # «d» (past tense) becomes «ed» after «d, t»
        $conv_suffix = 'ed' if $conv_suffix eq 'd' && $conv_base =~ /[dt]$/;

        # Schwa becomes audible in -ed+ly after certain consonants
        if (
               $conv_suffix eq 'li'
            && $conv_base !~ /ed$/
            && (   $tradspell =~ /[cgk]edly$/
                || ($tradspell =~ /[nr]edly$/ && $conv_base =~ /(ain|air|rn|yn)d$/)
                || ($tradspell =~ /ssedly$/   && $tradspell ne 'embarrassedly'))
            )
        {
            $conv_base =~ s/d$/ed/;
        }

        $orig_conv_base = $conv_base;
        # Final «ment» becomes stressed before some suffixes
        if ($conv_base =~ /ment$/ && $suffix =~ /^(able|ative)$/) {
            $conv_base = strip_acute_accents $conv_base;
            $conv_base =~ s/ment$/mént/;
        }

        # An additional /g/ might become audible between final /N/ and some suffixes
        # (e.g. «longger, stronggest» ‹longer, strongest›)
        if (   $suffix =~ /^(ate|er|est|ish|oid)$/
            && $conv_base =~ /ng$/
            && $converted =~ /ngg$conv_suffix$/)
        {
            $conv_suffix = "g$conv_suffix";
        }

        # «s» (plural or third person singular) is written «es« after sibilants
        $conv_suffix = 'es' if $conv_suffix eq 's' && $conv_base =~ /([jsxz]|[csz]h)$/;

        # Suffix «n» becomes «en» after some consonants
        $conv_suffix = 'en' if $conv_suffix eq 'n' && $conv_base =~ /[djkhlpstvy]$/;

        # Omitted schwa before final «l» is restored in front of «ait/et, erri, ism,
        # ist, oid, ys» ‹ate, ary, ..., ise/ize› (as well as some irregular suffixes,
        # cf. below), unless the schwa is not spoken
        if (   $conv_suffix =~ /^(ait|et|erri|ism|ist|oid|ys)$/
            && $conv_base =~ /[bcp]l$/
            && $base !~ /^(cycle|simple)$/)
        {
            $conv_base =~ s/cl$/kel/ || $conv_base =~ s/(.)$/e$1/;
        }

        # Rules for single-consonant suffix such as «d, n, s»
        if ($conv_suffix =~ /^[^$LYTSPEL_VOWELS]$/) {
            # Final «i» /i:/ becomes «ie» to prevent misreadings
            if ($conv_base =~ /i$/) {
                $conv_base .= 'e';
            }

            # Final «o» /oU/ is restored to «oa»
            if ($conv_base =~ /(?<!o)o$/) {
                $conv_base .= 'a';
            }

            # Final «u» /u:/ is restored to «uu»
            if ($conv_base =~ /(?<!i)u$/) {
                $conv_base .= 'u';
            }
        }

        # Schwa at the start of suffixes is written «a» if the base word ends in /i:/ or /u:/
        substr $conv_suffix, 0, 1, 'a'
            if $conv_suffix =~ /^e[^er]/
            && $conv_base =~ /([eé]e|[iuú])$/;

        # The suffix ‹ary› is spoken «eri» /s@`i/ in some words (most of them are listed as
        # non-compounds, but after final «ss» they must be treated as compounds to ensure
        # proper conversion)
        $conv_suffix = 'eri' if $tradspell =~ /^(dispensary|glossary)$/;

        # Likewise ‹ry›
        $conv_suffix = 'eri'
            if $conv_suffix eq 'ri'
            && $conv_base =~ /[bdfgjklnprsv]$/
            && $tradspell =~ /([^g]ery|dgery)$/
            && $tradspell !~ /(comradery|enginery|riflery)/;

        $orig_conv_base = $conv_base;
        if ($suffix =~ /^(.bility|aholic)$/) {
            # Strip stress marker from base word if the suffix is one of the stressed ones
            $conv_base = strip_acute_accents $conv_base;
        } elsif ($suffix =~ /^(morphism|zygous)/) {
            # Likewise, but in this case we need to add a stress marker to the first long
            # vowel in the suffix if the main word also contains long vowels
            # (not needed after prefixes, as they are considered unstressed)
            $conv_base = strip_acute_accents $conv_base;

            if (has_long_vowel $conv_base && !exists($PREFIXES{$conv_base})) {
                $conv_suffix = stress_vowel $conv_suffix, 0;
            }
        }

        my $compound = "$conv_base$conv_suffix";
        $Stress_Marked_Dict{$compound} = "$orig_conv_base$orig_conv_suffix";
        return $compound;
    }

    # Restore end-of-word spellings in potentially irregular suffixed forms.
    # Note: Some cases seem never to occur with these suffixes (or only in irregular words
    # that don't allow restoration) and hence haven't been added.
    # Not anchored to end of word because of indirect derivates such as ‹emotionality,
    # expressionistic›
    if ($conv_base =~ /tion/) {
        # Restore «tion» (shen), e.g. «traditionel» ‹traditional›
        $converted =~ s/(.*)shen/$1tion/
            || $converted =~ s/(.*)shon/$1tion/
            || warn "No match: $converted ($tradspell) from $conv_base";

        # No stress marker needed before -tion as that's the general rule
        if ($converted =~ /${Acute_Accent}.{0,2}tion/i) {
            $converted = strip_acute_accents $converted;
        }
    } elsif ($conv_base =~ /sion/) {
        # Restore «sion» (zhen), e.g. «ocaisionel» ‹occasional›
        $converted =~ s/(.*)[zs]hen/$1sion/
            || $converted =~ s/(.*)zhon/$1sion/
            || warn "No match: $converted ($tradspell) from $conv_base";

        # No stress marker needed before -sion as that's the general rule
        if ($converted =~ /${Acute_Accent}.{0,2}sion/i) {
            $converted = strip_acute_accents $converted;
        }
    }

    if ($conv_base =~ /all$/) {
        # Restore final «all», e.g. «spallaition» ‹spallation› from «spall»
        $converted =~ s/aul/all/;
    } elsif ($conv_base =~ /k$/ && ($conv_suffix !~ /^([eiY]|d$)/ || $suffix eq 'al')) {
        # Restore final «k», e.g. «embarkaition« ‹embarkation›
        $converted =~ s/(.*)c/$1k/ || warn "No match: $converted ($tradspell) from $conv_base";
    } elsif ($conv_base =~ /[^o]o$/ && $conv_base !~ /oa/ && $suffix ne 'an') {
        # Restore final «o» /oU/, e.g. «heeliotáxiss» ‹heliotaxis›
        $converted =~ s/(.*)oa/$1o/;
    } elsif ($conv_base =~ /s$/ && $converted =~ /z(ian|icl)$/) {
        # Restore final «s», e.g. «Hobsian» ‹Hobbesian›
        $converted =~ s/(.*)z/$1s/;
    } elsif ($conv_base =~ /sh$/ && $converted =~ /tion$/) {
        # Restore final «sh»: «Sailishen» ‹Salishan›
        $converted =~ s/tion$/shen/;
        # Delete stress marker if it's not unnecessary ("shen" has other rules than "tion")
        $converted = do_mark_stress $converted;
    } elsif ($conv_base =~ /ss$/) {
        # Restore final «ss», e.g «rispónssebl, pulssaition» ‹responsible, pulsation›
        if ($converted !~ /ss|tion$|shel$/ || $converted =~ /caition$/) {
            my $suffix_start = $1;
            $converted =~ s/(.*)[cs]([eiY])/$1ss$2/
                || warn "No match: $converted ($tradspell) from $conv_base";
        } elsif ($converted =~ /[^s]saition$/) {
            $converted =~ s/saition$/ssaition/;
        }
    } elsif ($conv_base =~ /[^aáoó]y$/) {
        # Restore final «y», e.g. «Perragwyen» ‹Paraguayan›
        $converted =~ s/(.*)iy/$1y/ || warn "No match: $converted ($tradspell) from $conv_base";
    } elsif ($conv_base =~ /ý$/) {
        # Restore final «ý», e.g. «dinýel» ‹denial›
        $converted =~ s/(.*)iy/$1ý/ || warn "No match: $converted ($tradspell) from $conv_base";
    } elsif ($conv_base =~ /s'?s/ && $converted !~ /s'?s/) {
        # Restore «ss» in the middle of words (including some special cases), e.g.
        # «classicl» ‹classical›
        $converted =~ s/c([eiy])/ss$1/
            || $converted =~ s/Ys/Yss/
            || $converted =~ s/nsi/nssi/;
    } elsif ($conv_base =~ /kw/ && $converted !~ /kw/) {
        # Restore «kw» in the middle of words: «Pikwíkian» ‹Pickwickian›
        $converted =~ s/qu/kw/ || warn "No match: $converted ($tradspell) from $conv_base";
    } elsif ($conv_base =~ /oic/ && $converted =~ /oï/) {
        # Restore «oic» without diaeresis, e.g. «stoicl« ‹stoical›
        $converted =~ s/oï/oi/;
    } elsif ($conv_base =~ /msi/ && $converted !~ /msi/) {
        # Restore «msi» in the middle of words: «whimsicaliti» ‹whimsicality›
        $converted =~ s/mzi/msi/ || warn "No match: $converted ($tradspell) from $conv_base";
    } elsif ($conv_base =~ /nk/ && $converted !~ /nk/) {
        # Restore «nk» in the middle of words, e.g. «conkoidel» ‹conchoidal›
        $converted =~ s/nc/nk/ || warn "No match: $converted ($tradspell) from $conv_base";
    }

    if ($conv_base =~ /th/i && $converted =~ /dh/i) {
        # Fix derivates from «ther», e.g. «botheraition» ‹botheration›
        $converted =~ s/dh/th/ || warn "No match: $converted ($tradspell) from $conv_base";
    }

    # If the derived word starts with «e» (not «er») and the base word with another short
    # vowel (except «i»), use the latter, e.g. «consideraition» ‹consideration› from
    # «consíder»
    if ($converted =~ /^$LYTSPEL_CONSONANT_POST_PROC*e(?![er])/i) {
        my ($pre_cons, $first_base_vowel) =
            $conv_base =~ /^($LYTSPEL_CONSONANT_POST_PROC*)([aeiouyáéíóúýäëïöü])/i;

        if ($first_base_vowel !~ /^[eiéíëï]$/i) {
            if ($pre_cons =~ /c$/) {
                # Also change «k» preceding the vowel back to «c»
                $converted =~ s/ke/c$first_base_vowel/;
            } else {
                $converted =~ s/e/$first_base_vowel/;
            }
        }
    }

    # Deal with cases where the derivate has an accent, but not the base word
    if ($converted =~ /$Acute_Accent/i && $conv_base !~ /$Acute_Accent/i) {
        if ($converted =~ /^$Acute_Accent/i) {
            # Initial accent can be deleted, e.g. «endian» from «end»
            $converted = strip_acute_accents $converted;
        } elsif ($converted =~ /^(.*$Acute_Accent)/i) {
            my $conv_start = $1;
            my $stress_marked_conv_base =
                   $Stress_Marked_Dict{$conv_base}
                || $Stress_Marked_Dict{lc $conv_base}
                || $Stress_Marked_Dict{ucfirst $conv_base};
            if (!defined($stress_marked_conv_base)) {
                warn "No stress-marked version found for $conv_base\n";
                $stress_marked_conv_base = $conv_base;
            }

            if ($stress_marked_conv_base =~ /^$conv_start/i) {
                # If the accent was only removed from the original word since it's not needed,
                # but it was originally in the same place as in the derivate, we can remove it
                # from the latter was well – e.g. «discriminetori» ‹discriminatory› from
                # «discriminait» ‹discriminate›. But we excluse words ending in «ic» such as
                # «cóleric» ‹choleric› because of the special stress rules defined for
                # this ending.
                $converted = strip_acute_accents $converted unless $converted =~ /ic$/;
            }
        }
    }

    return $converted;
}

# convert_row $colref, $tradspell: Convert a row (CSV line) from $IN_FILE style to $OUT_FILE.
# Any listed pronunciations are converted using the Lytspel rules and the resulting spelling
# that's nearest to the traditional spelling is selected and appended to the resulting output
# row. Also handles compounds correctly and updates the global $SUMMED_DIST and WORD_COUNT
# variables.
sub convert_row {
    my ($colref, $tradspell) = @_;
    my $parts = $COMPOUND_DICT_REF->{lc $tradspell};
    my $pos   = $colref->[1];
    my $converted;

    # First check if it's a compound
    my $compound = handle_compound($colref, $parts, $tradspell);

    if (!$compound || $compound =~ /^!/) {
        # It's a base or a suffixed word (the latter requires postprocessing)
        my $custom_entry = $CUSTOM_DICT_REF->{gen_key(lc $tradspell, $pos)}
            // $CUSTOM_DICT_REF->{lc $tradspell} // '';

        if ($custom_entry) {
            $converted = handle_custom_entry $custom_entry, $colref, $tradspell, $pos;
        } elsif ($tradspell =~ /^[A-Z]+$/
            && $tradspell !~ /^(COBOL|FORTRAN|IMAX|UNESCO|UNICEF)$/)
        {
            # Most all-caps words (abbreviations) are either skipped or added unchanged
            if (
                $tradspell =~ /^(AOL|ASCII|BBC|BBQ|BC|CIA|CNN|DC|DNA|FIFO|GATT|GDP|GMT|GOP
                    |HMS|HTML|IL|ILO|IOU|IQ|ISBN|KKK|LAN|LIFO|MC|MIT|MPEG|NAFTA|NASA|NASCAR
                    |NASDAQ|NATO|NC|NY|OECD|OK|OPEC|OT|RAF|TNT|TV|UK|USA|USS|WY)$/x
                )
            {
                $converted = $tradspell;
            } else {
                $converted = '';
            }
        } else {
            my ($rp, $ga, $phoneng) = unify_sounds $colref->[3], $colref->[4], $colref->[5],
                $tradspell;
            my $converted_rp      = convert_pron $rp,      $tradspell, $pos;
            my $converted_ga      = convert_pron $ga,      $tradspell, $pos;
            my $converted_phoneng = convert_pron $phoneng, $tradspell, $pos;

            # Omit GA if identical to RP
            $converted_ga = '' if $converted_ga eq $converted_rp;
            $converted    = select_best $converted_rp, $converted_ga, $converted_phoneng,
                $rp, $ga, $phoneng, $tradspell;
        }
    } else {
        # Return compound
        $converted = $compound;
    }

    return '' unless $converted;

    if ($compound && $compound =~ /^!(.*)=(.*)/) {
        # Postprocess suffixed word
        my $base   = $1;
        my $suffix = $2;
        $converted = postprocess_suffixed $converted, $base, $suffix, $pos, $tradspell;
    }

    $SUMMED_DIST += dist $converted, $tradspell;
    $WORD_COUNT++;
    my $conv_colref = [@$colref[0 .. 2], $converted];
    return $conv_colref;
}

# lookup_part_entry $part, $tradspell, $pos_hint: Look up the entry for a word part of a
# compound, taking case redirects and POS-tagged word parts into account. Returns the converted
# entry row -- if the word hasn't been processed before, it will be converted.
sub lookup_part_entry {
    my ($part, $tradspell, $pos_hint) = @_;
    my $cased         = $CASE_REDIRECT_REF->{$part};
    my $key           = $cased ? $cased : $part;
    my $unconv_colref = $UNCONVERTED_DICT_REF->{$key};

    unless ($unconv_colref) {
        # Must be a POS-tagged word -- use the provided $pos_hint or else 'v', since it's the
        # most frequent POS tag
        my $pos = $pos_hint || 'v';

        # Some heuristics to pick the correct POS tag use
        unless ($pos_hint) {
            # XXX Remove unnecessary parts (such as able, ing)
            # Most words ending in -ate are adjectives (e.g. ‹agglutinate›).
            # Most ‹close...› combinations use the adjective.
            $pos = 'aj'
                if ($part =~ /ate$/
                && $tradspell !~ /(able|^de.*minate|^predesignate|^supersaturate|agglutinate)$/)
                || ($part eq 'close' && $tradspell !~ /^close(down|out|ing|d|s)$|.close$/)
                || $tradspell =~
                /^(airmobile|infrequent|live(bearer|stock)|ungallant|wordperfect)$/;
            $pos = 'n'
                if ($part =~ /^(alloy|concave|congress|dove|house|lead|transfer|transfer|wind)$/
                && $tradspell !~ /(able|^(${part}e?r|fairlead|mislead|leadoff|unwind))$/)
                || ($part eq 'concert'      && $tradspell =~ /er$/)
                || ($part =~ /^mou(se|th)$/ && $tradspell !~ /^$part(ed|e?r|ing|y)$/)
                || ($part eq 'sow'          && $tradspell =~ /^sowb/)
                || $tradspell =~ /^counter/
                || $tradspell =~ /^(discounter|fluidextract|internship|rebeldom|omnipresent|
                    reentrance|subcompact|teardrop|semidesert)$/x;
            $pos = 'prp' if $part eq 'i';
        }

        $key           = gen_key $part, $pos;
        $unconv_colref = $UNCONVERTED_DICT_REF->{$key};

        # XXX Simplify this code
        unless ($unconv_colref) {
            # Use 'n' or else 'aj' as fallback
            $key           = gen_key $part, 'n';
            $unconv_colref = $UNCONVERTED_DICT_REF->{$key};

            unless ($unconv_colref) {
                $key           = gen_key $part, 'aj';
                $unconv_colref = $UNCONVERTED_DICT_REF->{$key};
                die "No entry found for $key\n" unless $unconv_colref;
            }
        }
    }

    my $conv_colref = $CONVERTED_DICT_REF->{$key};
    unless ($conv_colref) {
        # Convert word now
        $conv_colref = convert_row $unconv_colref, $cased || $part;
        $CONVERTED_DICT_REF->{$key} = $conv_colref;
    }

    return $conv_colref;
}

# hyphen_needed $first, $second: Check if a hyphen should be inserted between the parts
# of a compound to prevent misreading.
sub hyphen_needed {
    my ($first, $second) = @_;
    return ($first =~ /o$/i && $second =~ /^([iou]|a(?!i))/i);
}

# combine_with_stress_adjusted $first, $second, $part_to_stress: Combine a two-part
# combination (prefix + main word) into one, adjusting the stress depending on
# $part_to_stress, which must be 1 or 2.
sub combine_with_stress_adjusted {
    my ($first, $second, $part_to_stress) = @_;
    die "Invalid part_to_stress: $part_to_stress:\n" unless grep /$part_to_stress/, (1, 2);
    my $part_to_change = $part_to_stress == 1 ? $first : $second;

    if ($part_to_stress == 1) {
        # Add stress marker on prefix
        my $first_lower    = lc $first;
        my $first_stressed = find_default_stress $first_lower;

        # Restore case if needed
        $first_stressed = ucfirst $first_stressed if $first_lower ne $first;

        # Remove stress marker from main word
        $second = strip_acute_accents $second;
        return "$first_stressed$second";
    } else {
        # Simple join both parts into one
        return "$first$second";
    }
}

# handle_compound $colref, $parts, $tradspell: Handle a compound or derived form. Contractions
# derived from another word in a regular fashion (such as ‹it'd, she'll, shouldn't› are handled
# by this method has well.
#
# The return value is one of the following:
#
# * the spelling to use if the word is a compound or a prefixed form
# * "!mainword=suffix" if it's a suffixed word (for later postprocessing)
# * undef otherwise
sub handle_compound {
    # XXX Refactor this function into shorter ones
    my ($colref, $parts, $tradspell) = @_;
    my $pos = $colref->[1];
    $PROCESSED_COMPOUND_SET{gen_key(lc $tradspell, $pos)} = 1;
    my ($first_lytspel, $second_lytspel, $compound);

    # Check whether compound should stressed irregularly
    my $compound_stress = $Compound_Stress_Dict_Ref->{gen_key(lc $tradspell, $pos)}
        // $Compound_Stress_Dict_Ref->{lc $tradspell};

    if (defined $compound_stress) {
        warn "Invalid stress '$compound_stress' defined in $COMPOUND_STRESS for $tradspell"
            if $compound_stress !~ /^[12]$/;
    } else {
        $compound_stress = '';
    }

    if ($tradspell =~ /^(.*)('(d|ll|re|ve)|n't)$/ || $tradspell =~ /^(I)('m)$/) {
        # Handle regular contractions (and a few irregular ones)
        my $first  = $1;
        my $second = $2;

        if ($first =~ /^(ai|ha|sha)$/) {
            # «ain't, han't, shan't» remain unchanged
            $first_lytspel = $first;
        } elsif ($first =~ /^[dw]o$/) {
            # ‹don't, won't» becomes «doan't, woan't»
            $first_lytspel = "${first}a";
        } else {
            my $first_conv_colref = lookup_part_entry lc($first), $tradspell, $pos;
            $first_lytspel = $first_conv_colref->[3];
            # The last consonant of «must» is not spoken in contractions
            $first_lytspel = substr $first_lytspel, 0, -1 if $first_lytspel eq 'must';
        }

        # ‹'ll, 're, 've› lose their second letter, other contractions remain unchanged
        $second_lytspel = $second =~ /^'..$/ ? substr($second, 0, -1) : $second;

        $compound = "$first_lytspel$second_lytspel";
        $Stress_Marked_Dict{$compound} = $compound;
        return $compound;
    }

    return undef unless $parts;

    if ($parts =~ /-/) {
        # It's a compound made of two parts (separated by '-')
        my ($first, $second) = split /-/, $parts;
        my $first_conv_colref  = lookup_part_entry $first,  $tradspell, $pos;
        my $second_conv_colref = lookup_part_entry $second, $tradspell, $pos;
        die "First part $first of compound $tradspell not found\n"   unless $first_conv_colref;
        die "Second part $second of compound $tradspell not found\n" unless $second_conv_colref;
        $first_lytspel  = restore_capitalization $first_conv_colref->[3], $tradspell;
        $second_lytspel = lc $second_conv_colref->[3];

        # Capitalize second part of words with inner capitalization
        $second_lytspel = ucfirst($second_lytspel) if $tradspell =~ /^[A-Z][a-z]+[A-Z]/;
        $first_lytspel = "$first_lytspel-" if hyphen_needed($first_lytspel, $second_lytspel);
        my $orig_compound = "$first_lytspel$second_lytspel";

        if ($first_lytspel =~ /^$Acute_Accent/i && exists $Treat_As_Prefix{$first}) {
            # A few words are actually prefexes when they occur in this position, and so they
            # lose the accent on their first letter
            $first_lytspel = strip_acute_accents $first_lytspel;
        }

        $compound = "$first_lytspel$second_lytspel";
        $Stress_Marked_Dict{$compound} = $orig_compound;
        return $compound;
    } else {
        # Otherwise it should be a prefixed or suffixed word (separated by '=')
        my ($first, $second) = split /=/, $parts;
        my $stress_hint;
        my $suffixed        = 0;
        my $prefix_is_short = 0;

        unless ($second) {
            warn "Invalid compound definition for $tradspell: $parts\n";
            return undef;
        }

        # Second may be a suffix and/or first may be a prefix
        if (exists $SUFFIXES{$second}) {
            $second_lytspel = $SUFFIXES{$second};
            $suffixed       = 1;
        }

        if (exists $PREFIXES{$first}) {
            $first_lytspel   = restore_capitalization $PREFIXES{$first}->[0], $tradspell;
            $stress_hint     = $PREFIXES{$first}->[1];
            $prefix_is_short = $PREFIXES{$first}->[2];
        }

        # ‹disability› and similar prefix+"ability" compounds: treat second part as regular
        # word rather than suffix
        $second_lytspel = '' if $second eq 'ability' && $first_lytspel;

        # The part not yet defined must be a regular entry
        unless ($first_lytspel) {
            my $first_conv_colref = lookup_part_entry $first, $tradspell, $pos;
            die "Part $first not found while processing $tradspell\n"
                unless $first_conv_colref && $first_conv_colref->[3];
            $first_lytspel = restore_capitalization $first_conv_colref->[3], $tradspell;
        }

        if (!$second_lytspel || ($second eq 'able' && $stress_hint)) {
            # Lookup second part in regular dictionary if it's not a suffix or in case
            # of prefix='able' combinations such as 'unable'
            my $second_conv_colref = lookup_part_entry $second, $tradspell, $pos;
            die "Part $second not found while processing $tradspell\n"
                unless $second_conv_colref && $second_conv_colref->[3];
            $second_lytspel = lc $second_conv_colref->[3];
        }

        # /aI/ is written «iy» before vowels: adjust at the end of prefixes such as
        # «by» ‹bi›
        $first_lytspel =~ s/y$/iy/
            if $stress_hint
            && $first_lytspel =~ /[^ao]y$/
            && $second_lytspel !~ /^'?$LYTSPEL_CONSONANT_POST_PROC/;

        # Prefixes ending in «ay/oy» are written «ai/oi» before consonants, e.g. «ai» ‹a›
        $first_lytspel =~ s/y$/i/
            if $stress_hint
            && $first_lytspel =~ /[ao]y$/
            && $second_lytspel =~ /^'?$LYTSPEL_CONSONANT_POST_PROC/;

        # The Prefix «ir» becomes just «i» before another «r»
        $first_lytspel = 'i' if $first_lytspel eq 'ir' && $second_lytspel =~ /^r/ && $stress_hint;

        if ($stress_hint && $suffixed && $first =~ /^(out|post)$/) {
            # Combinations of "out" or "post" with a suffix are converted like non-compounds
            return undef;
        }

        if ($stress_hint && $first eq 'a') {
            # The prefix 'a' may be pronounced /eI/ or /a/ -- we check the pronunciation and
            # fix if it's the latter
            my $pron = $colref->[5] || $colref->[3];  # prefer PhonEng, use RP as fallback
            $first_lytspel = 'a' if $pron =~ /^[a@]/ || $tradspell eq 'asea';
        }

        if ($suffixed && !$stress_hint) {
            # Main word=suffix combination: return for later postprocessing
            return "!$first=$second";
        }

        $first_lytspel = "$first_lytspel-" if hyphen_needed($first_lytspel, $second_lytspel);
        $compound      = "$first_lytspel$second_lytspel";
        my $orig_compound = "$first_lytspel$second_lytspel";

        if (!$prefix_is_short || $second =~ /^(s|e[ds]|ing)$/) {
            # Long prefix or combination of prefix with one of the most basic suffixes:
            # combine both parts without changing anything
            $compound = "$first_lytspel$second_lytspel";
        } elsif ($stress_hint eq '1' || $compound_stress eq '1') {
            # Assume that prefix is stressed if this is requested or if the second part
            # is a suffix
            $compound = combine_with_stress_adjusted $first_lytspel, $second_lytspel, 1;
        } elsif ($stress_hint eq '2' || $compound_stress eq '2') {
            $compound = combine_with_stress_adjusted $first_lytspel, $second_lytspel, 2;
        } elsif ($stress_hint eq 'A') {
            # Check pronunciation to find out which part to stress
            my $pron = $colref->[5] || $colref->[3];  # prefer PhonEng, use RP as fallback

            if ($pron =~ /[$SAMPA_VOWELS].*'/) {
                # If a vowel occurs before the stress marker, we assume that the 2nd part is
                # stressed
                $compound = combine_with_stress_adjusted $first_lytspel, $second_lytspel, 2;
            } else {
                $compound = combine_with_stress_adjusted $first_lytspel, $second_lytspel, 1;
            }
        } else {
            warn "Entry '$tradspell' has invalid stress hint: '$stress_hint'\n";
        }

        $Stress_Marked_Dict{$compound} = $orig_compound;
        return $compound;
    }

}

# warn_unprocessed_entries $filename, $dictref, $processed_dictref
# Warn if $dictref contains any entries not listed in $processed_dictref (the latter may
# also be POS-tagged).
sub warn_unprocessed_entries {
    my ($filename, $dictref, $processed_dictref) = @_;
    for my $key (sort keys %$dictref) {
        warn "Unused $filename entry: $key\n"
            unless exists $processed_dictref->{$key}
            || exists $processed_dictref->{gen_key($key, 'v')}
            || exists $processed_dictref->{gen_key($key, 'aj')};
    }
}

# output_line $outfh, $aref: Print $aref (string array) to $outfh in CSV format.
# The function 'convert_hyphens_to_diaereses' is only called when this happens
# to make it work acress part boundaries (e.g. «Afroäishiatic» ‹Afroasiatic›) and so
# that we can know that interally diaereses are only used on accented vowels.
sub output_line {
    my ($outfh, $aref) = @_;
    my @fields = @$aref;
    $fields[3] = convert_hyphens_to_diaereses $fields[3] if $fields[3];
    $CSV_OUT->print($outfh, \@fields);
}

# convert_dict: Convert SAMPA spellings to Lytspel.
sub convert_dict {
    ($Map_Ref, $Max_Key_Len) = build_mapping;
    build_prefix_dict;
    build_suffix_dict;
    ($UNCONVERTED_DICT_REF, $CASE_REDIRECT_REF) = build_unconverted_dict_and_case_redirects;
    my $outfh = open_outfile_and_write_header $OUT_FILE, [qw(Traditional POS Redirect Lytspel)];

    for my $key (sort { lc $a cmp lc $b } keys %$UNCONVERTED_DICT_REF) {
        my $colref = $UNCONVERTED_DICT_REF->{$key};

        if (scalar @$colref < 4) {
            if ($key =~ /-$/) {
                # Hyphenated prefix: only print if there is no non-hyphenated form or if
                # the latter is written different from the prefix form
                my $prefix      = substr $key, 0, -1;
                my $conv_prefix = $PREFIXES{$prefix}->[0];
                my $alt_colref  = $CONVERTED_DICT_REF->{$prefix};

                unless ($alt_colref && $alt_colref->[3] eq $conv_prefix) {
                    output_line($outfh, [$key, '', '', "$conv_prefix-"]);
                }

            } elsif (scalar @$colref < 4) {
                # Redirect: Nothing to convert, just output and store line as is
                # (unless the custom dictionary says the entry should be deleted)
                my $tradspell    = $colref->[0];
                my $custom_entry = $CUSTOM_DICT_REF->{lc $tradspell} // '';

                if ($custom_entry eq 'D') {
                    $PROCESSED_CUSTOM_SET{lc $tradspell} = 1;
                } else {
                    output_line($outfh, $colref);
                    $CONVERTED_DICT_REF->{$key} = $colref;
                }
            }

            next;
        }

        my $conv_colref = $CONVERTED_DICT_REF->{$key};
        if ($conv_colref) {
            # Word has already been converted
            output_line($outfh, $conv_colref);
            next;
        }

        $conv_colref = convert_row $colref, $colref->[0];
        $CONVERTED_DICT_REF->{$key} = $conv_colref;
        output_line($outfh, $conv_colref) if $conv_colref;
    }

    close $outfh;

    warn_unprocessed_entries $CUSTOM,          $CUSTOM_DICT_REF,          \%PROCESSED_CUSTOM_SET;
    warn_unprocessed_entries $COMPOUND_STRESS, $Compound_Stress_Dict_Ref, \%PROCESSED_COMPOUND_SET;

    my $avg_dist = $SUMMED_DIST / $WORD_COUNT;
    say "Average distance between tradspell and Lytspel: $avg_dist";
}

# Main block
convert_dict;
