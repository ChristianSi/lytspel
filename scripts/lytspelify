#!/usr/bin/perl -CA
# Convert phonetic SAMPA spellings into Lytspel.
#
# Copyright (c) 2016-17 Christian Siefkes
# See accompanying LICENSE.txt file for licensing information.
#
# Required modules: Const::Fast, Text::Hyphen, Text::LevenshteinXS, and those listed in PhonEng.pm.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Const::Fast;
use Cwd 'abs_path';
use File::Basename 'dirname';
use List::Util qw(min max);
use Text::Hyphen;
use Text::LevenshteinXS 'distance';

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

const my $IN_FILE     => 'phonetic-dict.csv';
const my $OUT_FILE    => 'lytspel-dict.csv';
const my $COMPOUNDS   => 'compounds.csv';
const my $CUSTOM      => 'custom.csv';
const my $PHONEME_MAP => 'phoneme-map.csv';

# Vowel letters in SAMPA and Lytspel
const my $SAMPA_VOWELS   => '@:#3aAeEiIoOQuUV';
const my $LYTSPEL_VOWELS => 'aeiouY';
# Consonant letters
const my $SAMPA_CONSONANTS => '`bdDfghjklmnNprsStTvwzZ';
# Pattern fragment matching an optional stress marker
const my $OPT_STRESS_MARKER => "(?:=')?";
# Pattern fragment matching a Lytspel consonant
const my $LYTSPEL_CONSONANT => "(?:(?:[bcdfghjklmnprstvwxyz]h?|nn?g|qu)=?)";

# Stress the second part of a compound if the first part is listed here
my %STRESS_AFTER = map { $_ => 1 } qw/arch best chemo con crypt crypto dynamo ego ere
    extra fibro helio here hetero hydro hypo infra mon nitro peri psycho pyro supra thence
    there thio ultra where/;

# Stress the second part of a compound if listed here
my %STRESS_IF_SECOND = map { $_ => 1 } qw/air angular basic centric east eastward eastwards ever
    genesis genic graphic logic metric optic phobia phobic self selves therapy teen tropic west
    westward westwards/;

# If the first part of a compound is listed here, either part may be stressed (we check
# the pronunciation to find out).
my %STRESS_VARIES_IF_FIRST = map { $_ => 1 } qw/auto contra electro meta mono para photo
    poly radio retro/;

# If a compound is listed here, its 1st part is stressed (used only in cases where our
# rules indicate that the 2nd part should be stressed).
my %STRESS_FIRST_PART = map { $_ => 1 } qw/aftereffect aftersensation archlute archway
    heterodyne heterograft heterophil hypoblast hypogene hyponasty hypostyle infrasound
    infrastructure therefore ultrastructure wherefore/;

# If a compound is listed here, its 2nd part is stressed.
my %STRESS_SECOND_PART = map { $_ => 1 } qw/absentminded acetylcholine aeromedical aerostation
    Alamein Allhallowmas Allhallows altocumulus antarctic anteprandial anteversion anymore
    arsenopyrite Australasia tetrabranchiate/;

my $CSV_IN  = new_csv_in;
my $CSV_OUT = new_csv_out;
my $HYPH    = new Text::Hyphen min_word => 3, min_prefix => 1, min_suffix => 1;

# The following variables are globals for simplicity
my $SUMMED_DIST     = 0;
my $WORD_COUNT      = 0;
my $CUSTOM_DICT_REF = build_lc_map($CUSTOM);

# Set to which all processed custom entries are added.
my %PROCESSED_CUSTOM_SET;

# Mapping from prefixes to their Lytspel spellings and stress hints (1: stress prefix;
# 2: stress main word; 'A': let PhonEng determine stress). Values are two-element
# array references.
my %PREFIXES;

# build_lc_map $filename: Create and return a mapping from a simple CSV file containing
# two columns (keys and values). All keys are converted to lower-case, while values are
# used as is. Warns if there are duplicate keys.
sub build_lc_map {
    my ($filename) = @_;
    my %dict;
    open my $fh, '<', $filename or die "Unable to open $filename: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $key = lc($colref->[0]);
        warn "Duplicate key '$key' in $filename\n" if exists($dict{$key});
        $dict{$key} = $colref->[1];
    }

    close $fh;
    return \%dict;
}

# build_mapping: Create and return a mapping from SAMPA to the standard Lytspel spellings.
# Also return the length of the longest key in the map.
sub build_mapping {
    my %dict;
    my $maxkeylen = 0;
    open my $fh, '<', $PHONEME_MAP or die "Unable to open $PHONEME_MAP: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $sampa   = $colref->[0];
        my $lytspel = $colref->[4];

        # Skip if SAMPA or Lytspel entry is missing or if SAMPA is '-'
        next unless valid_key($sampa) && $lytspel;

        $maxkeylen = max $maxkeylen, length($lytspel);
        $dict{$sampa} = $lytspel;

        # Add stressed variant if phoneme is a consonant followed by a vowel
        if ($sampa =~ /^[$SAMPA_CONSONANTS][$SAMPA_VOWELS]/) {
            my $stressed_key = substr($sampa, 0, 1) . "'" . substr($sampa, 1);
            my $stressed_val = "'$lytspel";
            $maxkeylen = max $maxkeylen, length($stressed_val);
            $dict{$stressed_key} = $stressed_val;
        }
    }

    close $fh;
    return \%dict, $maxkeylen;
}

# gen_key $word, $pos: Combine a word and a optional POS tag into a joint key.
# If $pos is undefined or empty, $word alone is returned, otherwise "$word/$pos" is returned.
sub gen_key {
    my ($word, $pos) = @_;
    return $pos ? "$word/$pos" : $word;
}

# build_unconverted_dict_and_case_redirects: Returns references to two hashes:
# 1. From keys (see 'gen_key' function) to the complete $IN_FILE entries describing them
# 2. From lower-cased forms of words containing capital letters to their cased form
#    (e.g. 'europe' -> 'Europe')
sub build_unconverted_dict_and_case_redirects {
    open my $infh, '<', $IN_FILE or die "Unable to open $IN_FILE: $!\n";
    my $colref = $CSV_IN->getline($infh);  # Skip header line
    my %unconverted_dict;
    my %case_redirect;

    while ($colref = $CSV_IN->getline($infh)) {
        my $word = $colref->[0];
        my $pos  = $colref->[1];
        my $key  = gen_key $word, $pos;
        $unconverted_dict{$key} = $colref;
        $case_redirect{lc $word} = $word if $word =~ /[A-Z]/;
    }

    close $infh;
    return \%unconverted_dict, \%case_redirect;
}

# delsep $str: Delete any occurrences of '=' (used as separator) from a string.
sub delsep {
    my $str = shift;
    $str =~ s/=//g;
    return $str;
}

# dist $str1, $str2: Calculate the Levenshtein edit distance between two strings, ignoring case.
# Separators are deleted from both strings before doing the conversion:
sub dist {
    my ($str1, $str2) = @_;
    return distance(lc(delsep $str1), lc(delsep $str2));
}

# e_or_u_or_other $other, $left, $right, $tradspell: Return 'e', 'u', or $other depending on which
# is most similar to $tradspell. In case of a tie, 'e' is preferred over 'u' and $other is
# preferred over both. $other is ignored if it's is undefined or empty.
sub e_or_u_or_other {
    my ($other, $left, $right, $tradspell) = @_;

    # Schwa before vowels is always spelled «e»
    return 'e' if $right && $right !~ /^[$SAMPA_CONSONANTS]/;

    my $result =
        dist($tradspell, "${left}e$right") <= dist($tradspell, "${left}u$right") ? 'e' : 'u';

    if ($other) {
        $result =
            dist($tradspell, "$left$other$right") <= dist($tradspell, "$left$result$right")
            ? $other
            : $result;
    }

    return $result;
}

# any_short_vowel $left, $right, $tradspell: Return any of the five vowel letters depending on
# which is most similar to $tradspell. Ties are resolved by preferring the left-most match from
# the following list: e, u, a, o, i. ('e' and 'u' are generally preferred because their sound
# is close to a schwa sound, the other vowel letters are ranked by how often they represent a
# schwa in tradspel.)
sub any_short_vowel {
    my ($left, $right, $tradspell) = @_;
    my $chosen  = '';
    my $olddist = 1000;

    for my $vowel (qw/e u a o i/) {
        my $newdist = dist($tradspell, "$left$vowel$right");

        if ($newdist < $olddist) {
            $chosen  = $vowel;
            $olddist = $newdist;
        }
    }

    return $chosen;
}

# combine $left, $right: Combine two strings into one.
# Except when $left ends with a stress marker ("'") or either string is empty, the strings are
# separated by '='.
sub combine {
    my ($left, $right) = @_;
    return $left =~ /'$/ || !$right || !$left ? "$left$right" : "$left=$right";
}

# combine_and_adjust $val, $left, $right, $tradspell: Combine $left and $val into a joined
# string, applying context-specific rules to the resulting spelling as suitable.
sub combine_and_adjust {
    my ($val, $left, $right, $tradspell) = @_;

    if ($right eq '') {
        # End of word spellings

        if ($val eq '@' || $val eq 'a#') {
            # Final schwa becomes «er» if tradspell ends in ‹r› (typical for non-rhotic RP),
            # otherwise «a»
            $val = $tradspell =~ /r$/ ? 'er' : 'a';
        } elsif ($val eq 'e') {
            # Final «e» /E/ becomes «eh»
            $val = 'eh';
        } elsif ($val eq 'u') {
            # Final /V/ is spelled «uh»
            $val = 'uh';
        } elsif ($val eq 'er' && $left =~ /Y$/) {
            # Final /aI@`/ is written «yr», e.g. «fyr, in'spyr» ‹fire, inspire›
            $val = 'r';
        } elsif ($val eq 'k' && $left =~ /[^'aeou]i$/) {
            # «c» is used at the end of words ending in unstressed /Ik/
            $val = 'c';
        } elsif ($val eq 'l' && $left =~ /au$/) {
            # Final /O:l/ is written «all», e.g. «ball»
            $left =~ s/au$/al/;
        } elsif ($left !~ /([fkpt]|th)$/) {
            # Final /s/ becomes «ss» and /z/ becomes «s» except after /f, k, p, t, T/
            if ($val eq 's') {
                $val = 'ss';
            } elsif ($val eq 'z') {
                $val = 's';
            }
        }
    }

    if ($val eq '@' && $right eq 'l' && $left =~ /[bpdtfgksz]$/) {
        # Schwa is omitted between any of /b, p, d, t, f, g, k/ and final /l/
        $val = '';

        # Final /s@l/ is written «ssl» and final /z@l/ is written «sl»
        if ($left =~ /s$/) {
            $left .= 's';
        } elsif ($left =~ /z$/) {
            chop $left;
            $left .= 's';
        }

    } elsif ($val eq '@' && $right eq 'm' && $left =~ /z$/) {
        # Final /z@m/ is written «sm»
        $val = '';
        chop $left;
        $left .= 's';
    } elsif ($val eq '@' && $right eq 'm' && $left =~ /dh$/) {
        # Schwa is also omitted between /D/ and final /m/
        $val = '';
    } elsif ($val eq '@' && $right eq 'n' && $left =~ /[sz]h$/) {
        # Final /S@n/ becomes «tion» and /Z@n/ becomes «sion»
        $val = 'o';
        $left =~ s/sh$/ti/;
        $left =~ s/zh$/si/;
    } elsif ($val =~ /^(@|a#|I#)$/ && $right =~ /^[$SAMPA_CONSONANTS]*'/) {
        # Any schwa followed by a stressed vowel can become «e/u/a/o/i» (in preference order)
        $val = any_short_vowel $left, $right, $tradspell;
    } elsif ($val eq '@') {
        # /@/ becomes «e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('', $left, $right, $tradspell);
    } elsif ($val eq 'a#') {
        # /a#/ becomes «a/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('a', $left, $right, $tradspell);
    } elsif ($val eq 'I#') {
        # /I#/ becomes «i/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('i', $left, $right, $tradspell);
    } elsif ($val eq 'ai' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «ai» /eI/ becomes «ay» at the end of words and before other vowels
        $val = 'ay';
    } elsif ($val eq 'au' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «au» /O:/ becomes «aw» at the end of words and before other vowels
        $val = 'aw';
    } elsif ($val eq 'ee' && $right !~ /^[$SAMPA_CONSONANTS]/ && $left !~ /'$/) {
        # Unstressed «ee» /i:/ becomes «i» at the end of words and before other vowels
        $val = 'i';
    } elsif ($val eq 'oa' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «oa» /oU/ becomes «o» at the end of words and before other vowels
        $val = 'o';
    } elsif ($val eq 'Y' && $right && $right !~ /^([$SAMPA_CONSONANTS]|@`$)/) {
        # «y» /aI/ becomes «ai» before other vowels
        # (except before final /@` -- that combination becomes «yr»)
        $val = 'ai';
    } elsif ($val eq 'oi' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «oi» /OI/ becomes «oy» at the end of words and before other vowels
        $val = 'oy';
    } elsif ($val eq 'ou' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «ou» /aU/ becomes «ow» at the end of words and before other vowels
        $val = 'ow';
    } elsif ($val eq 'uu' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «uu» /u:/ becomes «u» at the end of words and before other vowels
        $val = 'u';
    } elsif ($val =~ /^ng?$/ && $right =~ /^k/ && $left !~ /^('?[eiu]|[cn]='?o)$/) {
        # Before /k/, «n» is pronounced /N/ rather then /n/, unless the word starts with
        # «con, en, in, non, un»; /n/ becomes «nn» in this position
        $val = $val eq 'n' ? 'nn' : 'n';
    } elsif ($val eq 'r' && $left =~ /r$/) {
        # Eliminate double «r»
        $val = '';
    }

    if ($val =~ /^[aou]/) {
        # /s/ becomes «ss» between any vowel and a vowel starting with «a, o, u»
        $left =~ s/([$LYTSPEL_VOWELS]=)s($OPT_STRESS_MARKER)$/$1ss$2/;
    } elsif ($val =~ /^[eiY]/) {
        # /s/ becomes «c» between any vowel and a vowel starting with «e, i, y»
        $left =~ s/([$LYTSPEL_VOWELS]=)s($OPT_STRESS_MARKER)$/$1c$2/;
    }

    if ($val !~ /^['eiYy]/) {
        # Non-final /k/ becomes «c» unless followed by any of «e, i, y»
        $left =~ s/k($OPT_STRESS_MARKER)$/c$1/;
    }

    if ($val =~ /^[$LYTSPEL_VOWELS]/) {
        # /z/ becomes «s» between two vowels
        $left =~ s/([$LYTSPEL_VOWELS]=)z($OPT_STRESS_MARKER)$/$1s$2/;

    }

    # TODO Integrate list of irregular words: «hi, shi, wi, mi» ‹he, she, we, me›
    # TODO ‹worry› should become «wurri» (but first find out why "w'uree" currently wins)
    # TODO Add to custom.csv and handle correctly: complicate/aj,k'QmplIkIt
    # TODO 1st stressed: dealate, nonsense, wherewithal, guardee, thankee, whoopee, spiritual
    # TODO Continue README from l.366: Disambiguating multigraphs
    # TODO Insert hyphens were necessary to prevent misreadings, incl.
    # unstressed /a/ after /i:/ or /I/:  «am'neesi-ak, zoadi-ak» ‹amnesiac, zodiac›.
    # unstressed /a/ after /u:/ e.g. «bivu-ak» ‹bivouac›
    return combine($left, $val);
}

# insert_at_start $consonants: Insert a stress at the start of a consonant sequence (separated
# by '='). Also restores the final '='.
sub insert_at_start {
    my ($consonants) = @_;
    return "'$consonants=";
}

# insert_after_first $cons_pair: Insert a stress marker after the first consonant of a sequence.
# Also restores the final '='.
sub insert_after_first {
    my ($cons_pair) = @_;
    $cons_pair =~ s/=/='/;
    return "$cons_pair=";
}

# insert_after_second $consonants: Insert a stress marker after the second consonant of a sequence.
# If the sequence contains just one or two consonants, it's inserted at the end instead.
# Also restores the final '='.
sub insert_after_second {
    my ($consonants) = @_;
    $consonants .= '=';
    return $consonants =~ s/(.*?=.*?=)/$1'/r;
}

# insert_at_end $consonants: Insert a stress at the end of a consonant sequence (separated by '=').
# Also restores the final '='.
sub insert_at_end {
    my ($consonants) = @_;
    return "$consonants='";
}

# hyphenated_contains $hyphenated, $pattern: Return true-ish iff $hyphenated contains
# $pattern. Also accepts some legacy spellings, e.g. 'ph' instead of 'f', '=c' instead of '=s',
# and 'ce=' instead of 's='.
sub hyphenated_contains {
    my ($hyphenated, $pattern) = @_;
    $pattern =~ s/[ck](?!h)/(c[hk]?|k)/;  # c|k may be written as any of c|ch|ck|k
    $pattern =~ s/dh/th/;
    $pattern =~ s/f/(f|ph)/;
    $pattern =~ s/j/[gj]/;
    $pattern =~ s/(n[gn])=/$1?=/;         # 'g' or second 'n' after 'n' is optional
    $pattern =~ s/([rv])=/$1e?=/;
    $pattern =~ s/=s/=[sc]/;
    $pattern =~ s/s=/(s|ce)=/;
    $pattern =~ s/z(?!h)/[sz]/;
    return $hyphenated =~ /$pattern/;
}

# insert_stress_marker_among_multiple_consonants $consonants, $hyphenated, $tradspell, $sep_count:
# Insert a stress marker in the proper place in a sequence of three or more consonants.
sub insert_stress_marker_among_multiple_consonants {
    my ($consonants, $hyphenated, $tradspell, $sep_count) = @_;
    my @cons     = split /=/, $consonants;
    my $left     = '';
    my $left_sep = '';

    # Check after which consonant the break should occur
    while (@cons) {
        my $next = shift @cons;
        $left .= $next;
        $left_sep .= "$next=";
        my $rest = join '', @cons;

        return "$left_sep'" . join('=', @cons) . '='
            if hyphenated_contains $hyphenated, "$left=$rest";
    }

    # No break found, so we use suitable defaults:
    # Break before consonant sequence, e.g. «in'struction, converrsaa'tsyoneh»
    # ‹instruction, conversazione›
    return insert_at_start $consonants if $consonants =~ /^(s=t=r|t=s=y)$/;

    # Break after second consonant, e.g. «ump'teen, Pyonj'yang, Burg'soanian, poast'limeni,
    # Fits'patric» ‹umpteen, Pyongyang, Bergsonian, postliminy, Fitzpatrick›
    return insert_after_second $consonants
        if $consonants =~ /^(m=p=t|n=j=y|r=g=s|s=t=l|t=s=[jpr])$/;

    # Otherwise break after first of three consonants, or after second of four
    return insert_after_first $consonants if $sep_count == 2;
    return insert_after_second $consonants;
}

# insert_stress_marker $consonants, $hyphenated, $tradspell: Insert a stress marker in the
# proper place in the sequence of $consonants before a stressed vowel.
sub insert_stress_marker {
    my ($consonants, $hyphenated, $tradspell) = @_;
    my $just_consonants = $consonants =~ s/=//gr;

    # Move stress marker before whole consonant sequence
    return insert_at_start $consonants if $hyphenated =~ /=$just_consonants/;

    # Break after 'ns', if $hyphenated confirms that or $tradspell contains 'trans'
    # (followed by ca|g|l|n|v)
    return insert_after_second $consonants
        if $just_consonants =~ /^(ns)(.*)/
        && ($hyphenated =~ /$1=$2/ || $tradspell =~ /trans(ca|g|l|n|v)/i);

    $consonants =~ s/=$//;  # drop final '='
    my $sep_count = () = $consonants =~ /=/g;

    # Three or more consonants
    return insert_stress_marker_among_multiple_consonants $consonants, $hyphenated, $tradspell,
        $sep_count
        if $sep_count > 1;

    # Second case covers e.g. «eg'zact, ang'zaieti, lug'zhueriass» ‹exact, anxiety, luxurious›
    return insert_after_first $consonants
        if hyphenated_contains $hyphenated, $consonants || $consonants =~ /g=z/;

    # Some special cases
    return insert_at_end $consonants if $tradspell eq 'Antarctica';
    return insert_after_first $consonants
        if ($consonants =~ /^s=/ && $tradspell =~ /^dis/i)
        || ($consonants eq 'c=l' && $tradspell =~ /^Ma?cL/i)
        || ($consonants eq 'p=l' && $tradspell =~ /^popl/i);

    # Break before both consonants if the first is 's' or if the second is 'l' or 'r'
    return insert_at_start $consonants if $consonants =~ /^s=|=[lr]$/;

    # Otherwise break in middle
    return insert_after_first $consonants;
}

# move_stress_marker $word, $tradspell: Move stress marker before the stressed syllable,
# omitting it if the first vowel is the stressed one.
sub move_stress_marker {
    my ($word, $tradspell) = @_;

    return $word unless $word =~ /'/;  # Nothing to do

    if ($word =~ /(.*?)($LYTSPEL_CONSONANT*)'/) {
        my $pre_match                = $1;
        my $consonants_before_marker = $2;

        if ($pre_match eq '') {
            # First vowel is the stressed one
            $word =~ s/'//;
        } elsif ($consonants_before_marker eq '') {
            # Stressed vowel is preceded by another vowel: nothing to do
        } elsif ($consonants_before_marker =~ /^(ss|rr)=$/) {
            # «ss» and «rr» are separated by the marker,
            # e.g. «as'sault, as'sumption, hor'rific»
            $word =~ s/(.)='/'$1=/;
        } elsif ($consonants_before_marker =~ /^nng/) {
            # "nng..." becomes "n'g..."
            $word =~ s/nn(g=.*?)'/n'$1/;
        } elsif ($consonants_before_marker =~ '^[^=]+=$') {
            # Move stress marker before the single consonant
            $word =~ s/$consonants_before_marker'/'$consonants_before_marker/;
        } else {
            # Ask Text::Hyphen
            my $hyphenated = $HYPH->hyphenate($tradspell, '=');
            my $stressed_cons = insert_stress_marker $consonants_before_marker, $hyphenated,
                $tradspell;
            $word =~ s/$consonants_before_marker'/$stressed_cons/;
        }

    } else {
        # This shouldn't happen
        warn "Don't know how to move stress in '$word' ($tradspell)\n";
    }

    return $word;
}

# restore_capitalization $converted, $tradspell: Restore the proper capitalization of a converted
# word. Also deletes separators ('=').
sub restore_capitalization {
    my ($converted, $tradspell) = @_;
    # Delete separators ('=') and convert capital letters to lower case (vowel «Y» as
    # distinguished from consonant «y»)
    $converted = lc(delsep $converted);

    $converted = ucfirst($converted) if $tradspell =~ /^[A-Z][a-z']*$/;  # Capitalized

   # TODO Later fully restore capitalization to match tradspell:
   # Mc|MacCapitalized becomes McCapitalized, e.g. «McAdem, McDowel» ‹McAdam, McDowell›;
   # a repeated /k/ sound is preserved, e.g. «McCoy, McKinli» ‹...McKinley›
   # The stress marker is omitted since the second (capitalized) syllable is always stressed
   # (except McEnroe, McIntosh, McIntyre, McNamara where the first syllable is stressed --
   # probably rewrite those without capital letter e.g. as «Makintosh»; ‹Macintosh› is already
   # in the dict)
   # Preserve D?Capitalized by capitalizing the first two vowels, e.g. «DiCaprio, DuuPont»
   # ‹...DuPont›; the stress marker is omitted since the second syllable is always stressed
   # Preserve O'Capitalized, e.g. «O'Braien» ‹O'Brien›; the capitalized O is spoken /oU/
   # N'Djamena and IJssel become simple capitalized words
   # Other Cap'Capitalized words are dropped as foreign names, e.g. ‹L'Oreal›
   # ALL CAPS and other forms are considered proper names or abbreviations are also dropped
   # lowercase (including apostrophes)
    ##if ($tradspell =~ /^[a-z']+$/) {  # lowercase (including apostrophes)
    return $converted;
}

# convert_pron $pron, $mapref, $maxkeylen, $tradspell: Convert a pronunciation using a given
# mapping alphabet (dictionary reference).
# $maxkeylen is the maximum length of keys that may occur in $mapref.
sub convert_pron {
    my ($pron, $mapref, $maxkeylen, $tradspell) = @_;
    return '' unless $pron;  # Empty input

    my $unconverted = $pron;
    my $converted   = '';

OUTER: while ($unconverted) {
        my $charcount = min $maxkeylen, length $unconverted;

    INNER: while ($charcount) {
            my $start = substr $unconverted, 0, $charcount;
            my $rest = substr $unconverted, $charcount;

            # No sound starts with '`' or ':'
            if ($rest =~ /^[`:]/) {
                $charcount--;
                next INNER;
            }

            my $val = $mapref->{$start};
            if (defined $val) {  # Match found
                $converted = combine_and_adjust $val, $converted, $rest, $tradspell;
                $unconverted = $rest;
                next OUTER;
            }

            $charcount--;
        }

        die "No match found for converting /$pron/ ($tradspell), "
            . "unconverted part: /$unconverted/\n";
    }

    $converted = move_stress_marker $converted,     $tradspell;
    $converted = restore_capitalization $converted, $tradspell;
    return $converted;
}

# build_prefix_dict $mapref, $maxkeylen: Populate the prefix dictionary.
sub build_prefix_dict {
    my ($mapref, $maxkeylen) = @_;
    my $filename = 'prefix.csv';

    open my $fh, '<', $filename or die "Unable to open $filename: $!\n";

    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $word        = $colref->[0];
        my $pron        = $colref->[1];
        my $stress_hint = $colref->[2];

        warn "Duplicate key '$word' in $filename\n" if exists($PREFIXES{$word});
        warn "Unexpected stress hint for prefix $word: '$stress_hint'\n"
            unless $stress_hint =~ /^[12A]$/;

        my $converted = convert_pron $pron, $mapref, $maxkeylen, $word;
        $PREFIXES{$word} = [$converted, $stress_hint];

        # TODO x To check conversion results step by step
        warn "Adding prefix: $word -> $converted, $stress_hint\n";
        last if scalar(keys %PREFIXES) >= 3;
    }

    close $fh;
}

# handle_custom_entry $custom_entry, $colref, $tradspell, $mapref, $maxkeylen: Handle a
# word listed in the custom.csv file. The $custom_entry may have one of the following values:
#
# * B: use British (RP) pronunciation
# * A: use American (GA) pronunciation
# * P: use the PhonEng pronunciation
# * D: don't add the word to the output dictionary (used for rare foreign words or names)
# * O: leave the spelling of the word unchanged
#
# Alternatively, a custom pronunciation may be given which is then used to generate the
# final spelling (assumed to have at least two characters, otherwise a warning is printed
# and the entry is ignored).
sub handle_custom_entry {
    my ($custom_entry, $colref, $tradspell, $mapref, $maxkeylen) = @_;
    $PROCESSED_CUSTOM_SET{lc $tradspell} = 1;

    return $tradspell if $custom_entry eq 'O';  # Leave word unchanged
    return '' if $custom_entry eq 'D';          # Skip word altogether

    my $pron = '';

    if ($custom_entry eq 'B') {
        $pron = $colref->[3];
    } elsif ($custom_entry eq 'A') {
        $pron = $colref->[4];
    } elsif ($custom_entry eq 'P') {
        $pron = $colref->[5];
    } elsif (length($custom_entry) > 1) {
        $pron = $custom_entry;
    }

    if ($pron) {
        return convert_pron $pron, $mapref, $maxkeylen, $tradspell;
    } else {
        warn "Unexpected custom entry for $tradspell: $custom_entry\n";
    }
}

# prepare_pron $pron: Fix the pronunication of a word by normalizing non-standard forms.
sub prepare_pron {
    my $pron = shift;
    # Normalize alternative forms of the r-colored schwa
    $pron =~ s/(?<![ei])\@r|\@`r|a#r/\@`/g;
    # If there are multiple stress markers, remove all but the last one
    $pron =~ s/'(?=.*')//g;
    return $pron;
}

# Unify a sound that may be pronounced differently in two accents. Arguments:
#
# * $rp: British pronunciation
# * $ga: American pronunciation
# * $phoneng: PhonEng pronunciation (optional)
# * $alt1: how the vowel is pronounced in RP (treated as a regex)
# * $alt2: how it is pronounced in GA (treated as a regex)
# * $winner: the pronouncation that should be used
# * $tradspell: the traditional spelling (used for debugging/logging)
# * $suppress_warning: set to a true value to suppresss a warning if unification isn't possible
#   (useful for unreliable latterns)
sub unify_sound {
    my ($rp, $ga, $phoneng, $alt1, $alt2, $winner, $tradspell, $suppress_warning) = @_;

    my $rp_alt1_count = () = $rp =~ /$alt1/g;
    my $ga_alt2_count = () = $ga =~ /$alt2/g;

    return $rp, $ga, $phoneng unless $rp_alt1_count && $ga_alt2_count;  # Nothing to do

    # Split on either alternative (NOT matching if /`/ as in /@`/ follows)
    my @rp_split      = split /($alt1|$alt2)(?!`)/, $rp;
    my @ga_split      = split /($alt1|$alt2)(?!`)/, $ga;
    my @phoneng_split = split /($alt1|$alt2)(?!`)/, $phoneng;
    my $rp_elem_count = scalar @rp_split;

    unless ($rp_elem_count == scalar @ga_split) {
        warn "Note: Cannot unify $tradspell pronouncations re $alt1/$alt2\n"
            unless $suppress_warning;
        return $rp, $ga, $phoneng;
    }

    my $unify_phoneng_too = $rp_elem_count == scalar @phoneng_split;

    for my $i (0 .. $rp_elem_count - 1) {
        if ($rp_split[$i] =~ /^$alt1$/ && $ga_split[$i] =~ /^$alt2$/) {
            $rp_split[$i] = $winner;
            $ga_split[$i] = $winner;

            $phoneng_split[$i] = $winner
                if $unify_phoneng_too && $phoneng_split[$i] =~ /^($alt1|$alt2)$/;
        }
    }

    $rp = join '', @rp_split;
    $ga = join '', @ga_split;

    $phoneng = join '', @phoneng_split if $unify_phoneng_too;

    return $rp, $ga, $phoneng;
}

# Unify the sound used in different pronunciations in cases where a specific vowel
# pronunciation should "win". Generally, unification is only attempted if RP and GA differ;
# otherwise the given pronunciations are returned unchanged. Redundant pronunciations
# (identical to an earlier one) are eliminated in any case.
sub unify_sounds {
    my ($rp, $ga, $phoneng, $tradspell) = @_;
    $rp      = prepare_pron $rp;
    $ga      = prepare_pron $ga;
    $phoneng = prepare_pron $phoneng;

    # Discard GA if identical to RP
    $ga = '' if $ga eq $rp;
    # Discard PhonEng if identical to RP or GA
    $phoneng = '' if $phoneng eq $rp || $phoneng eq $ga;

    # If PhonEng has /Nk/ where RP/GA have /nk/, use the former as it's usually correct
    if ($phoneng =~ /Nk/ && $rp =~ /nk/) {
        ($rp, $phoneng) = unify_sound $rp, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0;
        ($ga, $phoneng) = unify_sound $ga, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0
            if $ga;
    }

    return $rp, $ga, $phoneng unless $ga;  # Nothing more to unify

    # Unify vowels:
    # pair, share, variation -> «air»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'e@', 'Er', 'e@', $tradspell, 0;
    # cheer, year, peculiar -> «eer»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'i:?@', 'Ir', 'i@', $tradspell, 0;
    # poor, tour -> «oor»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'U@', 'Ur', 'Ur', $tradspell, 1;
    # number, modern -> «er» (schwa vs. r-colored schwa)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, '(?<![ei])@', '@`', '@`', $tradspell, 1;
    # port, ignore, keyboard, floral -> «oar»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'or', 'or', $tradspell, 1;
    # sorry, tomorrow -> «orr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Qr', 'O:r', 'Qr', $tradspell, 0;
    # for, dinosaur -> «or»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'O:r', 'O:r', $tradspell, 0;
    # encourage, current -> «urr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Vr', '3:r?', 'Vr', $tradspell, 0;
    # due, neutral, tune -> «ue»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'u:", "(?<![j])'u:", "'U:",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "ju:", "(?<![j'])u:", "U:",
        $tradspell, 0;
    # during, neural -> «uer» (/ju:r/ or /jUr/ in RP, /Ur/ in GA)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'(?:u:|U)r", "(?<![j])'Ur", "'U:r",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j(?:u:|U)r", "(?<![j'])Ur", "U:r",
        $tradspell, 0;

    return $rp, $ga, $phoneng;
}

# choose_nearer_or_shorter $first, $second, $tradspell: Choose and return $first or $second
# depending on which one is more similar to $tradspell.
# If both are equally similar, the shorter one is returned
# If there is still a tie, $first is returned.
# If $second is undefined or empty, $first is returned without further checks.
sub choose_nearer_or_shorter {
    my ($first, $second, $tradspell) = @_;
    return $first unless $second;

    my $comp = dist($first, $tradspell) <=> dist($second, $tradspell);
    $comp = length($first) <=> length($second) unless $comp;
    # TODO Find out how to disambiguate these cases
    #warn "$first and $second have equal distance to $tradspell and equal length\n" unless $comp;

    return ($comp <= 0) ? $first : $second;
}

# select_nearest: Select among the three converted spellings the one that's closest to
# $tradspell and return it. $converted_ga and $converted_phoneng may be empty.
sub select_nearest {
    my ($converted_rp, $converted_ga, $converted_phoneng, $tradspell) = @_;
    my $choosen = choose_nearer_or_shorter $converted_rp, $converted_ga, $tradspell;
    return choose_nearer_or_shorter $choosen, $converted_phoneng, $tradspell;
}

# convert_row $colref, $tradspell, $mapref, $maxkeylen: Convert a row (CSV line)
# from $IN_FILE style to $OUT_FILE. Any listed pronunciations are converted using the
# Lytspel rules and the resulting spelling that's nearest to the traditional spelling is
# selected and appended to the resulting output row. Also updates the global
# $SUMMED_DIST and WORD_COUNT variables.
sub convert_row {
    my ($colref, $tradspell, $mapref, $maxkeylen) = @_;
    my $custom_entry = $CUSTOM_DICT_REF->{lc $tradspell} // '';
    my $converted;

    if ($custom_entry) {
        $converted = handle_custom_entry $custom_entry, $colref, $tradspell, $mapref, $maxkeylen;
    } else {
        my ($rp, $ga, $phoneng) = unify_sounds $colref->[3], $colref->[4], $colref->[5], $tradspell;
        my $converted_rp      = convert_pron $rp,      $mapref, $maxkeylen, $tradspell;
        my $converted_ga      = convert_pron $ga,      $mapref, $maxkeylen, $tradspell;
        my $converted_phoneng = convert_pron $phoneng, $mapref, $maxkeylen, $tradspell;

        # Omit GA if identical to RP
        $converted_ga = '' if $converted_ga eq $converted_rp;
        # Omit PhonEng if identical to RP or GA
        $converted_phoneng = ''
            if $converted_phoneng eq $converted_rp || $converted_phoneng eq $converted_ga;

        # Keep only the spelling that's closest to tradspell
        $converted = select_nearest $converted_rp, $converted_ga, $converted_phoneng, $tradspell;
    }

    return '' unless $converted;  # Skip word if handle_custom_entry returned empty result

    $SUMMED_DIST += dist $converted, $tradspell;
    $WORD_COUNT++;
    my $conv_colref = [@$colref[0 .. 2], $converted];
    return $conv_colref;
}

# lookup_part $part, $tradspell, $unconverted_dict_ref, $converted_dict_ref, $case_redirect_ref,
# $mapref, $maxkeylen: Look up the entry for a word part of a compound, taking case redirects
# and POS-tagged word parts into account. Returns the converted entry row -- if the word
# hasn't been processed before, it will be converted.
sub lookup_part_entry {
    my ($part, $tradspell, $unconverted_dict_ref, $converted_dict_ref, $case_redirect_ref,
        $mapref, $maxkeylen)
        = @_;
    my $cased         = $case_redirect_ref->{$part};
    my $key           = $cased ? $cased : $part;
    my $unconv_colref = $unconverted_dict_ref->{$key};

    unless ($unconv_colref) {
        # Must be a POS-tagged word -- use some heuristics to pick the correct POS tag
        my $pos = 'v';  # default POS tag (most frequent)
        $pos = 'aj' if $part =~ /ate$/;  # e.g. ‹agglutinate›
        $pos = 'n' if $part =~ /^(house|lead|transfer|transfer|wind)$/ and $tradspell ne 'fairlead';
        $key = gen_key $part, $pos;
        $unconv_colref = $unconverted_dict_ref->{$key};

        unless ($unconv_colref) {
            $key = gen_key $part, 'n';                      # use 'n' as fallback
            $unconv_colref = $unconverted_dict_ref->{$key};
            warn "No entry found for $key\n" unless $unconv_colref;
        }
    }

    my $conv_colref = $converted_dict_ref->{$key};
    unless ($conv_colref) {
        # Convert word now
        $conv_colref = convert_row $unconv_colref, $cased || $part, $mapref, $maxkeylen;
        $converted_dict_ref->{$key} = $conv_colref;
    }

    return $conv_colref;
}

# handle_compound $colref, $parts, $tradspell, $unconverted_dict_ref, $converted_dict_ref,
# $case_redirect_ref, $mapref, $maxkeylen: Handle a compound or derived form.
# Returns the spelling to use for the compound if the word is one; returns undef otherwise.
sub handle_compound {
    my ($colref, $parts, $tradspell, $unconverted_dict_ref, $converted_dict_ref,
        $case_redirect_ref, $mapref, $maxkeylen)
        = @_;

    if ($parts =~ /-/) {
        # It's a compound made of two parts
        my ($first, $second) = split /-/, $parts;
        my $first_conv_colref = lookup_part_entry $first, $tradspell, $unconverted_dict_ref,
            $converted_dict_ref, $case_redirect_ref, $mapref, $maxkeylen;
        my $second_conv_colref = lookup_part_entry $second, $tradspell, $unconverted_dict_ref,
            $converted_dict_ref, $case_redirect_ref, $mapref, $maxkeylen;
        my $first_lytspel  = restore_capitalization $first_conv_colref->[3], $tradspell;
        my $second_lytspel = lc $second_conv_colref->[3];
        my $compound       = "$first_lytspel$second_lytspel";

        # If the compound contains two stress markers, we keep just the second one
        $compound =~ s/'// if $compound =~ /'.*'/;

        # If the compound contains a stress markers, we retain it (unless the second part is
        # «a'bout» ‹about›, e.g. «roundabout») and are done (unless the first part is
        # «i'lectro» ‹electro› -- then we'll check below which part carries the main stress)
        if ($compound =~ /'/) {
            $compound =~ s/'// if $second eq 'about';
            return $compound unless $first eq 'electro';
        }

        # If this word is listed as a special case, we return it and are done
        return $compound if exists($STRESS_FIRST_PART{$tradspell});

        # Insert stress marker before second part if appropriate
        $compound = "$first_lytspel'$second_lytspel"
            if exists($STRESS_AFTER{$first})
            || exists($STRESS_IF_SECOND{$second})
            || exists($STRESS_SECOND_PART{$tradspell});

        if (exists($STRESS_VARIES_IF_FIRST{$first})) {
            # Check pronunciation to find out which part to stress
            my $pron = $colref->[5] || $colref->[3];  # prefer PhonEng, use RP as fallback

            # In ‹electro...› combinations, we discard the first sound (vowel), since it's
            # never stressed
            $pron = substr($pron, 1) if $first eq 'electro';

            if ($pron =~ /[$SAMPA_VOWELS].*'/) {
                # If a vowel occurs before the stress marker, we assume that the 2nd part is
                # stressed (in case of ‹electro...› combinations, it may already contain a
                # stress marker)
                $first_lytspel =~ s/'//;  # convert «i'lectro» to «ilectro»
                $compound = "$first_lytspel'$second_lytspel" unless $second_lytspel =~ /'/;
            }
        }

        return $compound;
    } elsif ($parts =~ /=/) {
        # It's a prefixed or suffixed word
        my ($first, $second) = split /=/, $parts;
        my $compound;

        if (exists $PREFIXES{$first}) {
            # TODO x Main part may itself be a compound, e.g. clockwise, takeover
            return undef if $second eq 's';  # TODO x special case: prefix-suffix combi
            my $conv_prefix        = restore_capitalization $PREFIXES{$first}->[0], $tradspell;
            my $stress_hint        = $PREFIXES{$first}->[0];
            my $second_conv_colref = lookup_part_entry $second, $tradspell, $unconverted_dict_ref,
                $converted_dict_ref, $case_redirect_ref, $mapref, $maxkeylen;
            my $second_lytspel = lc $second_conv_colref->[3];

            if ($stress_hint eq '2' && $second_lytspel != /'/) {
                # Insert stress marker before main word
                $compound = "$conv_prefix'$second_lytspel";
            } else {
                $compound = "$conv_prefix$second_lytspel";
            }
            # TODO x Take 'A' hint into account

            return $compound;
        } else {
            # TODO x Implement
            return undef;
        }

        # TODO x Adapt POS heuristics for prefixed and suffixed forms; document pre|suffix.csv
        # Replace prefix.list by prefix.csv: Trad,Pron,Stress (1: first part, 2: second part, A:
        # ask PE; L: last syllable of first part)
        # for word in ; do grep -i ^$word, lytspel-dict.csv; done
        # Suffixes ed/es/s need special treatment
        # -ial after «t» merges to /tS@l/
        # -ion after «st» merges to /tS@n/ (currently written «chen»), after «t» to /S@n/
        # (written «tion»)
        # -ual after «t» merges to /tSu:@l/
        # Note: if stress changes, a schwa might become a short vowel--in that case, use it
        # also for the base form, e.g. «telson» due to «tel'sonic» ‹telsonic›
        # Handle prefix/suffix combis correctly (e.g. antis)
        # Add prefixes: ab- (e.g. abampere, 2nd part stressed)
        # Add suffix: -otic (stressed before suffix), -ology (ditto)
        # Stress last syllable of 1st part: -meter (e.g. aerometer, electrometer,
        # alkalimeter), -tropism (e.g. aerotropism, stereotropism)
        # Add prefix per- «per»: stress 2nd part; but keep a few manual entries for ‹per›
        # «pur» (likewise stressed on 2nd part): percutaneous,per-cutaneous;
        # peroxidic,per-oxidic; peroxide,per-oxide
        # Add suffixes: -ine «in» or maybe «yn» (e.g. petaline, phialine;
        # ensure that no -line words are accidentally excluded),
        # -oid (e.g. petaloid), -ous «uss» (e.g. petalous)
        # Add prefixes: ‹tele› «tele»; ‹zoo› /zoU@/ «zoa» (PE determines stress);
        # neuro- (make sure it's used for ‹neurosecretion›)
        # Make -tic a suffix instead of a regular compound part (e.g. aromatic),
        # likewise -ary (e.g. visionary), -ology (e.g. planetology), -arian (e.g. parliamentarian),
        # make a suffix: tele-
        # Stress before final consonant(s) of first part (probably treat as suffix): -otic,
        # e.g. «aci'dotic» ‹acidotic›
        # Make ‹zoo› a prefix written «zoe» /zoU@/; first or second part may be stressed.
        # Make suffix: ate (spoken «ait» /eIt/ or sometimes «it» /It/ -- dicts sometimes have
        # /@t/ instead)
        # Suffix stress rules win over prefix stress rules, e.g. ‹biotic› «bai'otic»
        # Exceptions where 1st is stressed: all [-=]sphere combis (e.g. biosphere, chemosphere)
        # TODO Adapt decompose (and Makefile) to use prefix|suffix.csv instead of .list
    }

# TODO When looking up words, consider that they might be POS-tagged (v, n, av, prp)
# Then handle prefixed ('=' with known prefix) and suffixed entries.
# TODO Handle prefixes and suffixes correctly («dis, mis; anti, semi» are spelled like that
# regardless of which letter follows; prefixes «baio, nio» ‹bio, neo›;
# suffix «ful» is preserved; «-est» remains as is (never "ast"))
# Test that is also works if the case of the original word is different.
# Correct and use the result for each prefix/suffixes; also handle and
# document schwa/single-letter short changes such as «hexagen» ‹hexagon› due to «he'xagenel»
# ‹hexagonal›; deal with «nationel» ‹national› from «naition» ‹nation› as a special case
# (the derived form is irregular).
# Ensure that «obzur'vaition» ‹observation› is converted correctly (from «ob'zurv» ‹observe›)
# Ensure that the «tion» and «sion» spellings aren't used in words derived by appending «n» or
# «en», e.g. «ashen, freshen, Rushan, Purzhan»
# TODO Add -ance, -ence as suffixes
# TODO Add 'bi' as prefix, otherwise add manual entries:
# biconcave,bi-concave
# biconcavity,bi-concavity
# Add 'on' as prefix, e.g. ‹oncoming› should be analysed as ‹on=coming›

    return undef;  # not a compound
}

# warn_unprocessed_custom_entries: Warn if there are entries in the custom.csv file not
# in the dictionary.
sub warn_unprocessed_custom_entries {
    # TODO Add a similar checks for compounds-manual.csv and compound-black|blacklist.csv
    # (also warn if there are duplicate entries)
    for my $key (sort keys %$CUSTOM_DICT_REF) {
        warn "Unused $CUSTOM entry: $key\n" unless exists $PROCESSED_CUSTOM_SET{$key};
    }
}

# convert_dict: Convert SAMPA spellings to Lytspel.
sub convert_dict {
    my ($mapref, $maxkeylen) = build_mapping;
    my $compound_map_ref = build_lc_map $COMPOUNDS;
    build_prefix_dict $mapref, $maxkeylen;
    my ($unconverted_dict_ref, $case_redirect_ref) = build_unconverted_dict_and_case_redirects;
    my %converted_dict;
    my $outfh = open_outfile_and_write_header $OUT_FILE, [qw(Traditional POS Redirect Lytspel)];

    for my $key (sort { lc $a cmp lc $b } keys %$unconverted_dict_ref) {
        my $colref = $unconverted_dict_ref->{$key};

        if (scalar @$colref < 4) {
            # Nothing to convert, just output and store line as is
            $CSV_OUT->print($outfh, $colref);
            $converted_dict{$key} = $colref;
            next;
        }

        my $conv_colref = $converted_dict{$key};
        if ($conv_colref) {
            # Word has already been converted
            $CSV_OUT->print($outfh, $conv_colref);
            next;
        }

        my $tradspell = $colref->[0];
        my $parts     = $compound_map_ref->{lc $tradspell};
        my $compound  = handle_compound $colref, $parts, $tradspell, $unconverted_dict_ref,
            \%converted_dict, $case_redirect_ref, $mapref, $maxkeylen
            if $parts;

        if ($compound) {
 # TODO Stress 1st part: breakaway, castaway, cutaway, flyaway, foldaway, getaway, giveaway,
 # Greenaway, Hathaway, hideaway, huntaway, layaway, rockaway, rollaway, runaway, soakaway,
 # stowaway, straightaway, throwaway, walkaway (-away in general);
 # counterattack, counterreply, countersubject, heterocycle, lookalike, minicomputer, pinafore,
 # slugabed, standalone, tarmacadam, telerecord, turnverein, videocassette, woebegone
 # servocontrol/n
 # -amine (calamine, Dramamine, hexamine, histamine), -around
 # Stress 2nd part: aerologic only, not choplogic; benediction, binocular,
 # bronchiectasis, commonsense, dextrocardia, diacetylmorphine, diazomethane, duecento,
 # echocardiogram, eftsoon, everlasting, farewell, forever, forevermore, goodbye, hemelytron,
 # hereinafter, boohoo, lambaste, mercaptopurine, methacrylate,
 # methylbenzene, methylnaphthalene, moreover, nymphomaniac, oleomargarine, penannular,
 # penultimate, penultima, phenylalanine, philhellene,
 # Rockhampton, saltpeter, sardonyx, statampere, sulfaguanidine, sulfathiazole, sympetalous,
 # synchrocyclotron, tetraethyl, throughout, uniaxial, without
 # -aldehyde, -chemical, -chemistry, -decagon, -eastern, -forward, -metric, -phonic, -sexual,
 # -western, magneto-, mal- (except malware)
 # PE determines stress: proto-, stereo-
 # TODO «sm» should be divided in the middle, e.g. «antas'matic» ‹antasthmatic›;
 # ditto «rl», e.g. «bur'leta» ‹burletta›
 # and «st»
 # Fix stress marker: Chinnky'ang -> Chinn'kyang ('y' before a vowel is a consonant);
 # find out why the marker is «Sheen'ing» ‹Sining› is misplaced; ‹pontlevis› should become
 # «pont'leviss», not pon'tleviss
 # TODO Treat all words ending in ‹syllable› or ‹syllabic› as compounds even if not listed
 # (2nd stressed: dissyllable, dodecasyllable), ditto ‹disyllabism› (2nd stressed) and
 # ‹monosyllabicity›
 # TODO Make -ary -> erri a suffix (reactionary, customary)
 # make -ate a suffix spoken either «ait» or «et|it» (e.g. «dy'recteret» ‹directorate›;
 # sometimes it depends on the POS tag, e.g. ‹proportionate›)
 # TODO Add centralist (should become central=ist and centralists: centralist=s)
 # TODO Distinguish live/v: liv vs aj: lyv; livelong should become livlong; warehouse/v should
 # become «wairhous»
 # ‹planoconvex› should be come «planocon'vex» (from the aj)
 # TODO Unify /@ri:/ (or /@rI/ or /@`ri/) vs. /Eri:/ to the latter, e.g.
 # ‹solidary, temporary, voluntary›
 # TODO ‹quad› should probably always become «quod» rather than «quaad»

            # Use return value instead of calling convert_row
            $conv_colref = [@$colref[0 .. 2], $compound];
        } else {
            $conv_colref = convert_row $colref, $tradspell, $mapref, $maxkeylen;
        }

        $converted_dict{$key} = $conv_colref;
        $CSV_OUT->print($outfh, $conv_colref) if $conv_colref;

        # TODO Finally drop POS tag if all variants are written the same, e.g. «mouth»
        # TODO Handle most frequent pre- and suffixes in converter rather than dict
        # (also creating a compact version of the dict where they are dropped, after
        # making sure that the converter will indeed lead to the same results)
    }

    close $outfh;

    warn_unprocessed_custom_entries;
    my $avg_dist = $SUMMED_DIST / $WORD_COUNT;
    say "Average distance between tradspell and Lytspel: $avg_dist";
}

# Main block
convert_dict;
