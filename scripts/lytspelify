#!/usr/bin/perl -CA
# Convert phonetic SAMPA spellings into Lytspel.
#
# Copyright (c) 2016 Christian Siefkes
# See accompanying LICENSE file for licensing information.
#
# Required modules: Const::Fast, Text::LevenshteinXS, and those listed in PhonEng.pm.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Const::Fast;
use Cwd 'abs_path';
use File::Basename 'dirname';
use List::Util qw(min max);
use Text::LevenshteinXS 'distance';

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

const my $IN_FILE     => 'phonetic-dict.csv';
const my $OUT_FILE    => 'lytspel-dict.csv';
const my $PHONEME_MAP => 'phoneme-map.csv';

# Vowel letters in SAMPA and Lytspel
const my $SAMPA_VOWELS   => '@:#3aAeEiIoOQuUV';
const my $LYTSPEL_VOWELS => '[aeiouY]';
# Consonant letters
const my $SAMPA_CONSONANTS => '`bdDfghjklmnNprsStTvwzZ';
# Pattern fragment matching an optional stress marker
const my $OPT_STRESS_MARKER => "(?:=')?";

my $CSV_IN  = new_csv_in;
my $CSV_OUT = new_csv_out;

# build_mapping: Create and return a mapping from SAMPA to the standard Lytspel spellings.
# Also return the length of the longest key in the map.
sub build_mapping {
    my %dict;
    my $maxkeylen = 0;
    open my $fh, '<', $PHONEME_MAP or die "Unable to open $PHONEME_MAP: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $sampa   = $colref->[0];
        my $lytspel = $colref->[4];

        # Skip if SAMPA or Lytspel entry is missing or if SAMPA is '-'
        next unless valid_key($sampa) && $lytspel;

        $maxkeylen = max $maxkeylen, length($lytspel);
        $dict{$sampa} = $lytspel;

        # Add stressed variant if phoneme is a consonant followed by a vowel
        if ($sampa =~ /^[$SAMPA_CONSONANTS][$SAMPA_VOWELS]/) {
            my $stressed_key = substr($sampa, 0, 1) . "'" . substr($sampa, 1);
            my $stressed_val = "'$lytspel";
            $maxkeylen = max $maxkeylen, length($stressed_val);
            $dict{$stressed_key} = $stressed_val;
        }
    }

    close $fh;
    return \%dict, $maxkeylen;
}

# prepare_pron $pron: Fix the pronunication of a word by normalizing non-standard forms.
sub prepare_pron {
    my $pron = shift;
    # Normalize alternative forms of the r-colored schwa
    $pron =~ s/(?<![ei])\@r|\@`r|a#r/\@`/g;
    # If there are multiple stress markers, remove all but the last one
    $pron =~ s/'(?=.*')//g;
    return $pron;
}

# Unify a sound that may be pronounced differently in two accents. Arguments:
#
# * $rp: British pronunciation
# * $ga: American pronunciation
# * $phoneng: PhonEng pronunciation (optional)
# * $alt1: how the vowel is pronounced in RP (treated as a regex)
# * $alt2: how it is pronounced in GA (treated as a regex)
# * $winner: the pronouncation that should be used
# * $tradspell: the traditional spelling (used for debugging/logging)
# * $suppress_warning: set to a true value to suppresss a warning if unification isn't possible
#   (useful for unreliable latterns)
sub unify_sound {
    my ($rp, $ga, $phoneng, $alt1, $alt2, $winner, $tradspell, $suppress_warning) = @_;

    my $rp_alt1_count = () = $rp =~ /$alt1/g;
    my $ga_alt2_count = () = $ga =~ /$alt2/g;

    return $rp, $ga, $phoneng unless $rp_alt1_count && $ga_alt2_count;  # Nothing to do

    # Split on either alternative (NOT matching if /`/ as in /@`/ follows)
    my @rp_split      = split /($alt1|$alt2)(?!`)/, $rp;
    my @ga_split      = split /($alt1|$alt2)(?!`)/, $ga;
    my @phoneng_split = split /($alt1|$alt2)(?!`)/, $phoneng;
    my $rp_elem_count = scalar @rp_split;

    unless ($rp_elem_count == scalar @ga_split) {
        warn "Cannot unify $tradspell pronouncations re $alt1/$alt2\n" unless $suppress_warning;
        return $rp, $ga, $phoneng;
    }

    my $unify_phoneng_too = $rp_elem_count == scalar @phoneng_split;

    for my $i (0 .. $rp_elem_count - 1) {
        if ($rp_split[$i] =~ /^$alt1$/ && $ga_split[$i] =~ /^$alt2$/) {
            $rp_split[$i] = $winner;
            $ga_split[$i] = $winner;

            $phoneng_split[$i] = $winner
                if $unify_phoneng_too && $phoneng_split[$i] =~ /^($alt1|$alt2)$/;
        }
    }

    $rp = join '', @rp_split;
    $ga = join '', @ga_split;

    $phoneng = join '', @phoneng_split if $unify_phoneng_too;

    return $rp, $ga, $phoneng;
}

# Unify the sound used in different pronunciations in cases where a specific vowel
# pronunciation should "win". Generally, unification is only attempted if RP and GA differ;
# otherwise the given pronunciations are returned unchanged. Redundant pronunciations
# (identical to an earlier one) are eliminated in any case.
sub unify_sounds {
    my ($rp, $ga, $phoneng, $tradspell) = @_;
    $rp      = prepare_pron $rp;
    $ga      = prepare_pron $ga;
    $phoneng = prepare_pron $phoneng;

    # Discard GA if identical to RP
    $ga = '' if $ga eq $rp;
    # Discard PhonEng if identical to RP or GA
    $phoneng = '' if $phoneng eq $rp || $phoneng eq $ga;

    # If PhonEng has /Nk/ where RP/GA have /nk/, use the former as it's usually correct
    if ($phoneng =~ /Nk/ && $rp =~ /nk/) {
        ($rp, $phoneng) = unify_sound $rp, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0;
        ($ga, $phoneng) = unify_sound $ga, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0
            if $ga;
    }

    return $rp, $ga, $phoneng unless $ga;  # Nothing more to unify

    # Unify vowels:
    # pair, share, variation -> «air»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'e@', 'Er', 'e@', $tradspell, 0;
    # cheer, year, peculiar -> «eer»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'i:?@', 'Ir', 'i@', $tradspell, 0;
    # poor, tour -> «oor»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'U@', 'Ur', 'Ur', $tradspell, 1;
    # number, modern -> «er» (schwa vs. r-colored schwa)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, '(?<![ei])@', '@`', '@`', $tradspell, 1;
    # port, ignore, keyboard, floral -> «oar»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'or', 'or', $tradspell, 1;
    # sorry, tomorrow -> «orr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Qr', 'O:r', 'Qr', $tradspell, 0;
    # for, dinosaur -> «or»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'O:r', 'O:r', $tradspell, 0;
    # encourage, current -> «urr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Vr', '3:r?', 'Vr', $tradspell, 0;
    # due, neutral, tune -> «ue»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'u:", "(?<![j])'u:", "'U:",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "ju:", "(?<![j'])u:", "U:",
        $tradspell, 0;
    # during, neural -> «uer» (/ju:r/ or /jUr/ in RP, /Ur/ in GA)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'(?:u:|U)r", "(?<![j])'Ur", "'U:r",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j(?:u:|U)r", "(?<![j'])Ur", "U:r",
        $tradspell, 0;

    return $rp, $ga, $phoneng;
}

# delsep $str: Delete any occurrences of '=' (used as separator) from a string.
sub delsep {
    my $str = shift;
    $str =~ s/=//g;
    return $str;
}

# dist $str1, $str2: Calculate the Levenshtein edit distance between two strings, ignoring case.
# Separators are deleted from both strings before doing the conversion:
sub dist {
    my ($str1, $str2) = @_;
    return distance(lc(delsep $str1), lc(delsep $str2));
}

# e_or_u_or_other $other, $left, $right, $tradspell: Return 'e', 'u', or $other depending on which
# is most similar to $tradspell. In case of a tie, 'e' is preferred over 'u' and $other is
# preferred over both. $other is ignored if it's is undefined or empty.
sub e_or_u_or_other {
    my ($other, $left, $right, $tradspell) = @_;

    # Schwa before vowels is always spelled «e»
    return 'e' if $right && $right !~ /^[$SAMPA_CONSONANTS]/;
    # TODO Write schwa after other vowels as «a», e.g. «maniuel» ‹manual›?
    # (check whether/how often /a/ occurs in this position)

    my $result =
        dist($tradspell, "${left}e$right") <= dist($tradspell, "${left}u$right") ? 'e' : 'u';

    if ($other) {
        $result =
            dist($tradspell, "$left$other$right") <= dist($tradspell, "$left$result$right")
            ? $other
            : $result;
    }

    return $result;
}

# any_short_vowel $left, $right, $tradspell: Return any of the five vowel letters depending on
# which is most similar to $tradspell. Ties are resolved by preferring the left-most match from
# the following list: e, u, a, o, i. ('e' and 'u' are generally preferred because their sound
# is close to a schwa sound, the other vowel letters are ranked by how often they represent a
# schwa in tradspel.)
sub any_short_vowel {
    my ($left, $right, $tradspell) = @_;
    my $chosen  = '';
    my $olddist = 1000;

    for my $vowel (qw/e u a o i/) {
        my $newdist = dist($tradspell, "$left$vowel$right");

        if ($newdist < $olddist) {
            $chosen  = $vowel;
            $olddist = $newdist;
        }
    }

    return $chosen;
}

# combine $left, $right: Combine two strings into one.
# Except when $left ends with a stress marker ("'") or either string is empty, the strings are
# separated by '='.
sub combine {
    my ($left, $right) = @_;
    return $left =~ /'$/ || !$right || !$left ? "$left$right" : "$left=$right";
}

# combine_and_adjust $val, $left, $right, $tradspell: Combine $left and $val into a joined
# string, applying context-specific rules to the resulting spelling as suitable.
sub combine_and_adjust {
    my ($val, $left, $right, $tradspell) = @_;

    if ($right eq '') {
        # End of word spellings

        if ($val eq '@' || $val eq 'a#') {
            # Final schwa becomes «er» if tradspell ends in ‹r› (typical for non-rhotic RP),
            # otherwise «a»
            $val = $tradspell =~ /r$/ ? 'er' : 'a';
        } elsif ($val eq 'e') {
            # Final «e» /E/ becomes «eh»
            $val = 'eh';
        } elsif ($val eq 'u') {
            # Final /V/ is spelled «uh»
            $val = 'uh';
        } elsif ($val eq 'er' && $left =~ /Y$/) {
            # Final /aI@`/ is written «yr», e.g. «fyr, in'spyr» ‹fire, inspire›
            $val = 'r';
        } elsif ($val eq 'k' && $left =~ /[^'aeou]i$/) {
            # «c» is used at the end of words ending in unstressed /Ik/
            $val = 'c';
        } elsif ($val eq 'l' && $left =~ /au$/) {
            # Final /O:l/ is written «all», e.g. «ball»
            $left =~ s/au$/al/;
        } elsif ($left !~ /([fkpt]|th)$/) {
            # Final /s/ becomes «ss» and /z/ becomes «s» except after /f, k, p, t, T/
            if ($val eq 's') {
                $val = 'ss';
            } elsif ($val eq 'z') {
                $val = 's';
            }
        }
    }

    if ($val eq '@' && $right eq 'l' && $left =~ /[bpdtfgksz]$/) {
        # Schwa is omitted between any of /b, p, d, t, f, g, k/ and final /l/
        $val = '';

        # Final /s@l/ is written «ssl» and final /z@l/ is written «sl»
        if ($left =~ /s$/) {
            $left .= 's';
        } elsif ($left =~ /z$/) {
            chop $left;
            $left .= 's';
        }

    } elsif ($val eq '@' && $right eq 'm' && $left =~ /z$/) {
        # Final /z@m/ is written «sm»
        $val = '';
        chop $left;
        $left .= 's';
    } elsif ($val eq '@' && $right eq 'm' && $left =~ /dh$/) {
        # Schwa is also omitted between /D/ and final /m/
        $val = '';
    } elsif ($val eq '@' && $right eq 'n' && $left =~ /[sz]h$/) {
        # Final /S@n/ becomes «tion» and /Z@n/ becomes «sion»
        $val = 'o';
        $left =~ s/sh$/ti/;
        $left =~ s/zh$/si/;
    } elsif ($val =~ /^(@|a#|I#)$/ && $right =~ /^[$SAMPA_CONSONANTS]*'/) {
        # Any schwa followed by a stressed vowel can become «e/u/a/o/i» (in preference order)
        $val = any_short_vowel $left, $right, $tradspell;
    } elsif ($val eq '@') {
        # /@/ becomes «e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('', $left, $right, $tradspell);
    } elsif ($val eq 'a#') {
        # /a#/ becomes «a/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('a', $left, $right, $tradspell);
    } elsif ($val eq 'I#') {
        # /I#/ becomes «i/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('i', $left, $right, $tradspell);
    } elsif ($val eq 'ai' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «ai» /eI/ becomes «ay» at the end of words and before other vowels
        $val = 'ay';
    } elsif ($val eq 'au' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «au» /O:/ becomes «aw» at the end of words and before other vowels
        $val = 'aw';
    } elsif ($val eq 'ee' && $right !~ /^[$SAMPA_CONSONANTS]/ && $left !~ /'$/) {
        # Unstressed «ee» /i:/ becomes «i» at the end of words and before other vowels
        $val = 'i';
    } elsif ($val eq 'oa' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «oa» /oU/ becomes «o» at the end of words and before other vowels
        $val = 'o';
    } elsif ($val eq 'Y' && $right && $right !~ /^([$SAMPA_CONSONANTS]|@`$)/) {
        # «y» /aI/ becomes «ai» before other vowels
        # (except before final /@` -- that combination becomes «yr»)
        $val = 'ai';
    } elsif ($val eq 'oi' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «oi» /OI/ becomes «oy» at the end of words and before other vowels
        $val = 'oy';
    } elsif ($val eq 'ou' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «ou» /aU/ becomes «ow» at the end of words and before other vowels
        $val = 'ow';
    } elsif ($val eq 'uu' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «uu» /u:/ becomes «u» at the end of words and before other vowels
        $val = 'u';
    } elsif ($val =~ /^ng?$/ && $right =~ /^k/ && $left !~ /^('?[eiu]|[cn]='?o)$/) {
        # Before /k/, «n» is pronounced /N/ rather then /n/, unless the word starts with
        # «con, en, in, non, un»; /n/ becomes «nn» in this position
        $val = $val eq 'n' ? 'nn' : 'n';
    } elsif ($val eq 'r' && $left =~ /r$/) {
        # Eliminate double «r»
        $val = '';
    }

    if ($val =~ /^[aou]/) {
        # /s/ becomes «ss» between any vowel and a vowel starting with «a, o, u»
        $left =~ s/($LYTSPEL_VOWELS=)s($OPT_STRESS_MARKER)$/$1ss$2/;
    } elsif ($val =~ /^[eiY]/) {
        # /s/ becomes «c» between any vowel and a vowel starting with «e, i, y»
        $left =~ s/($LYTSPEL_VOWELS=)s($OPT_STRESS_MARKER)$/$1c$2/;
    }

    if ($val !~ /^['eiYy]/) {
        # Non-final /k/ becomes «c» unless followed by any of «e, i, y»
        $left =~ s/k($OPT_STRESS_MARKER)$/c$1/;
    }

    if ($val =~ /^$LYTSPEL_VOWELS/) {
        # /z/ becomes «s» between two vowels
        $left =~ s/($LYTSPEL_VOWELS=)z($OPT_STRESS_MARKER)$/$1s$2/;

    }

# TODO decompose script (cf. partsplitter) to suggest compounds; correct and use the
# result for each prefix/suffixes (in: phonetic-dict.csv; out compounds.csv); also handle and
# document schwa/single-letter short changes such as «hexagen» ‹hexagon› due to «he'xagenel»
# ‹hexagonal›; deal with national,nation=al as special case
# TODO Afterwards delete legacy dir?
# Integrate compounds.csv (note that all entries are lower-case)
# TODO Handle prefixes and suffixes correctly («dis, mis; anti, semi» are spelled like that
# regardless of which letter follows; prefixes «baio, nio» ‹bio, neo›;
# suffix «ful» is preserved; «-est» remains as is (never "ast"))
# ‹oncoming› should be analysed as ‹on-coming›
# Ensure that «obzur'vaition» ‹observation› is converted correctly (from «ob'zurv» ‹observe›)
# Ensure that the «tion» and «sion» spellings aren't used in words derived by appending «n» or
# «en», e.g. «ashen, freshen, Rushan, Purzhan»
# Ensure that «tion» and «sion» are preserved in derived words, even if the derived form is
# irregular (e.g. «nationel» ‹national› from «naition» ‹nation›).
# Warn if the chosen variant would have been selected anyway or if a listed word is not in the
# dict or listed twice
# TODO Integrate list of irregular words: «hi, shi, wi, mi» ‹he, she, we, me›
# TODO ‹worry› should become «wurri» (using blacklist-phoneng.txt, but first find out
# why "w'uree" currently wins)
# ‹Christchurch, christcross, christen, Christendom, Christhood, Christianity,
# Christianization, Christianize, Christiansand, dewar, superfluous, cairngorm, martingale,
# Apure, comte, conge, Cambrai, Campeche, canzone, carabiniere, Cavite, Cetinje, chicalote,
# cairngorm, combe, complice, Courtrai, Edirne, esse, estaminet, Este, fettucine, Fiesole,
# Frunze, Gliwice, Iquique, irade, Katowice, Kielce, Kure, Lecce, Lidice, Loiret, Marche,
# marchese, Marinduque, metage, Montefiascone, Mugabe, Nivernais, Ordzhonikidze, Oriente,
# Orjonikidze, Palenque, petuntse, Piave, Que, reflet, Rene, rete, Roubaix, Skopje, Teide,
# Udine, Zabrze, Zaporozhye, zaptieh, Quebecer, mozzette, Anschauung, chiaus, kiaugh, Yaounde,
# elasmobranch, Gelsenkirchen, nomenclature, abranchial, abranchiate, alencon, Algonquian,
# asynchronism, asynchronous, Barranquilla, Bianca, blanquette, charabanc, palanquin,
# pancratium, Chinkiang, messieurs›:
# PhonEng should win
# ‹bourgeois, cha, christian, grandma, grandpa, overslaugh, Quebec›: RP should win
# ‹cushaw, da, na, ca, Sta, conquest, wonk›: original spelling should remain
# Custom spellings (note: better specify /pronunciation/ instead of resulting spelling):
# pshaw -> shaw, brough -> brok, cushaw: cu'shaw, duomo: dwoamo, foh: faw,
# kakemono: caake'moano, Charleroi: Shauleroy, branchiopod: brankiapod, false: faulss
# Delete (foreign words or names): Artois, Borodino, trois, Valoi, Condorcet, Attlee,
# Beauharnais, Beaumarchais, Buonaparte, Cimabue, Courbet, Delaunay, dele, Dubuffet, Duse,
# Farnese, Firenze, Fiume, Foucquet, Giorgione, conversazione, improvvisatore, jefe, jeu,
# jeux, Jorge, Jose, Labe, Lyautey, madre, Manolete, Monteux, mozzette, Piemonte, Quesnay,
# religieux, Tevere, Teyde, ubique, veloce, di, gi, Leopoldo, moi, Pareto, Delacroix, est,
# Francoise, Goncourt
# TODO Continue README from l.366: Disambiguating multigraphs
# TODO Insert hyphens were necessary to prevent misreadings, incl.
# unstressed /a/ after /i:/ or /I/:  «am'neesi-ak, zoadi-ak» ‹amnesiac, zodiac›.
# unstressed /a/ after /u:/ e.g. «bivu-ak» ‹bivouac›
    return combine($left, $val);
}

# restore_capitalization $converted, $tradspell: Restore the proper capitalization of a converted
# word. Also deletes separators ('=').
sub restore_capitalization {
    my ($converted, $tradspell) = @_;
    # Delete separators ('=') and convert capital letters to lower case (vowel «Y» as
    # distinguished from consonant «y»)
    $converted = lc(delsep $converted);

    # TODO Make sure that this also works if the word starts with a stressed vowel
    $converted = ucfirst($converted) if $tradspell =~ /^[A-Z][a-z']*$/;  # Capitalized

   # TODO Later fully restore capitalization to match tradspell:
   # Mc|MacCapitalized becomes McCapitalized, e.g. «McAdem, McDowel» ‹McAdam, McDowell›;
   # a repeated /k/ sound is preserved, e.g. «McCoy, McKinli» ‹...McKinley›
   # The stress marker is omitted since the second (capitalized) syllable is always stressed
   # (except McEnroe, McIntosh, McIntyre, McNamara where the first syllable is stressed --
   # probably rewrite those without capital letter e.g. as «Makintosh»; ‹Macintosh› is already
   # in the dict)
   # Preserve D?Capitalized by capitalizing the first two vowels, e.g. «DiCaprio, DuuPont»
   # ‹...DuPont›; the stress marker is omitted since the second syllable is always stressed
   # Preserve O'Capitalized, e.g. «O'Braien» ‹O'Brien›; the capitalized O is spoken /oU/
   # N'Djamena and IJssel become simple capitalized words
   # Other Cap'Capitalized words are dropped as foreign names, e.g. ‹L'Oreal›
   # ALL CAPS and other forms are considered proper names or abbreviations are also dropped
   # lowercase (including apostrophes)
    ##if ($tradspell =~ /^[a-z']+$/) {  # lowercase (including apostrophes)
    return $converted;
}

# convert_pron $pron, $mapref, $maxkeylen, $tradspell: Convert a pronunciation using a given
# mapping alphabet (dictionary reference).
# $maxkeylen is the maximumg length of keys that may occur in $mapref.
sub convert_pron {
    my ($pron, $mapref, $maxkeylen, $tradspell) = @_;
    return '' unless $pron;  # Empty input

    my $unconverted = $pron;
    my $converted   = '';

OUTER: while ($unconverted) {
        my $charcount = min $maxkeylen, length $unconverted;

    INNER: while ($charcount) {
            my $start = substr $unconverted, 0, $charcount;
            my $rest = substr $unconverted, $charcount;

            # No sound starts with '`' or ':'
            if ($rest =~ /^[`:]/) {
                $charcount--;
                next INNER;
            }

            my $val = $mapref->{$start};

            if (defined $val) {  # Match found
                $converted = combine_and_adjust $val, $converted, $rest, $tradspell;
                $unconverted = $rest;
                next OUTER;
            }

            $charcount--;
        }

        die "No match found for converting /$pron/ ($tradspell), "
            . "unconverted part: /$unconverted/\n";
    }

    $converted = restore_capitalization $converted, $tradspell;
    return $converted;
}

# choose_nearer_or_shorter $first, $second, $tradspell: Choose and return $first or $second
# depending on which one is more similar to $tradspell.
# If both are equally similar, the shorter one is returned
# If there is still a tie, $first is returned.
# If $second is undefined or empty, $first is returned without further checks.
sub choose_nearer_or_shorter {
    my ($first, $second, $tradspell) = @_;
    return $first unless $second;

    my $comp = dist($first, $tradspell) <=> dist($second, $tradspell);
    $comp = length($first) <=> length($second) unless $comp;
    # TODO Find out how to disambiguate these cases
    #warn "$first and $second have equal distance to $tradspell and equal length\n" unless $comp;

    return ($comp <= 0) ? $first : $second;
}

# select_nearest_and_calc_distance: Select among the three converted spellings the one that's
# closest to $tradspell and return it. Also returns the edit distance between the selected
# spelling and $tradspell as a second value.
# $converted_ga and $converted_phoneng may be empty.
sub select_nearest_and_calc_distance {
    my ($converted_rp, $converted_ga, $converted_phoneng, $tradspell) = @_;
    my $choosen = choose_nearer_or_shorter $converted_rp, $converted_ga, $tradspell;
    $choosen = choose_nearer_or_shorter $choosen, $converted_phoneng, $tradspell;
    my $dist = dist $choosen, $tradspell;

    # TODO For now, we just prefix the choosen value with a '*'
    if ($choosen eq $converted_rp) {
        # Omit '*' if it's the only value
        $converted_rp = "*$converted_rp" if $converted_ga || $converted_phoneng;
    } elsif ($choosen eq $converted_ga) {
        $converted_ga = "*$converted_ga";
    } else {
        $converted_phoneng = "*$converted_phoneng";
    }

    return $converted_rp, $converted_ga, $converted_phoneng, $dist;
}

# convert_dict: Convert SAMPA spellings to Lytspel.
sub convert_dict {
    my ($mapref, $maxkeylen) = build_mapping;
    open my $infh, '<', $IN_FILE or die "Unable to open $IN_FILE: $!\n";
    my $colref = $CSV_IN->getline($infh);  # Skip header line
    my $outfh = open_outfile_and_write_header $OUT_FILE, [qw(Traditional POS Redirect Lytspel)];
    my $summed_dist = 0;
    my $wordcount   = 0;

    while ($colref = $CSV_IN->getline($infh)) {
        if (scalar @$colref < 4) {
            # Nothing to convert, just output line as is
            $CSV_OUT->print($outfh, $colref);
            next;
        }

        my $tradspell = $colref->[0];
        my ($rp, $ga, $phoneng) = unify_sounds $colref->[3], $colref->[4], $colref->[5], $tradspell;
        my $converted_rp      = convert_pron $rp,      $mapref, $maxkeylen, $tradspell;
        my $converted_ga      = convert_pron $ga,      $mapref, $maxkeylen, $tradspell;
        my $converted_phoneng = convert_pron $phoneng, $mapref, $maxkeylen, $tradspell;

        # Omit GA if identical to RP
        $converted_ga = '' if $converted_ga eq $converted_rp;
        # Omit PhonEng if identical to RP or GA
        $converted_phoneng = ''
            if $converted_phoneng eq $converted_rp || $converted_phoneng eq $converted_ga;

        # TODO Finally keep only the spelling that's closest to tradspell.
        my $dist;
        ($converted_rp, $converted_ga, $converted_phoneng, $dist) =
            select_nearest_and_calc_distance $converted_rp, $converted_ga, $converted_phoneng,
            $tradspell;
        $summed_dist += $dist;
        $wordcount++;

        # TODO Move stress marker before stressed syllable, omitting if the first vowel is the
        # stressed one
        # «ss» is separated by the marker: as'sault, as'sumption
        # «nng» may become «n'g»: «en'gaij, in'grain» ‹engage, ingrain›
        $CSV_OUT->print($outfh,
            [@$colref[0 .. 2], $converted_rp, $converted_ga, $converted_phoneng]);

        # TODO Finally drop POS tag if all variants are written the same, e.g. «mouth»
    }

    my $avg_dist = $summed_dist / $wordcount;
    say "Average distance between tradspell and Lytspel: $avg_dist";

    close $infh;
    close $outfh;
}

# Main block
convert_dict;
