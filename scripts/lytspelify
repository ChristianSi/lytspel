#!/usr/bin/perl -CA
# Convert phonetic SAMPA spellings into Lytspel.
#
# Copyright (c) 2016 Christian Siefkes
# See accompanying LICENSE file for licensing information.
#
# Required modules: Const::Fast, Text::Hyphen, Text::LevenshteinXS, and those listed in PhonEng.pm.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Const::Fast;
use Cwd 'abs_path';
use File::Basename 'dirname';
use List::Util qw(min max);
use Text::Hyphen;
use Text::LevenshteinXS 'distance';

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

const my $IN_FILE     => 'phonetic-dict.csv';
const my $OUT_FILE    => 'lytspel-dict.csv';
const my $COMPOUNDS   => 'compounds.csv';
const my $PHONEME_MAP => 'phoneme-map.csv';

# Vowel letters in SAMPA and Lytspel
const my $SAMPA_VOWELS   => '@:#3aAeEiIoOQuUV';
const my $LYTSPEL_VOWELS => 'aeiouY';
# Consonant letters
const my $SAMPA_CONSONANTS => '`bdDfghjklmnNprsStTvwzZ';
# Pattern fragment matching an optional stress marker
const my $OPT_STRESS_MARKER => "(?:=')?";
# Pattern fragment matching a Lytspel consonant
const my $LYTSPEL_CONSONANT => "(?:(?:[bcdfghjklmnprstvwxyz]h?|nn?g|qu)=?)";

# Stress the second part of a compound if the first part is listed here
my %STRESS_AFTER = map { $_ => 1 } qw/arch best chemo con crypt crypto dynamo ego ere
    extra fibro helio here hetero hydro hypo mon nitro peri psycho pyro supra thence
    there thio ultra where/;

# Stress the second part of a compound if listed here
my %STRESS_IF_SECOND = map { $_ => 1 } qw/air angular basic east eastward eastwards ever
    genesis genic graphic metric optic phobia phobic self selves teen tropic west
    westward westwards/;

# If the first part of a compound is listed here, either part may be stressed (we check
# the pronunciation to find out).
my %STRESS_VARIES_IF_FIRST = map { $_ => 1 } qw/auto contra electro mono para photo poly
    radio retro/;

my $CSV_IN  = new_csv_in;
my $CSV_OUT = new_csv_out;
my $HYPH    = new Text::Hyphen min_word => 3, min_prefix => 1, min_suffix => 1;
# The following two variables are globals for simplicity
my $SUMMED_DIST = 0;
my $WORD_COUNT  = 0;

# build_mapping: Create and return a mapping from SAMPA to the standard Lytspel spellings.
# Also return the length of the longest key in the map.
sub build_mapping {
    my %dict;
    my $maxkeylen = 0;
    open my $fh, '<', $PHONEME_MAP or die "Unable to open $PHONEME_MAP: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $sampa   = $colref->[0];
        my $lytspel = $colref->[4];

        # Skip if SAMPA or Lytspel entry is missing or if SAMPA is '-'
        next unless valid_key($sampa) && $lytspel;

        $maxkeylen = max $maxkeylen, length($lytspel);
        $dict{$sampa} = $lytspel;

        # Add stressed variant if phoneme is a consonant followed by a vowel
        if ($sampa =~ /^[$SAMPA_CONSONANTS][$SAMPA_VOWELS]/) {
            my $stressed_key = substr($sampa, 0, 1) . "'" . substr($sampa, 1);
            my $stressed_val = "'$lytspel";
            $maxkeylen = max $maxkeylen, length($stressed_val);
            $dict{$stressed_key} = $stressed_val;
        }
    }

    close $fh;
    return \%dict, $maxkeylen;
}

# build_compound_map: Create and return a mapping from compounds and derived forms to their
# building blocks.
sub build_compound_map {
    my %dict;
    open my $fh, '<', $COMPOUNDS or die "Unable to open $COMPOUNDS: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        $dict{$colref->[0]} = $colref->[1];
    }

    close $fh;
    return \%dict;
}

# gen_key $word, $pos: Combine a word and a optional POS tag into a joint key.
# If $pos is undefined or empty, $word alone is returned, otherwise "$word/$pos" is returned.
sub gen_key {
    my ($word, $pos) = @_;
    return $pos ? "$word/$pos" : $word;
}

# build_unconverted_dict_and_case_redirects: Returns references to two hashes:
# 1. From keys (see 'gen_key' function) to the complete $IN_FILE entries describing them
# 2. From lower-cased forms of words containing capital letters to their cased form
#    (e.g. 'europe' -> 'Europe')
sub build_unconverted_dict_and_case_redirects {
    open my $infh, '<', $IN_FILE or die "Unable to open $IN_FILE: $!\n";
    my $colref = $CSV_IN->getline($infh);  # Skip header line
    my %unconverted_dict;
    my %case_redirect;

    while ($colref = $CSV_IN->getline($infh)) {
        my $word = $colref->[0];
        my $pos  = $colref->[1];
        my $key  = gen_key $word, $pos;
        $unconverted_dict{$key} = $colref;
        $case_redirect{lc $word} = $word if $word =~ /[A-Z]/;
    }

    close $infh;
    return \%unconverted_dict, \%case_redirect;
}

# delsep $str: Delete any occurrences of '=' (used as separator) from a string.
sub delsep {
    my $str = shift;
    $str =~ s/=//g;
    return $str;
}

# dist $str1, $str2: Calculate the Levenshtein edit distance between two strings, ignoring case.
# Separators are deleted from both strings before doing the conversion:
sub dist {
    my ($str1, $str2) = @_;
    return distance(lc(delsep $str1), lc(delsep $str2));
}

# e_or_u_or_other $other, $left, $right, $tradspell: Return 'e', 'u', or $other depending on which
# is most similar to $tradspell. In case of a tie, 'e' is preferred over 'u' and $other is
# preferred over both. $other is ignored if it's is undefined or empty.
sub e_or_u_or_other {
    my ($other, $left, $right, $tradspell) = @_;

    # Schwa before vowels is always spelled «e»
    return 'e' if $right && $right !~ /^[$SAMPA_CONSONANTS]/;

    my $result =
        dist($tradspell, "${left}e$right") <= dist($tradspell, "${left}u$right") ? 'e' : 'u';

    if ($other) {
        $result =
            dist($tradspell, "$left$other$right") <= dist($tradspell, "$left$result$right")
            ? $other
            : $result;
    }

    return $result;
}

# any_short_vowel $left, $right, $tradspell: Return any of the five vowel letters depending on
# which is most similar to $tradspell. Ties are resolved by preferring the left-most match from
# the following list: e, u, a, o, i. ('e' and 'u' are generally preferred because their sound
# is close to a schwa sound, the other vowel letters are ranked by how often they represent a
# schwa in tradspel.)
sub any_short_vowel {
    my ($left, $right, $tradspell) = @_;
    my $chosen  = '';
    my $olddist = 1000;

    for my $vowel (qw/e u a o i/) {
        my $newdist = dist($tradspell, "$left$vowel$right");

        if ($newdist < $olddist) {
            $chosen  = $vowel;
            $olddist = $newdist;
        }
    }

    return $chosen;
}

# combine $left, $right: Combine two strings into one.
# Except when $left ends with a stress marker ("'") or either string is empty, the strings are
# separated by '='.
sub combine {
    my ($left, $right) = @_;
    return $left =~ /'$/ || !$right || !$left ? "$left$right" : "$left=$right";
}

# combine_and_adjust $val, $left, $right, $tradspell: Combine $left and $val into a joined
# string, applying context-specific rules to the resulting spelling as suitable.
sub combine_and_adjust {
    my ($val, $left, $right, $tradspell) = @_;

    if ($right eq '') {
        # End of word spellings

        if ($val eq '@' || $val eq 'a#') {
            # Final schwa becomes «er» if tradspell ends in ‹r› (typical for non-rhotic RP),
            # otherwise «a»
            $val = $tradspell =~ /r$/ ? 'er' : 'a';
        } elsif ($val eq 'e') {
            # Final «e» /E/ becomes «eh»
            $val = 'eh';
        } elsif ($val eq 'u') {
            # Final /V/ is spelled «uh»
            $val = 'uh';
        } elsif ($val eq 'er' && $left =~ /Y$/) {
            # Final /aI@`/ is written «yr», e.g. «fyr, in'spyr» ‹fire, inspire›
            $val = 'r';
        } elsif ($val eq 'k' && $left =~ /[^'aeou]i$/) {
            # «c» is used at the end of words ending in unstressed /Ik/
            $val = 'c';
        } elsif ($val eq 'l' && $left =~ /au$/) {
            # Final /O:l/ is written «all», e.g. «ball»
            $left =~ s/au$/al/;
        } elsif ($left !~ /([fkpt]|th)$/) {
            # Final /s/ becomes «ss» and /z/ becomes «s» except after /f, k, p, t, T/
            if ($val eq 's') {
                $val = 'ss';
            } elsif ($val eq 'z') {
                $val = 's';
            }
        }
    }

    if ($val eq '@' && $right eq 'l' && $left =~ /[bpdtfgksz]$/) {
        # Schwa is omitted between any of /b, p, d, t, f, g, k/ and final /l/
        $val = '';

        # Final /s@l/ is written «ssl» and final /z@l/ is written «sl»
        if ($left =~ /s$/) {
            $left .= 's';
        } elsif ($left =~ /z$/) {
            chop $left;
            $left .= 's';
        }

    } elsif ($val eq '@' && $right eq 'm' && $left =~ /z$/) {
        # Final /z@m/ is written «sm»
        $val = '';
        chop $left;
        $left .= 's';
    } elsif ($val eq '@' && $right eq 'm' && $left =~ /dh$/) {
        # Schwa is also omitted between /D/ and final /m/
        $val = '';
    } elsif ($val eq '@' && $right eq 'n' && $left =~ /[sz]h$/) {
        # Final /S@n/ becomes «tion» and /Z@n/ becomes «sion»
        $val = 'o';
        $left =~ s/sh$/ti/;
        $left =~ s/zh$/si/;
    } elsif ($val =~ /^(@|a#|I#)$/ && $right =~ /^[$SAMPA_CONSONANTS]*'/) {
        # Any schwa followed by a stressed vowel can become «e/u/a/o/i» (in preference order)
        $val = any_short_vowel $left, $right, $tradspell;
    } elsif ($val eq '@') {
        # /@/ becomes «e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('', $left, $right, $tradspell);
    } elsif ($val eq 'a#') {
        # /a#/ becomes «a/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('a', $left, $right, $tradspell);
    } elsif ($val eq 'I#') {
        # /I#/ becomes «i/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('i', $left, $right, $tradspell);
    } elsif ($val eq 'ai' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «ai» /eI/ becomes «ay» at the end of words and before other vowels
        $val = 'ay';
    } elsif ($val eq 'au' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «au» /O:/ becomes «aw» at the end of words and before other vowels
        $val = 'aw';
    } elsif ($val eq 'ee' && $right !~ /^[$SAMPA_CONSONANTS]/ && $left !~ /'$/) {
        # Unstressed «ee» /i:/ becomes «i» at the end of words and before other vowels
        $val = 'i';
    } elsif ($val eq 'oa' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «oa» /oU/ becomes «o» at the end of words and before other vowels
        $val = 'o';
    } elsif ($val eq 'Y' && $right && $right !~ /^([$SAMPA_CONSONANTS]|@`$)/) {
        # «y» /aI/ becomes «ai» before other vowels
        # (except before final /@` -- that combination becomes «yr»)
        $val = 'ai';
    } elsif ($val eq 'oi' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «oi» /OI/ becomes «oy» at the end of words and before other vowels
        $val = 'oy';
    } elsif ($val eq 'ou' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «ou» /aU/ becomes «ow» at the end of words and before other vowels
        $val = 'ow';
    } elsif ($val eq 'uu' && $right !~ /^[$SAMPA_CONSONANTS]/) {
        # «uu» /u:/ becomes «u» at the end of words and before other vowels
        $val = 'u';
    } elsif ($val =~ /^ng?$/ && $right =~ /^k/ && $left !~ /^('?[eiu]|[cn]='?o)$/) {
        # Before /k/, «n» is pronounced /N/ rather then /n/, unless the word starts with
        # «con, en, in, non, un»; /n/ becomes «nn» in this position
        $val = $val eq 'n' ? 'nn' : 'n';
    } elsif ($val eq 'r' && $left =~ /r$/) {
        # Eliminate double «r»
        $val = '';
    }

    if ($val =~ /^[aou]/) {
        # /s/ becomes «ss» between any vowel and a vowel starting with «a, o, u»
        $left =~ s/([$LYTSPEL_VOWELS]=)s($OPT_STRESS_MARKER)$/$1ss$2/;
    } elsif ($val =~ /^[eiY]/) {
        # /s/ becomes «c» between any vowel and a vowel starting with «e, i, y»
        $left =~ s/([$LYTSPEL_VOWELS]=)s($OPT_STRESS_MARKER)$/$1c$2/;
    }

    if ($val !~ /^['eiYy]/) {
        # Non-final /k/ becomes «c» unless followed by any of «e, i, y»
        $left =~ s/k($OPT_STRESS_MARKER)$/c$1/;
    }

    if ($val =~ /^[$LYTSPEL_VOWELS]/) {
        # /z/ becomes «s» between two vowels
        $left =~ s/([$LYTSPEL_VOWELS]=)z($OPT_STRESS_MARKER)$/$1s$2/;

    }

    # TODO Afterwards delete legacy dir?
    # TODO Integrate list of irregular words: «hi, shi, wi, mi» ‹he, she, we, me›
    # TODO ‹worry› should become «wurri» (but first find out why "w'uree" currently wins)
    # ‹Christchurch, christcross, christen, Christendom, Christhood, Christianity,
    # Christianization, Christianize, Christiansand, dewar, superfluous, cairngorm, martingale,
    # Apure, comte, conge, Cambrai, Campeche, canzone, carabiniere, Cavite, Cetinje, chicalote,
    # cairngorm, combe, complice, Courtrai, Edirne, esse, estaminet, Este, fettucine, Fiesole,
    # Frunze, Gliwice, Iquique, irade, Katowice, Kielce, Kure, Lecce, Lidice, Loiret, Marche,
    # marchese, Marinduque, metage, Montefiascone, Mugabe, Nivernais, Ordzhonikidze, Oriente,
    # Orjonikidze, Palenque, petuntse, Piave, Que, reflet, Rene, rete, Roubaix, Skopje, Teide,
    # Udine, Zabrze, Zaporozhye, zaptieh, Quebecer, mozzette, Anschauung, chiaus, kiaugh, Yaounde,
    # elasmobranch, Gelsenkirchen, nomenclature, abranchial, abranchiate, alencon, Algonquian,
    # asynchronism, asynchronous, Barranquilla, Bianca, blanquette, charabanc, palanquin,
    # pancratium, Chinkiang, messieurs, baklava, baklawa, concubinary, Alkmaar, neurosecretion,
    # Avalokitesvara, Blagoveshchensk, lorgnette, dimenhydrinate, paresthesia, postliminy,
    # transhumance, uphroe, isoperimetry, Juneteenth, homeostasis, craquelure, erysipelas,
    # erysipelatous, armipotent, bersaglieri, coparcenary, dolichocephalic, Hanseatic, Miskolc,
    # leptocephalic, platycephalic, popliteal, popliteus, Vespucci, scleroderma, Tlaxcala,
    # sexagenary, abiogenetic, anthropogenetic, cytogenetics, digenetic, ectogenetic,
    # epeirogenetic, gamogenetic, gluconeogenetic, glycogenetic, glycogenolysis, histogenetic,
    # homogenetic, hydrogenolysis, hypnogenetic, immunogenetics, ontogenetic, orogenetic,
    # parthenogenetic, pathogenetic, quadragenarian, quinquagenarian, schizogenetic,
    # septuagenarian, thermogenetic, xenogenetic, zygogenetic, ecarte, immortelle, parterre,
    # Parthenope, tartare, theretofore, inglenook, christiania, dessiatine, dishabille, misoneism,
    # plano, marmot, monseigneur, amine, sitology, choplogic, archenteric, Betamax›:
    # PhonEng should win
    # ‹bourgeois, cha, christian, grandma, grandpa, overslaugh, Quebec, Fitzroy, grease
    # (POS tag shouldn't make a difference), implead, nitro›: RP should win
    # ‹marcel, marcella›: GE should win
    # ‹cushaw, da, na, ca, Sta, conquest, wonk›: original spelling should remain
    # Custom spellings (note: better specify /pronunciation/ instead of resulting spelling):
    # pshaw -> shaw, brough -> brok, cushaw: cu'shaw, duomo: dwoamo, foh: faw, amain: a'main
    # kakemono: caake'moano, Charleroi: Shauleroy, branchiopod: brankiapod, false: faulss,
    # formidable: /f'O:rmId@b@l/, askari: /'ask@`i:/, voltameter: /vQlt'amIt@`/,
    # zoometry /zoU'om@tri:/ -> zo'ometri; zoography /zoU'ografi:/ -> zo'ografi,
    # decagon /d'Ek@gQn/ -> dekegon
    # Delete (foreign words or names): Artois, Borodino, trois, Valoi, Condorcet, Attlee,
    # Beauharnais, Beaumarchais, Buonaparte, Cimabue, Courbet, Delaunay, dele, Dubuffet, Duse,
    # Farnese, Firenze, Fiume, Foucquet, Giorgione, conversazione, improvvisatore, jefe, jeu,
    # jeux, Jorge, Jose, Labe, Lyautey, madre, Manolete, Monteux, mozzette, Piemonte, Quesnay,
    # religieux, Tevere, Teyde, ubique, veloce, di, gi, Leopoldo, moi, Pareto, Delacroix, est,
    # Francoise, Goncourt, Castiglione, Descartes, Msgr, Sturmabteilung, Magritte, Dessalines,
    # Lufthansa, ai, bien
    # Warn if the chosen variant would have been selected anyway or if a listed word is not in the
    # dict or listed twice
    # TODO Continue README from l.366: Disambiguating multigraphs
    # TODO Insert hyphens were necessary to prevent misreadings, incl.
    # unstressed /a/ after /i:/ or /I/:  «am'neesi-ak, zoadi-ak» ‹amnesiac, zodiac›.
    # unstressed /a/ after /u:/ e.g. «bivu-ak» ‹bivouac›
    return combine($left, $val);
}

# insert_at_start $consonants: Insert a stress at the start of a consonant sequence (separated
# by '='). Also restores the final '='.
sub insert_at_start {
    my ($consonants) = @_;
    return "'$consonants=";
}

# insert_after_first $cons_pair: Insert a stress marker after the first consonant of a sequence.
# Also restores the final '='.
sub insert_after_first {
    my ($cons_pair) = @_;
    $cons_pair =~ s/=/='/;
    return "$cons_pair=";
}

# insert_after_second $consonants: Insert a stress marker after the second consonant of a sequence.
# If the sequence contains just one or two consonants, it's inserted at the end instead.
# Also restores the final '='.
sub insert_after_second {
    my ($consonants) = @_;
    $consonants .= '=';
    return $consonants =~ s/(.*?=.*?=)/$1'/r;
}

# insert_at_end $consonants: Insert a stress at the end of a consonant sequence (separated by '=').
# Also restores the final '='.
sub insert_at_end {
    my ($consonants) = @_;
    return "$consonants='";
}

# hyphenated_contains $hyphenated, $pattern: Return true-ish iff $hyphenated contains
# $pattern. Also accepts some legacy spellings, e.g. 'ph' instead of 'f', '=c' instead of '=s',
# and 'ce=' instead of 's='.
sub hyphenated_contains {
    my ($hyphenated, $pattern) = @_;
    $pattern =~ s/[ck](?!h)/(c[hk]?|k)/;  # c|k may be written as any of c|ch|ck|k
    $pattern =~ s/dh/th/;
    $pattern =~ s/f/(f|ph)/;
    $pattern =~ s/j/[gj]/;
    $pattern =~ s/(n[gn])=/$1?=/;         # 'g' or second 'n' after 'n' is optional
    $pattern =~ s/([rv])=/$1e?=/;
    $pattern =~ s/=s/=[sc]/;
    $pattern =~ s/s=/(s|ce)=/;
    $pattern =~ s/z(?!h)/[sz]/;
    return $hyphenated =~ /$pattern/;
}

# insert_stress_marker_among_multiple_consonants $consonants, $hyphenated, $tradspell, $sep_count:
# Insert a stress marker in the proper place in a sequence of three or more consonants.
sub insert_stress_marker_among_multiple_consonants {
    my ($consonants, $hyphenated, $tradspell, $sep_count) = @_;
    my @cons     = split /=/, $consonants;
    my $left     = '';
    my $left_sep = '';

    # Check after which consonant the break should occur
    while (@cons) {
        my $next = shift @cons;
        $left .= $next;
        $left_sep .= "$next=";
        my $rest = join '', @cons;

        return "$left_sep'" . join('=', @cons) . '='
            if hyphenated_contains $hyphenated, "$left=$rest";
    }

    # No break found, so we use suitable defaults:
    # Break before consonant sequence, e.g. «in'struction, converrsaa'tsyoneh»
    # ‹instruction, conversazione›
    return insert_at_start $consonants if $consonants =~ /^(s=t=r|t=s=y)$/;

    # Break after second consonant, e.g. «ump'teen, Pyonj'yang, Burg'soanian, poast'limeni,
    # Fits'patric» ‹umpteen, Pyongyang, Bergsonian, postliminy, Fitzpatrick›
    return insert_after_second $consonants
        if $consonants =~ /^(m=p=t|n=j=y|r=g=s|s=t=l|t=s=[jpr])$/;

    # Otherwise break after first of three consonants, or after second of four
    return insert_after_first $consonants if $sep_count == 2;
    return insert_after_second $consonants;
}

# insert_stress_marker $consonants, $hyphenated, $tradspell: Insert a stress marker in the
# proper place in the sequence of $consonants before a stressed vowel.
sub insert_stress_marker {
    my ($consonants, $hyphenated, $tradspell) = @_;
    my $just_consonants = $consonants =~ s/=//gr;

    # Move stress marker before whole consonant sequence
    return insert_at_start $consonants if $hyphenated =~ /=$just_consonants/;

    # Break after 'ns', if $hyphenated confirms that or $tradspell contains 'trans'
    # (followed by ca|g|l|n|v)
    return insert_after_second $consonants
        if $just_consonants =~ /^(ns)(.*)/
        && ($hyphenated =~ /$1=$2/ || $tradspell =~ /trans(ca|g|l|n|v)/i);

    $consonants =~ s/=$//;  # drop final '='
    my $sep_count = () = $consonants =~ /=/g;

    # Three or more consonants
    return insert_stress_marker_among_multiple_consonants $consonants, $hyphenated, $tradspell,
        $sep_count
        if $sep_count > 1;

    # Second case covers e.g. «eg'zact, ang'zaieti, lug'zhueriass» ‹exact, anxiety, luxurious›
    return insert_after_first $consonants
        if hyphenated_contains $hyphenated, $consonants || $consonants =~ /g=z/;

    # Some special cases
    return insert_at_end $consonants if $tradspell eq 'Antarctica';
    return insert_after_first $consonants
        if ($consonants =~ /^s=/ && $tradspell =~ /^dis/i)
        || ($consonants eq 'c=l' && $tradspell =~ /^Ma?cL/i)
        || ($consonants eq 'p=l' && $tradspell =~ /^popl/i);

    # Break before both consonants if the first is 's' or if the second is 'l' or 'r'
    return insert_at_start $consonants if $consonants =~ /^s=|=[lr]$/;

    # Otherwise break in middle
    return insert_after_first $consonants;
}

# move_stress_marker $word, $tradspell: Move stress marker before the stressed syllable,
# omitting it if the first vowel is the stressed one.
sub move_stress_marker {
    my ($word, $tradspell) = @_;

    return $word unless $word =~ /'/;  # Nothing to do

    if ($word =~ /(.*?)($LYTSPEL_CONSONANT*)'/) {
        my $pre_match                = $1;
        my $consonants_before_marker = $2;

        if ($pre_match eq '') {
            # First vowel is the stressed one
            $word =~ s/'//;
        } elsif ($consonants_before_marker eq '') {
            # Stressed vowel is preceded by another vowel: nothing to do
        } elsif ($consonants_before_marker =~ /^(ss|rr)=$/) {
            # «ss» and «rr» are separated by the marker,
            # e.g. «as'sault, as'sumption, hor'rific»
            $word =~ s/(.)='/'$1=/;
        } elsif ($consonants_before_marker =~ /^nng/) {
            # "nng..." becomes "n'g..."
            $word =~ s/nn(g=.*?)'/n'$1/;
        } elsif ($consonants_before_marker =~ '^[^=]+=$') {
            # Move stress marker before the single consonant
            $word =~ s/$consonants_before_marker'/'$consonants_before_marker/;
        } else {
            # Ask Text::Hyphen
            my $hyphenated = $HYPH->hyphenate($tradspell, '=');
            my $stressed_cons = insert_stress_marker $consonants_before_marker, $hyphenated,
                $tradspell;
            $word =~ s/$consonants_before_marker'/$stressed_cons/;
        }

    } else {
        # This shouldn't happen
        warn "Don't know how to move stress in '$word' ($tradspell)\n";
    }

    return $word;
}

# restore_capitalization $converted, $tradspell: Restore the proper capitalization of a converted
# word. Also deletes separators ('=').
sub restore_capitalization {
    my ($converted, $tradspell) = @_;
    # Delete separators ('=') and convert capital letters to lower case (vowel «Y» as
    # distinguished from consonant «y»)
    $converted = lc(delsep $converted);

    $converted = ucfirst($converted) if $tradspell =~ /^[A-Z][a-z']*$/;  # Capitalized

   # TODO Later fully restore capitalization to match tradspell:
   # Mc|MacCapitalized becomes McCapitalized, e.g. «McAdem, McDowel» ‹McAdam, McDowell›;
   # a repeated /k/ sound is preserved, e.g. «McCoy, McKinli» ‹...McKinley›
   # The stress marker is omitted since the second (capitalized) syllable is always stressed
   # (except McEnroe, McIntosh, McIntyre, McNamara where the first syllable is stressed --
   # probably rewrite those without capital letter e.g. as «Makintosh»; ‹Macintosh› is already
   # in the dict)
   # Preserve D?Capitalized by capitalizing the first two vowels, e.g. «DiCaprio, DuuPont»
   # ‹...DuPont›; the stress marker is omitted since the second syllable is always stressed
   # Preserve O'Capitalized, e.g. «O'Braien» ‹O'Brien›; the capitalized O is spoken /oU/
   # N'Djamena and IJssel become simple capitalized words
   # Other Cap'Capitalized words are dropped as foreign names, e.g. ‹L'Oreal›
   # ALL CAPS and other forms are considered proper names or abbreviations are also dropped
   # lowercase (including apostrophes)
    ##if ($tradspell =~ /^[a-z']+$/) {  # lowercase (including apostrophes)
    return $converted;
}

# convert_pron $pron, $mapref, $maxkeylen, $tradspell: Convert a pronunciation using a given
# mapping alphabet (dictionary reference).
# $maxkeylen is the maximumg length of keys that may occur in $mapref.
sub convert_pron {
    my ($pron, $mapref, $maxkeylen, $tradspell) = @_;
    return '' unless $pron;  # Empty input

    my $unconverted = $pron;
    my $converted   = '';

OUTER: while ($unconverted) {
        my $charcount = min $maxkeylen, length $unconverted;

    INNER: while ($charcount) {
            my $start = substr $unconverted, 0, $charcount;
            my $rest = substr $unconverted, $charcount;

            # No sound starts with '`' or ':'
            if ($rest =~ /^[`:]/) {
                $charcount--;
                next INNER;
            }

            my $val = $mapref->{$start};
            if (defined $val) {  # Match found
                $converted = combine_and_adjust $val, $converted, $rest, $tradspell;
                $unconverted = $rest;
                next OUTER;
            }

            $charcount--;
        }

        die "No match found for converting /$pron/ ($tradspell), "
            . "unconverted part: /$unconverted/\n";
    }

    $converted = move_stress_marker $converted,     $tradspell;
    $converted = restore_capitalization $converted, $tradspell;
    return $converted;
}

# prepare_pron $pron: Fix the pronunication of a word by normalizing non-standard forms.
sub prepare_pron {
    my $pron = shift;
    # Normalize alternative forms of the r-colored schwa
    $pron =~ s/(?<![ei])\@r|\@`r|a#r/\@`/g;
    # If there are multiple stress markers, remove all but the last one
    $pron =~ s/'(?=.*')//g;
    return $pron;
}

# Unify a sound that may be pronounced differently in two accents. Arguments:
#
# * $rp: British pronunciation
# * $ga: American pronunciation
# * $phoneng: PhonEng pronunciation (optional)
# * $alt1: how the vowel is pronounced in RP (treated as a regex)
# * $alt2: how it is pronounced in GA (treated as a regex)
# * $winner: the pronouncation that should be used
# * $tradspell: the traditional spelling (used for debugging/logging)
# * $suppress_warning: set to a true value to suppresss a warning if unification isn't possible
#   (useful for unreliable latterns)
sub unify_sound {
    my ($rp, $ga, $phoneng, $alt1, $alt2, $winner, $tradspell, $suppress_warning) = @_;

    my $rp_alt1_count = () = $rp =~ /$alt1/g;
    my $ga_alt2_count = () = $ga =~ /$alt2/g;

    return $rp, $ga, $phoneng unless $rp_alt1_count && $ga_alt2_count;  # Nothing to do

    # Split on either alternative (NOT matching if /`/ as in /@`/ follows)
    my @rp_split      = split /($alt1|$alt2)(?!`)/, $rp;
    my @ga_split      = split /($alt1|$alt2)(?!`)/, $ga;
    my @phoneng_split = split /($alt1|$alt2)(?!`)/, $phoneng;
    my $rp_elem_count = scalar @rp_split;

    unless ($rp_elem_count == scalar @ga_split) {
        warn "Cannot unify $tradspell pronouncations re $alt1/$alt2\n" unless $suppress_warning;
        return $rp, $ga, $phoneng;
    }

    my $unify_phoneng_too = $rp_elem_count == scalar @phoneng_split;

    for my $i (0 .. $rp_elem_count - 1) {
        if ($rp_split[$i] =~ /^$alt1$/ && $ga_split[$i] =~ /^$alt2$/) {
            $rp_split[$i] = $winner;
            $ga_split[$i] = $winner;

            $phoneng_split[$i] = $winner
                if $unify_phoneng_too && $phoneng_split[$i] =~ /^($alt1|$alt2)$/;
        }
    }

    $rp = join '', @rp_split;
    $ga = join '', @ga_split;

    $phoneng = join '', @phoneng_split if $unify_phoneng_too;

    return $rp, $ga, $phoneng;
}

# Unify the sound used in different pronunciations in cases where a specific vowel
# pronunciation should "win". Generally, unification is only attempted if RP and GA differ;
# otherwise the given pronunciations are returned unchanged. Redundant pronunciations
# (identical to an earlier one) are eliminated in any case.
sub unify_sounds {
    my ($rp, $ga, $phoneng, $tradspell) = @_;
    $rp      = prepare_pron $rp;
    $ga      = prepare_pron $ga;
    $phoneng = prepare_pron $phoneng;

    # Discard GA if identical to RP
    $ga = '' if $ga eq $rp;
    # Discard PhonEng if identical to RP or GA
    $phoneng = '' if $phoneng eq $rp || $phoneng eq $ga;

    # If PhonEng has /Nk/ where RP/GA have /nk/, use the former as it's usually correct
    if ($phoneng =~ /Nk/ && $rp =~ /nk/) {
        ($rp, $phoneng) = unify_sound $rp, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0;
        ($ga, $phoneng) = unify_sound $ga, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0
            if $ga;
    }

    return $rp, $ga, $phoneng unless $ga;  # Nothing more to unify

    # Unify vowels:
    # pair, share, variation -> «air»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'e@', 'Er', 'e@', $tradspell, 0;
    # cheer, year, peculiar -> «eer»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'i:?@', 'Ir', 'i@', $tradspell, 0;
    # poor, tour -> «oor»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'U@', 'Ur', 'Ur', $tradspell, 1;
    # number, modern -> «er» (schwa vs. r-colored schwa)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, '(?<![ei])@', '@`', '@`', $tradspell, 1;
    # port, ignore, keyboard, floral -> «oar»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'or', 'or', $tradspell, 1;
    # sorry, tomorrow -> «orr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Qr', 'O:r', 'Qr', $tradspell, 0;
    # for, dinosaur -> «or»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'O:r', 'O:r', $tradspell, 0;
    # encourage, current -> «urr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Vr', '3:r?', 'Vr', $tradspell, 0;
    # due, neutral, tune -> «ue»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'u:", "(?<![j])'u:", "'U:",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "ju:", "(?<![j'])u:", "U:",
        $tradspell, 0;
    # during, neural -> «uer» (/ju:r/ or /jUr/ in RP, /Ur/ in GA)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'(?:u:|U)r", "(?<![j])'Ur", "'U:r",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j(?:u:|U)r", "(?<![j'])Ur", "U:r",
        $tradspell, 0;

    return $rp, $ga, $phoneng;
}

# choose_nearer_or_shorter $first, $second, $tradspell: Choose and return $first or $second
# depending on which one is more similar to $tradspell.
# If both are equally similar, the shorter one is returned
# If there is still a tie, $first is returned.
# If $second is undefined or empty, $first is returned without further checks.
sub choose_nearer_or_shorter {
    my ($first, $second, $tradspell) = @_;
    return $first unless $second;

    my $comp = dist($first, $tradspell) <=> dist($second, $tradspell);
    $comp = length($first) <=> length($second) unless $comp;
    # TODO Find out how to disambiguate these cases
    #warn "$first and $second have equal distance to $tradspell and equal length\n" unless $comp;

    return ($comp <= 0) ? $first : $second;
}

# select_nearest_and_calc_distance: Select among the three converted spellings the one that's
# closest to $tradspell and return it. Also returns the edit distance between the selected
# spelling and $tradspell as a second value.
# $converted_ga and $converted_phoneng may be empty.
sub select_nearest_and_calc_distance {
    my ($converted_rp, $converted_ga, $converted_phoneng, $tradspell) = @_;
    my $choosen = choose_nearer_or_shorter $converted_rp, $converted_ga, $tradspell;
    $choosen = choose_nearer_or_shorter $choosen, $converted_phoneng, $tradspell;
    my $dist = dist $choosen, $tradspell;
    return $choosen, $dist;
}

# convert_column $colref, $tradspell, $mapref, $maxkeylen: Convert a column (CSV line)
# from $IN_FILE style to $OUT_FILE. Any listed pronunciations are converted using the
# Lytspel rules and the resulting spelling that's nearest to the traditional spelling is
# selected and appended to the resulting output column. Also updates the global
# $SUMMED_DIST and WORD_COUNT variables.
sub convert_column {
    my ($colref, $tradspell, $mapref, $maxkeylen) = @_;
    my ($rp, $ga, $phoneng) = unify_sounds $colref->[3], $colref->[4], $colref->[5], $tradspell;
    my $converted_rp      = convert_pron $rp,      $mapref, $maxkeylen, $tradspell;
    my $converted_ga      = convert_pron $ga,      $mapref, $maxkeylen, $tradspell;
    my $converted_phoneng = convert_pron $phoneng, $mapref, $maxkeylen, $tradspell;

    # Omit GA if identical to RP
    $converted_ga = '' if $converted_ga eq $converted_rp;
    # Omit PhonEng if identical to RP or GA
    $converted_phoneng = ''
        if $converted_phoneng eq $converted_rp || $converted_phoneng eq $converted_ga;

    # Keep only the spelling that's closest to tradspell
    my ($converted, $dist) = select_nearest_and_calc_distance $converted_rp, $converted_ga,
        $converted_phoneng, $tradspell;
    $SUMMED_DIST += $dist;
    $WORD_COUNT++;
    my $conv_colref = [@$colref[0 .. 2], $converted];
    return $conv_colref;
}

# lookup_part $part, $tradspell, $unconverted_dict_ref, $converted_dict_ref, $case_redirect_ref,
# $mapref, $maxkeylen: Look up the entry for a word part of a compound, taking case redirects
# and POS-tagged word parts into account. Returns the converted entry column -- if the word
# hasn't been processed before, it will be converted.
sub lookup_part_entry {
    my ($part, $tradspell, $unconverted_dict_ref, $converted_dict_ref, $case_redirect_ref,
        $mapref, $maxkeylen)
        = @_;
    my $cased         = $case_redirect_ref->{$part};
    my $key           = $cased ? $cased : $part;
    my $unconv_colref = $unconverted_dict_ref->{$key};

    unless ($unconv_colref) {
        # Must be a POS-tagged word -- use some heuristics to pick the correct POS tag
        my $pos = 'v';  # default POS tag (most frequent)
        $pos = 'aj' if $part =~ /ate$/;  # e.g. ‹agglutinate›
        $pos = 'n' if $part =~ /^(house|lead|transfer|transfer|wind)$/ and $tradspell ne 'fairlead';
        $key = gen_key $part, $pos;
        $unconv_colref = $unconverted_dict_ref->{$key};

        unless ($unconv_colref) {
            $key = gen_key $part, 'n';                      # use 'n' as fallback
            $unconv_colref = $unconverted_dict_ref->{$key};
            warn "No entry found for $key\n" unless $unconv_colref;
        }
        # TODO Adapt POS heuristics for prefixed an suffixed forms
    }

    my $conv_colref = $converted_dict_ref->{$key};
    unless ($conv_colref) {
        # Convert word now
        $conv_colref = convert_column $unconv_colref, $cased || $part, $mapref, $maxkeylen;
        $converted_dict_ref->{$key} = $conv_colref;
    }

    return $conv_colref;
}

# handle_compound $colref, $parts, $tradspell, $unconverted_dict_ref, $converted_dict_ref,
# $case_redirect_ref, $mapref, $maxkeylen: Handle a compound or derived form.
# Returns the spelling to use for the compound if the word is one; returns undef otherwise.
sub handle_compound {
    my ($colref, $parts, $tradspell, $unconverted_dict_ref, $converted_dict_ref,
        $case_redirect_ref, $mapref, $maxkeylen)
        = @_;

    if ($parts =~ /-/) {
        # It's a compound made of two parts
        my ($first, $second) = split /-/, $parts;
        my $first_conv_colref = lookup_part_entry $first, $tradspell, $unconverted_dict_ref,
            $converted_dict_ref, $case_redirect_ref, $mapref, $maxkeylen;
        my $second_conv_colref = lookup_part_entry $second, $tradspell, $unconverted_dict_ref,
            $converted_dict_ref, $case_redirect_ref, $mapref, $maxkeylen;
        my $first_lytspel  = $first_conv_colref->[3];
        my $second_lytspel = $second_conv_colref->[3];
        my $compound       = "$first_lytspel$second_lytspel";

        # If the compound contains two stress markers, we keep just the second one
        $compound =~ s/'// if $compound =~ /'.*'/;

        # If the compound contains a stress markers, we retain it (unless the second part is
        # «a'bout» ‹about›, e.g. «roundabout») and are done (unless the first part is
        # «i'lectro» ‹electro› -- then we'll check below which part carries the main stress)
        if ($compound =~ /'/) {
            $compound =~ s/'// if $second eq 'about';
            return $compound unless $first eq 'electro';
        }

        # Insert stress marker before second part if appropriate
        $compound = "$first_lytspel'$second_lytspel"
            if exists($STRESS_AFTER{$first}) || exists($STRESS_IF_SECOND{$second});

        if (exists($STRESS_VARIES_IF_FIRST{$first})) {
            # Check pronunciation to find out which part to stress
            my $pron = $colref->[5] || $colref->[3];  # prefer PhonEng, use RP as fallback

            # In ‹electro...› combinations, we discard the first sound (vowel), since it's
            # never stressed
            $pron = substr($pron, 1) if $first eq 'electro';

            if ($pron =~ /[$SAMPA_VOWELS].*'/) {
                # If a vowel occurs before the stress marker, we assume that the 2nd part is
                # stressed (in case of ‹electro...› combinations, it may already contain a
                # stress marker)
                $first_lytspel =~ s/'//;  # convert «i'lectro» to «ilectro»
                $compound = "$first_lytspel'$second_lytspel" unless $second_lytspel =~ /'/;
            }
        }

        say "$tradspell should become $compound";

     # TODO x
     # Stress 2nd part: aeromedical, tetrabranchiate
     # Start of 2nd part might be stressed: ultramodern, transpire, hypozeuxis
     # Exceptions where 1st is stressed: therefore, ultrastructure, wherefore, archlute, archway,
     # -sphere combis (e.g. biosphere, chemosphere), hereabout, heterophil, heterodyne, heterograft,
     # hypoblast, hypogene, hyponasty, hypostyle, infrasound, infrastructure
     # Check whether it's really a compound: mawkin, acockbill, agravic, arcana, arcane.
     # Not a compound: affair (and other aff- combinations), appall (and other app-
     # combinations), ashake (and some other ash- combinations), aspasia (and other asp-
     # combiantions?), assail and some other ass- combis, combis with bam- and probably ban-,
     # barbaric and some other bar- combis, some car-/man- combis, -sis- combis, most or all cor-
     # combis, most or all cur-/imp- combis, all dip-/-ure/fib-/-for-/-ill-/ind-/-ara/ken-/kris-/
     # -faction/-lac-/-lieu-/-mac-/-mari-/-mel-/mor-/-ola-/-nag-/-ana-/-ord-/-ova-/-ira-/-ita-/
     # -nola-/-anna-/-odic-/-axis-/-rosa-/-mento-/-stamin-/-syn-/-tai-/-tor-/-tran-/-ila-/-edo-/
     # -ante/-vin-/-with-/-zoom-/-rate/-ron-/-lojic-/-con-/-dos-/-bally- combis (except birthrate),
     # various meta- combis (check those where it matters, e.g. because they have a stress
     # marker)
     # Not a compound: pantalone, canakin, electrode, tetrode, archenteron, archenteric,
     # autogamy, autolysis, autotrophy, carbohydrate, cryptogam
    } else {
        # TODO Implement
        # Make -tic a suffix instead of a regular compound part (e.g. aromatic),
        # likewise -ary (e.g. visionary), -ology (e.g. planetology), -arian (e.g. parliamentarian),
        # make a suffix: tele-
        # Stress before final consonant(s) of first part (probably treat as suffix): -otic,
        # e.g. «aci'dotic» ‹acidotic›
        # Make ‹zoo› a prefix written «zoe» /zoU@/; first or second part may be stressed.
    }

# TODO When looking up words, consider that they might be POS-tagged (v, n, av, prp)
# Then handle prefixed ('=' with known prefix) and suffixed entries.
# TODO Handle prefixes and suffixes correctly («dis, mis; anti, semi» are spelled like that
# regardless of which letter follows; prefixes «baio, nio» ‹bio, neo›;
# suffix «ful» is preserved; «-est» remains as is (never "ast"))
# Test that is also works if the case of the original word is different.
# Correct and use the result for each prefix/suffixes; also handle and
# document schwa/single-letter short changes such as «hexagen» ‹hexagon› due to «he'xagenel»
# ‹hexagonal›; deal with «nationel» ‹national› from «naition» ‹nation› as a special case
# (the derived form is irregular).
# Ensure that «obzur'vaition» ‹observation› is converted correctly (from «ob'zurv» ‹observe›)
# Ensure that the «tion» and «sion» spellings aren't used in words derived by appending «n» or
# «en», e.g. «ashen, freshen, Rushan, Purzhan»
# TODO Add -ance, -ence as suffixes
# TODO Add 'bi' as prefix, otherwise add manual entries:
# biconcave,bi-concave
# biconcavity,bi-concavity
# Add 'on' as prefix, e.g. ‹oncoming› should be analysed as ‹on=coming›

    return undef;  # not a compound
}

# convert_dict: Convert SAMPA spellings to Lytspel.
sub convert_dict {
    my ($mapref, $maxkeylen) = build_mapping;
    my $compound_map_ref = build_compound_map;
    my ($unconverted_dict_ref, $case_redirect_ref) = build_unconverted_dict_and_case_redirects;
    my %converted_dict;
    my $outfh = open_outfile_and_write_header $OUT_FILE, [qw(Traditional POS Redirect Lytspel)];

    for my $key (sort { lc $a cmp lc $b } keys %$unconverted_dict_ref) {
        my $colref = $unconverted_dict_ref->{$key};

        if (scalar @$colref < 4) {
            # Nothing to convert, just output and store line as is
            $CSV_OUT->print($outfh, $colref);
            $converted_dict{$key} = $colref;
            next;
        }

        my $conv_colref = $converted_dict{$key};
        if ($conv_colref) {
            # Word has already been converted
            $CSV_OUT->print($outfh, $conv_colref);
            next;
        }

        my $tradspell = $colref->[0];
        my $parts     = $compound_map_ref->{lc $tradspell};
        my $compound  = handle_compound $colref, $parts, $tradspell, $unconverted_dict_ref,
            \%converted_dict, $case_redirect_ref, $mapref, $maxkeylen
            if $parts;

        if ($compound) {
            # TODO x Integrate with code below: use return value instead of calling convert_column
            say "Compound found: $tradspell should become $compound";
        }

        $conv_colref = convert_column $colref, $tradspell, $mapref, $maxkeylen;
        $converted_dict{$key} = $conv_colref;
        $CSV_OUT->print($outfh, $conv_colref);

        # TODO Finally drop POS tag if all variants are written the same, e.g. «mouth»
        # TODO Handle most frequent pre- and suffixes in converter rather than dict
        # (also creating a compact version of the dict where they are dropped, after
        # making sure that the converter will indeed lead to the same results)
    }

    my $avg_dist = $SUMMED_DIST / $WORD_COUNT;
    say "Average distance between tradspell and Lytspel: $avg_dist";

    close $outfh;
}

# Main block
convert_dict;
