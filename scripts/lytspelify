#!/usr/bin/perl -CA
# Convert phonetic SAMPA spellings into Lytspel.
#
# Copyright (c) 2016 Christian Siefkes
# See accompanying LICENSE file for licensing information.
#
# Required modules: Const::Fast, Text::LevenshteinXS, and those listed in PhonEng.pm.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Const::Fast;
use Cwd 'abs_path';
use File::Basename 'dirname';
use List::Util qw(min max);
use Text::LevenshteinXS 'distance';

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

const my $IN_FILE          => 'phonetic-dict.csv';
const my $OUT_FILE         => 'lytspel-dict.csv';
const my $PHONEME_MAP      => 'phoneme-map.csv';

# Vowel letters in SAMPA and Lytspel
const my $SAMPA_VOWELS      => '@:#3aAeEiIoOQuUV';
const my $LYTSPEL_VOWELS    => '[aeiouY]';
# Consonant letters
const my $SAMPA_CONSONANTS  => '`bdDfghjklmnNprsStTvwzZ';
# Pattern fragment matching an optional stress marker
const my $OPT_STRESS_MARKER => "(?:=')?";

my $CSV_IN  = new_csv_in;
my $CSV_OUT = new_csv_out;

# build_mapping: Create and return a mapping from SAMPA to the standard Lytspel spellings.
# Also return the length of the longest key in the map.
sub build_mapping {
    my %dict;
    my $maxkeylen = 0;
    open my $fh, '<', $PHONEME_MAP or die "Unable to open $PHONEME_MAP: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $sampa   = $colref->[0];
        my $lytspel = $colref->[4];

        # Skip if SAMPA or Lytspel entry is missing or if SAMPA is '-'
        next unless valid_key($sampa) && $lytspel;

        $maxkeylen = max $maxkeylen, length($lytspel);
        $dict{$sampa} = $lytspel;

        # Add stressed variant if phoneme is a consonant followed by a vowel
        if ($sampa =~ /^[$SAMPA_CONSONANTS][$SAMPA_VOWELS]/) {
            my $stressed_key = substr($sampa, 0, 1) . "'" . substr($sampa, 1);
            my $stressed_val = "'$lytspel";
            $maxkeylen = max $maxkeylen, length($stressed_val);
            $dict{$stressed_key} = $stressed_val;
        }
    }

    close $fh;
    return \%dict, $maxkeylen;
}

# open_outfile_and_write_header: Open output file in CSV format and write the header line.
# Returns the opened file handle. Also backups an old version of the file, if any.
sub open_outfile_and_write_header {
    rename_to_backup_file_if_exists $OUT_FILE;
    open my $outfh, '>', $OUT_FILE or die "Unable to open $OUT_FILE for writing: $!\n";
    $CSV_OUT->print($outfh, [qw(Traditional POS RedirectLytspel)]);
    return $outfh;
}

# prepare_pron $pron: Fix the pronunication of a word by normalizing non-standard forms.
sub prepare_pron {
    my $pron = shift;
    # Normalize alternative forms of the r-colored schwa
    $pron =~ s/(?<![ei])\@r|\@`r|a#r/\@`/g;
    return $pron;
}

# delsep $str: Delete any occurrences of '=' (used as separator) from a string.
sub delsep {
    my $str = shift;
    $str =~ s/=//g;
    return $str;
}

# dist $str1, $str2: Calculate the Levenshtein edit distance between two strings, ignoring case.
# Separators are deleted from both strings before doing the conversion:
sub dist {
    my ($str1, $str2) = @_;
    return distance(lc(delsep $str1), lc(delsep $str2));
}

# e_or_u_or_other $other, $left, $right, $tradspell: Return 'e', 'u', or $other depending on which
# is most similar to $tradspell. In case of a tie, 'e' is preferred over 'u' and $other is
# preferred over both. $other is ignored if it's is undefined or empty.
sub e_or_u_or_other {
    my ($other, $left, $right, $tradspell) = @_;
    my $result = dist($tradspell, "${left}e$right") <= dist($tradspell, "${left}u$right")
                 ? 'e' : 'u';

    if ($other) {
        $result = dist($tradspell, "$left$other$right")
                  <= dist($tradspell, "$left$result$right")
                  ? $other : $result;
    }

    return $result;
}

# any_short_vowel $left, $right, $tradspell: Return any of the five vowel letters depending on
# which is most similar to $tradspell. Ties are resolved by preferring the left-most match from
# the following list: e, u, a, o, i. ('e' and 'u' are generally preferred because their sound
# is close to a schwa sound, the other vowel letters are ranked by how often they represent a
# schwa in tradspel.)
sub any_short_vowel {
    my ($left, $right, $tradspell) = @_;
    my $chosen = '';
    my $olddist = 1000;

    for my $vowel (qw/e u a o i/) {
        my $newdist = dist($tradspell, "$left$vowel$right");

        if ($newdist < $olddist) {
            $chosen = $vowel;
            $olddist = $newdist;
        }
    }

    return $chosen;
}

# combine $left, $right: Combine two strings into one.
# Except when $left ends with a stress marker ("'") or $right is empty, the strings are separated
# by '='.
sub combine {
    my ($left, $right) = @_;
    return $left =~ /'$/ || $right eq '' ? "$left$right" : "$left=$right";
}

# combine_and_adjust $val, $left, $right, $tradspell: Combine $left and $val into a joined
# string, applying context-specific rules to the resulting spelling as suitable.
sub combine_and_adjust {
    my ($val, $left, $right, $tradspell) = @_;

    if ($right eq '') {
        # End of word spellings

        if ($val eq '@' || $val eq 'a#') {
            # Final schwa becomes «er» if tradspell ends in ‹r› (typical for non-rhotic RP),
            # otherwise «a»
            $val = $tradspell =~ /r$/ ? 'er' : 'a';
        } elsif ($val eq 'k' && $left =~ /[^'aeou]i$/) {
            # «c» is used at the end of words ending in unstressed /Ik/
            $val = 'c';
        } elsif ($left !~ /([fkpt]|th)$/) {
            # Final /s/ becomes «ss» and /z/ becomes «s» except after /f, k, p, t, T/
            if ($val eq 's') {
                $val = 'ss';
            } elsif ($val eq 'z') {
                $val = 's';
            }
        }
    }

    if ($val eq '@' && $right eq 'l' && $left =~ /[bpdtfgksz]($OPT_STRESS_MARKER)$/) {
        # TODO $OPT_STRESS_MARKER can be omitted?
        # Schwa is omitted between any of /b, p, d, t, f, g, k/ and final /l/
        $val = '';

        # Final /s@l/ is written «ssl» and final /z@l/ is written «sl»
        if ($left =~ /s$/) {
            $left .= 's';
        } elsif ($left =~ /z$/) {
            chop $left;
            $left .= 's';
        }

    } elsif ($val eq '@' && $right eq 'm' && $left =~ /z$/) {
        # Final /z@m/ is written «sm»
        $val = '';
        chop $left;
        $left .= 's';
    } elsif ($val =~ /^(@|a#|I#)$/ && $right =~ /^[$SAMPA_CONSONANTS]*'/) {
        # Any schwa followed by a stressed vowel can become «e/u/a/o/i» (in preference order)
        $val = any_short_vowel $left, $right, $tradspell;
    } elsif ($val eq '@') {
        # /@/ becomes «e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('', $left, $right, $tradspell);
    } elsif ($val eq 'a#') {
        # /a#/ becomes «a/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('a', $left, $right, $tradspell);
    } elsif ($val eq 'I#') {
        # /I#/ becomes «i/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('i', $left, $right, $tradspell);
    } elsif ($val eq 'r' && $left =~ /r$/) {
        # Eliminate double «r»
        $val = '';
    }

    if ($val =~ /^[aou]/) {
        # /s/ becomes «ss» between any vowel and a vowel starting with «a, o, u»
        $left =~ s/($LYTSPEL_VOWELS=)s($OPT_STRESS_MARKER)$/$1ss$2/;
    } elsif ($val =~ /^[eiY]/) {
        # /s/ becomes «c» between any vowel and a vowel starting with «e, i, y»
        $left =~ s/($LYTSPEL_VOWELS=)s($OPT_STRESS_MARKER)$/$1c$2/;
    }

    if ($val !~ /^['eiY]/) {
        # Non-final /k/ becomes «c» unless followed by a vowel starting with «e, i, y»
        $left =~ s/k($OPT_STRESS_MARKER)$/c$1/;
    }

    if ($val =~ /^$LYTSPEL_VOWELS/) {
        # /z/ becomes «s» between two vowels
        $left =~ s/($LYTSPEL_VOWELS=)z($OPT_STRESS_MARKER)$/$1s$2/;

    }

    # TODO Implement rules from README from l.215: schwa is also omitted between /D/ and final /m/
    # TODO When handling «x» /ks/, make sure that the schwa in /ks@l/ is not omitted,
    # e.g. «axel, pixel» ‹axle...›
    # TODO Handle prefixes and suffixes correctly («dis, mis» are spelled like that regardless
    # of which letter follows; suffix «ful» is preserved)
    # TODO Generally use «ue» in cases were RP has /j'u:/ and GA has /u:/, e.g. ‹new›
    # (PhonEng may have either)
    # TODO Generally use «eer» in cases were RP has /i:@/ and GA has /Ir/, e.g. ‹year, peculiar›
    # (ignoring PhonEng?)
    return combine($left, $val);
}

# restore_capitalization $converted, $tradspell: Restore the proper capitalization of a converted
# word. Also deletes separators ('=').
sub restore_capitalization {
    my ($converted, $tradspell) = @_;
     # Delete separators ('=') and lower-case capital letters (vowel «Y» as distinguished from
     # consonant «y»)
    $converted = lc(delsep $converted);
    if ($tradspell =~ /^[A-Z][a-z']*$/) {  # Capitalized
        $converted = ucfirst $converted;
    }
    # TODO Later fully restore capitalization to match tradspell:
    # Mc|MacCapitalized becomes McCapitalized, e.g. «McAdem, McDowel» ‹McAdam, McDowell›;
    # a repeated /k/ sound is preserved, e.g. «McCoy, McKinli» ‹...McKinley›
    # The stress marker is omitted since the second (capitalized) syllable is always stressed
    # (except McEnroe, McIntosh, McIntyre, McNamara where the first syllable is stressed --
    # probably rewrite those without capital letter e.g. as «Makintosh»; ‹Macintosh› is already
    # in the dict)
    # Preserve D?Capitalized by capitalizing the first two vowels, e.g. «DiCaprio, DuuPont»
    # ‹...DuPont›; the stress marker is omitted since the second syllable is always stressed
    # Preserve O'Capitalized, e.g. «O'Braien» ‹O'Brien›; the capitalized O is spoken /oU/
    # N'Djamena and IJssel become simple capitalized words
    # Other Cap'Capitalized words are dropped as foreign names, e.g. ‹L'Oreal›
    # ALL CAPS and other forms are considered proper names or abbreviations are also dropped
    # lowercase (including apostrophes)
    ##if ($tradspell =~ /^[a-z']+$/) {  # lowercase (including apostrophes)
    return $converted;
}

# convert_pron $pron, $mapref, $maxkeylen, $tradspell: Convert a pronunciation using a given
# mapping alphabet (dictionary reference).
# $maxkeylen is the maximumg length of keys that may occur in $mapref.
sub convert_pron {
    my ($pron, $mapref, $maxkeylen, $tradspell) = @_;
    $pron = prepare_pron $pron;
    return '' unless $pron;  # Empty input

    my $unconverted = $pron;
    my $converted   = '';

OUTER: while ($unconverted) {
        my $charcount = min $maxkeylen, length $unconverted;

    INNER: while ($charcount) {
            my $start = substr $unconverted, 0, $charcount;
            my $rest  = substr $unconverted, $charcount;
            my $val   = $mapref->{$start};

            if (defined $val) {  # Match found
                $converted = combine_and_adjust $val, $converted, $rest, $tradspell;
                $unconverted = $rest;
                next OUTER;
            }

            $charcount--;
        }

        die "No match found for converting /$pron/, unconverted part: /$unconverted/\n";
    }

    $converted = restore_capitalization $converted, $tradspell;
    return $converted;
}

# choose_nearer_or_shorter $first, $second, $tradspell: Choose and return $first or $second
# depending on which one is more similar to $tradspell.
# If both are equally similar, the shorter one is returned
# If there is still a tie, $first is returned.
# If $second is undefined or empty, $first is returned without further checks.
sub choose_nearer_or_shorter {
    my ($first, $second, $tradspell) = @_;
    return $first unless $second;

    my $comp = dist($first, $tradspell) <=> dist($second, $tradspell);
    $comp = length($first) <=> length($second) unless $comp;
    # TODO Words ending in «r» should be preferred if tradspell ends in ‹r› or ‹re»,
    # e.g. ‹creature› should become «creecher», not "creecha"
    # TODO Find out how to disambiguate these cases
    #warn "$first and $second have equal distance to $tradspell and equal length\n" unless $comp;

    return ($comp <= 0) ? $first : $second;
}

# select_nearest_and_calc_distance: Select among the three converted spellings the one that's
# closest to $tradspell and return it. Also returns the edit distance between the selected
# spelling and $tradspell as a second value.
# $converted_ga and $converted_phoneng may be empty.
sub select_nearest_and_calc_distance {
    my ($converted_rp, $converted_ga, $converted_phoneng, $tradspell) = @_;
    my $choosen = choose_nearer_or_shorter $converted_rp, $converted_ga, $tradspell;
    $choosen = choose_nearer_or_shorter $choosen, $converted_phoneng, $tradspell;
    my $dist = dist $choosen, $tradspell;

    # TODO For now, we just prefix the choosen value with a '*'
    if ($choosen eq $converted_rp) {
        # Omit '*' if it's the only value
        $converted_rp = "*$converted_rp" if $converted_ga || $converted_phoneng;
    } elsif ($choosen eq $converted_ga) {
        $converted_ga = "*$converted_ga";
    } else {
        $converted_phoneng = "*$converted_phoneng";
    }

    return $converted_rp, $converted_ga, $converted_phoneng, $dist;
}

# convert_dict: Convert SAMPA spellings to Lytspel.
sub convert_dict {
    my ($mapref, $maxkeylen) = build_mapping;
    open my $infh, '<', $IN_FILE or die "Unable to open $IN_FILE: $!\n";
    my $colref = $CSV_IN->getline($infh);       # Skip header line
    my $outfh  = open_outfile_and_write_header;
    my $summed_dist = 0;
    my $wordcount = 0;

    while ($colref = $CSV_IN->getline($infh)) {
        if (scalar @$colref < 4) {
            # Nothing to convert, just output line as is
            $CSV_OUT->print($outfh, $colref);
            next;
        }

        my $tradspell         = $colref->[0];
        my $converted_rp      = convert_pron $colref->[3], $mapref, $maxkeylen, $tradspell;
        my $converted_ga      = convert_pron $colref->[4], $mapref, $maxkeylen, $tradspell;
        my $converted_phoneng = convert_pron $colref->[5], $mapref, $maxkeylen, $tradspell;

        # Omit GA if identical to RP
        $converted_ga = '' if $converted_ga eq $converted_rp;
        # Omit PhonEng if identical to RP or GA
        $converted_phoneng = ''
            if $converted_phoneng eq $converted_rp || $converted_phoneng eq $converted_ga;

        # TODO Finally keep only the spelling that's closest to tradspell.
        my $dist;
        ($converted_rp, $converted_ga, $converted_phoneng, $dist) = select_nearest_and_calc_distance
                $converted_rp, $converted_ga, $converted_phoneng, $tradspell;
        $summed_dist += $dist;
        $wordcount++;

        # TODO Move stress marker before stressed syllable, omitting if the first vowel is the
        # stressed one («ss» is separated by the marker: as'sault, as'sumption)
        $CSV_OUT->print($outfh,
            [@$colref[0 .. 2], $converted_rp, $converted_ga, $converted_phoneng]);

        # TODO Finally drop POS tag if all variants are written the same, e.g. «mouth»
    }

    my $avg_dist = $summed_dist / $wordcount;
    say "Average distance between tradspell and Lytspel: $avg_dist";

    close $infh;
    close $outfh;
}

# Main block
convert_dict;
