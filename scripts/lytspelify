#!/usr/bin/perl -CA
# Convert phonetic SAMPA spellings into Lytspel.
#
# Copyright (c) 2016-17 Christian Siefkes
# See accompanying LICENSE.txt file for licensing information.
#
# Required modules: Const::Fast, Text::Hyphen, Text::LevenshteinXS, and those listed in PhonEng.pm.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Const::Fast;
use Cwd 'abs_path';
use File::Basename 'dirname';
use List::Util qw(min max);
use Text::Hyphen;
use Text::LevenshteinXS 'distance';

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

const my $IN_FILE     => 'phonetic-dict.csv';
const my $OUT_FILE    => 'lytspel-dict.csv';
const my $COMPOUNDS   => 'compounds.csv';
const my $CUSTOM      => 'custom.csv';
const my $PHONEME_MAP => 'phoneme-map.csv';

# Vowel letters in SAMPA and Lytspel
const my $SAMPA_VOWELS   => '@:#3aAeEiIoOQuUV';
const my $LYTSPEL_VOWELS => 'aeiouY';
# Class of consonant letters, with /j/ always a consonant
const my $SAMPA_SIMPLE_CONSONANT_CLS => "[`bdDfghklmnNprsStTvwzZj]";
# Class of consonant letters, with /j/ only considered a consonant if it's not followed
# by /u:/ or /Ur/ («iu, iur» spellings)
const my $SAMPA_CONSONANT_CLS => "(?:[`bdDfghklmnNprsStTvwzZ]|j(?!'?(?:u:|Ur)))";
# Pattern fragment matching an optional stress marker
const my $OPT_STRESS_MARKER => "(?:=')?";
# Pattern fragment matching a Lytspel consonant
const my $LYTSPEL_CONSONANT => "(?:(?:[bcdfghjklmnprstvwxyz]h?|nn?g|qu)=?)";

# Stress the second part of a compound if the first part is listed here
my %STRESS_AFTER = map { $_ => 1 } qw/arch best chemo con crypt crypto dynamo ego ere
    extra fibro helio here hetero hydro hypo infra mon nitro peri psycho pyro supra thence
    there thio ultra where/;

# Stress the second part of a compound if listed here
my %STRESS_IF_SECOND = map { $_ => 1 } qw/air angular basic centric east eastward eastwards ever
    genesis genic graphic logic metric optic phobia phobic self selves therapy tropic west
    westward westwards/;

# If the first part of a compound is listed here, either part may be stressed (we check
# the pronunciation to find out).
my %STRESS_VARIES_IF_FIRST = map { $_ => 1 } qw/auto contra electro meta mono para photo
    poly pro radio retro/;

# If a compound is listed here, its 1st part is stressed (used only in cases where our
# rules indicate that the 2nd part should be stressed).
my %STRESS_FIRST_PART = map { $_ => 1 } qw/aftereffect aftersensation archlute archway
    heterodyne heterograft heterophil hypoblast hypogene hyponasty hypostyle infrasound
    infrastructure therefore ultrastructure wherefore/;

# If a compound is listed here, its 2nd part is stressed.
my %STRESS_SECOND_PART = map { $_ => 1 } qw/absentminded acetylcholine aeromedical aerostation
    Alamein Allhallowmas Allhallows altocumulus antarctic anteprandial anteversion anymore
    arsenopyrite Australasia tetrabranchiate/;

# TODO Switch to Upper_Camel_Case for file-scoped variables (in all files)
my $CSV_IN  = new_csv_in;
my $CSV_OUT = new_csv_out;
my $HYPH    = new Text::Hyphen min_word => 3, min_prefix => 1, min_suffix => 1;

# The following variables are globals for simplicity
my $SUMMED_DIST       = 0;
my $WORD_COUNT        = 0;
my $COMPOUND_DICT_REF = build_lc_map($COMPOUNDS);
my $CUSTOM_DICT_REF   = build_lc_map($CUSTOM);
my $UNCONVERTED_DICT_REF;
my $CONVERTED_DICT_REF;
my $CASE_REDIRECT_REF;

# Set to which all processed custom entries are added.
my %PROCESSED_CUSTOM_SET;

# Mapping from prefixes to their Lytspel spellings and stress hints (1: stress prefix;
# 2: stress main word; 'A': let PhonEng determine stress). Values are two-element
# array references.
my %PREFIXES;

# Mapping from suffixes to their Lytspel spellings.
my %SUFFIXES;

# build_lc_map $filename: Create and return a mapping from a simple CSV file containing
# two columns (keys and values). All keys are converted to lower-case, while values are
# used as is. Warns if there are duplicate keys.
sub build_lc_map {
    my ($filename) = @_;
    my %dict;
    open my $fh, '<', $filename or die "Unable to open $filename: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $key = lc($colref->[0]);
        warn "Duplicate key '$key' in $filename\n" if exists($dict{$key});
        $dict{$key} = $colref->[1];
    }

    close $fh;
    return \%dict;
}

# build_mapping: Create and return a mapping from SAMPA to the standard Lytspel spellings.
# Also return the length of the longest key in the map.
sub build_mapping {
    my %dict;
    my $maxkeylen = 0;
    open my $fh, '<', $PHONEME_MAP or die "Unable to open $PHONEME_MAP: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        my $sampa   = $colref->[0];
        my $lytspel = $colref->[4];

        # Skip if SAMPA or Lytspel entry is missing or if SAMPA is '-'
        next unless valid_key($sampa) && $lytspel;

        $maxkeylen = max $maxkeylen, length($lytspel);
        $dict{$sampa} = $lytspel;

        # Add stressed variant if phoneme is a consonant followed by a vowel
        if ($sampa =~ /^${SAMPA_SIMPLE_CONSONANT_CLS}[$SAMPA_VOWELS]/) {
            my $stressed_key = substr($sampa, 0, 1) . "'" . substr($sampa, 1);
            my $stressed_val = "'$lytspel";
            $maxkeylen = max $maxkeylen, length($stressed_val);
            $dict{$stressed_key} = $stressed_val;
        }
    }

    close $fh;
    return \%dict, $maxkeylen;
}

# gen_key $word, $pos: Combine a word and a optional POS tag into a joint key.
# If $pos is undefined or empty, $word alone is returned, otherwise "$word/$pos" is returned.
sub gen_key {
    my ($word, $pos) = @_;
    return $pos ? "$word/$pos" : $word;
}

# build_unconverted_dict_and_case_redirects: Returns references to two hashes:
# 1. From keys (see 'gen_key' function) to the complete $IN_FILE entries describing them
# 2. From lower-cased forms of words containing capital letters to their cased form
#    (e.g. 'europe' -> 'Europe')
sub build_unconverted_dict_and_case_redirects {
    open my $infh, '<', $IN_FILE or die "Unable to open $IN_FILE: $!\n";
    my $colref = $CSV_IN->getline($infh);  # Skip header line
    my %unconverted_dict;
    my %case_redirect;

    while ($colref = $CSV_IN->getline($infh)) {
        my $word = $colref->[0];
        my $pos  = $colref->[1];
        my $key  = gen_key $word, $pos;
        $unconverted_dict{$key} = $colref;
        $case_redirect{lc $word} = $word if $word =~ /[A-Z]/;
    }

    close $infh;
    return \%unconverted_dict, \%case_redirect;
}

# delsep $str: Delete any occurrences of '=' (used as separator) from a string.
sub delsep {
    my $str = shift;
    $str =~ s/=//g;
    return $str;
}

# dist $str1, $str2: Calculate the Levenshtein edit distance between two strings, ignoring case.
# Separators are deleted from both strings before doing the conversion:
sub dist {
    my ($str1, $str2) = @_;
    return distance(lc(delsep $str1), lc(delsep $str2));
}

# e_or_u_or_other $other, $left, $right, $tradspell: Return 'e', 'u', or $other depending on which
# is most similar to $tradspell. In case of a tie, 'e' is preferred over 'u' and $other is
# preferred over both. $other is ignored if it's is undefined or empty.
sub e_or_u_or_other {
    my ($other, $left, $right, $tradspell) = @_;

    # Schwa before vowels is always spelled «e»
    return 'e' if $right && $right !~ /^$SAMPA_CONSONANT_CLS/;

    my $result =
        dist($tradspell, "${left}e$right") <= dist($tradspell, "${left}u$right") ? 'e' : 'u';

    if ($other) {
        $result =
            dist($tradspell, "$left$other$right") <= dist($tradspell, "$left$result$right")
            ? $other
            : $result;
    }

    return $result;
}

# any_short_vowel $left, $right, $tradspell: Return any of the five vowel letters depending on
# which is most similar to $tradspell. Ties are resolved by preferring the left-most match from
# the following list: e, u, a, o, i. ('e' and 'u' are generally preferred because their sound
# is close to a schwa sound, the other vowel letters are ranked by how often they represent a
# schwa in tradspel.)
sub any_short_vowel {
    my ($left, $right, $tradspell) = @_;
    my $chosen  = '';
    my $olddist = 1000;

    for my $vowel (qw/e u a o i/) {
        my $newdist = dist($tradspell, "$left$vowel$right");

        if ($newdist < $olddist) {
            $chosen  = $vowel;
            $olddist = $newdist;
        }
    }

    return $chosen;
}

# combine $left, $right: Combine two strings into one.
# Except when $left ends with a stress marker ("'") or either string is empty, the strings are
# separated by '='.
sub combine {
    my ($left, $right) = @_;
    return $left =~ /'$/ || !$right || !$left ? "$left$right" : "$left=$right";
}

# combine_and_adjust $val, $left, $right, $tradspell: Combine $left and $val into a joined
# string, applying context-specific rules to the resulting spelling as suitable.
sub combine_and_adjust {
    my ($val, $left, $right, $tradspell) = @_;

    if ($right eq '') {
        # End of word spellings

        if ($val eq '@' || $val eq 'a#') {
            # Final schwa becomes «er» if tradspell ends in ‹r› (typical for non-rhotic RP),
            # otherwise «a»
            $val = $tradspell =~ /r$/ ? 'er' : 'a';
        } elsif ($val eq 'e') {
            # Final «e» /E/ becomes «eh»
            $val = 'eh';
        } elsif ($val eq 'u') {
            # Final /V/ is spelled «uh»
            $val = 'uh';
        } elsif ($val eq 'er' && $left =~ /Y$/) {
            # Final /aI@`/ is written «yr», e.g. «fyr, in'spyr» ‹fire, inspire›
            $val = 'r';
        } elsif ($val eq 'k' && $left =~ /(?<!['aeou])i$/) {
            # «c» is used at the end of words ending in unstressed /Ik/
            $val = 'c';
        } elsif ($val eq 'l' && $left =~ /au$/) {
            # Final /O:l/ is written «all», e.g. «ball»
            $left =~ s/au$/al/;
        } elsif ($left !~ /([fkpt]|th)$/) {
            # Final /s/ becomes «ss» and /z/ becomes «s» except after /f, k, p, t, T/
            if ($val eq 's') {
                $val = 'ss';
            } elsif ($val eq 'z') {
                $val = 's';
            }
        }
    }

    if ($val eq '@' && $right eq 'l' && $left =~ /[bpdtfgksz]$/) {
        # TODO Add 'c'?
        # Schwa is omitted between any of /b, p, d, t, f, g, k/ and final /l/
        $val = '';

        # Final /s@l/ is written «ssl» and final /z@l/ is written «sl»
        if ($left =~ /s$/) {
            $left .= 's';
        } elsif ($left =~ /z$/) {
            chop $left;
            $left .= 's';
        }

    } elsif ($val eq '@' && $right eq 'm' && $left =~ /z$/) {
        # Final /z@m/ is written «sm»
        $val = '';
        chop $left;
        $left .= 's';
    } elsif ($val eq '@' && $right eq 'm' && $left =~ /dh$/) {
        # Schwa is also omitted between /D/ and final /m/
        $val = '';
    } elsif ($val eq '@' && $right eq 'n' && $left =~ /[sz]h$/) {
        # Final /S@n/ becomes «tion» and /Z@n/ becomes «sion»
        $val = 'o';
        $left =~ s/sh$/ti/;
        $left =~ s/zh$/si/;
    } elsif ($val =~ /^(@|a#|I#)$/ && $right =~ /^$SAMPA_SIMPLE_CONSONANT_CLS*'/) {
        # Any schwa followed by a stressed vowel can become «e/u/a/o/i» (in preference order)
        $val = any_short_vowel $left, $right, $tradspell;
    } elsif ($val eq '@') {
        # /@/ becomes «e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('', $left, $right, $tradspell);
    } elsif ($val eq 'a#') {
        # /a#/ becomes «a/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('a', $left, $right, $tradspell);
    } elsif ($val eq 'I#') {
        # /I#/ becomes «i/e/u» depending on what's more similar to tradspell (in preference order)
        $val = e_or_u_or_other('i', $left, $right, $tradspell);
    } elsif ($val eq 'ai' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «ai» /eI/ becomes «ay» at the end of words and before other vowels
        $val = 'ay';
    } elsif ($val eq 'au' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «au» /O:/ becomes «aw» at the end of words and before other vowels
        $val = 'aw';
    } elsif ($val eq 'ee' && $right !~ /^$SAMPA_CONSONANT_CLS/ && $left !~ /'$/) {
        # Unstressed «ee» /i:/ becomes «i» at the end of words and before other vowels
        $val = 'i';
    } elsif ($val eq 'oa' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «oa» /oU/ becomes «o» at the end of words and before other vowels
        $val = 'o';
    } elsif ($val eq 'Y' && $right && $right !~ /^($SAMPA_CONSONANT_CLS|@`$)/) {
        # «y» /aI/ becomes «ai» before other vowels
        # (except before final /@`/ -- that combination becomes «yr»)
        $val = 'ai';
    } elsif ($val eq 'oi' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «oi» /OI/ becomes «oy» at the end of words and before other vowels
        $val = 'oy';
    } elsif ($val eq 'ou' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «ou» /aU/ becomes «ow» at the end of words and before other vowels
        $val = 'ow';
    } elsif ($val eq 'uu' && $right !~ /^$SAMPA_CONSONANT_CLS/) {
        # «uu» /u:/ becomes «u» at the end of words and before other vowels
        $val = 'u';
    } elsif ($val =~ /^ng?$/ && $right =~ /^k/ && $left !~ /^('?[eiu]|[cn]='?o)$/) {
        # Before /k/, «n» is pronounced /N/ rather then /n/, unless the word starts with
        # «con, en, in, non, un»; /n/ becomes «nn» in this position
        $val = $val eq 'n' ? 'nn' : 'n';
    } elsif ($val eq 'r' && $left =~ /r$/) {
        # Eliminate double «r»
        $val = '';
    }

    if ($val =~ /^[aou]/) {
        # /s/ becomes «ss» between any vowel and a vowel starting with «a, o, u»
        $left =~ s/([$LYTSPEL_VOWELS]=)s($OPT_STRESS_MARKER)$/$1ss$2/;
    } elsif ($val =~ /^[eiY]/) {
        # /s/ becomes «c» between any vowel and a vowel starting with «e, i, y»
        $left =~ s/([$LYTSPEL_VOWELS]=)s($OPT_STRESS_MARKER)$/$1c$2/;
    }

    if ($val !~ /^['eiYy]/) {
        # Non-final /k/ becomes «c» unless followed by any of «e, i, y»
        $left =~ s/k($OPT_STRESS_MARKER)$/c$1/;
    }

    if ($val =~ /^[$LYTSPEL_VOWELS]/) {
        # /z/ becomes «s» between two vowels
        $left =~ s/([$LYTSPEL_VOWELS]=)z($OPT_STRESS_MARKER)$/$1s$2/;

    }

    # TODO Integrate list of irregular words: «hi, shi, wi, mi» ‹he, she, we, me›
    # TODO ‹worry› should become «wurri» (but first find out why "w'uree" currently wins)
    # TODO Add to custom.csv and handle correctly: complicate/aj,k'QmplIkIt
    # TODO 1st stressed (includes prefixed/suffixed words): dealate, nonsense, wherewithal,
    # guardee, thankee, whoopee, spiritual, noncom, nonsense, overseer
    # 2nd stressed: withal, overdraw, overreach, oversee, overseen
    # TODO Add with 2nd stressed: outshot/v, overcharge/v, overcharges/v
    # TODO Continue README from l.457: Irregular words
    # TODO Insert hyphens were necessary to prevent misreadings, incl.
    # unstressed /a/ after /i:/ or /I/:  «am'neesi-ak, zoadi-ak» ‹amnesiac, zodiac›.
    # unstressed /a/ after /u:/ e.g. «bivu-ak» ‹bivouac›;
    # «co-ope'raition» ‹cooperation›
    # Multigraphs ending in «r» may be interrupted by a stress marker before the final «r» and
    # are still read as multigraphs, e.g. «co-ope'raition, hor'rific»
    # Elsewhere, stress markers interrupt potential multigraphs, «co'operait» ‹cooperate›
    # Cf. restore_capitalization (move delsep out of that function and also handle compounds
    # such as «short-hand» ‹shorthand›)
    # (cf. "Disambiguating multigraphs")
    return combine($left, $val);
}

# insert_at_start $consonants: Insert a stress at the start of a consonant sequence (separated
# by '='). Also restores the final '='.
sub insert_at_start {
    my ($consonants) = @_;
    return "'$consonants=";
}

# insert_after_first $cons_pair: Insert a stress marker after the first consonant of a sequence.
# Also restores the final '='.
sub insert_after_first {
    my ($cons_pair) = @_;
    $cons_pair =~ s/=/='/;
    return "$cons_pair=";
}

# insert_after_second $consonants: Insert a stress marker after the second consonant of a sequence.
# If the sequence contains just one or two consonants, it's inserted at the end instead.
# Also restores the final '='.
sub insert_after_second {
    my ($consonants) = @_;
    $consonants .= '=';
    return $consonants =~ s/(.*?=.*?=)/$1'/r;
}

# insert_at_end $consonants: Insert a stress at the end of a consonant sequence (separated by '=').
# Also restores the final '='.
sub insert_at_end {
    my ($consonants) = @_;
    return "$consonants='";
}

# hyphenated_contains $hyphenated, $pattern: Return true-ish iff $hyphenated contains
# $pattern. Also accepts some legacy spellings, e.g. 'ph' instead of 'f', '=c' instead of '=s',
# and 'ce=' instead of 's='.
sub hyphenated_contains {
    my ($hyphenated, $pattern) = @_;
    $pattern =~ s/[ck](?!h)/(c[hk]?|k)/;  # c|k may be written as any of c|ch|ck|k
    $pattern =~ s/dh/th/;
    $pattern =~ s/f/(f|ph)/;
    $pattern =~ s/j/[gj]/;
    $pattern =~ s/(n[gn])=/$1?=/;         # 'g' or second 'n' after 'n' is optional
    $pattern =~ s/([rv])=/$1e?=/;
    $pattern =~ s/=s/=[sc]/;
    $pattern =~ s/s=/(s|ce)=/;
    $pattern =~ s/z(?!h)/[sz]/;
    return $hyphenated =~ /$pattern/;
}

# insert_stress_marker_among_multiple_consonants $consonants, $hyphenated, $tradspell, $sep_count:
# Insert a stress marker in the proper place in a sequence of three or more consonants.
sub insert_stress_marker_among_multiple_consonants {
    my ($consonants, $hyphenated, $tradspell, $sep_count) = @_;
    my @cons     = split /=/, $consonants;
    my $left     = '';
    my $left_sep = '';

    # Check after which consonant the break should occur
    while (@cons) {
        my $next = shift @cons;
        $left .= $next;
        $left_sep .= "$next=";
        my $rest = join '', @cons;

        return "$left_sep'" . join('=', @cons) . '='
            if hyphenated_contains $hyphenated, "$left=$rest";
    }

    # No break found, so we use suitable defaults:
    # Break before consonant sequence, e.g. «in'struction, converrsaa'tsyoneh»
    # ‹instruction, conversazione›
    return insert_at_start $consonants if $consonants =~ /^(s=t=r|t=s=y)$/;

    # Break after second consonant, e.g. «temp'taition, Pyonj'yang, pont'leviss,
    # Burg'soanian, poast'limeni, Fits'patric» ‹temptation, Pyongyang, pontlevis,
    # Bergsonian, postliminy, Fitzpatrick›
    return insert_after_second $consonants
        if $consonants =~ /^(m=p=t|n=j=y|n=t=l|r=g=s|s=t=l|t=s=[jpr])$/;

    # Otherwise break after first of three consonants, or after second of four
    return insert_after_first $consonants if $sep_count == 2;
    return insert_after_second $consonants;
}

# insert_stress_marker $consonants, $hyphenated, $tradspell: Insert a stress marker in the
# proper place in the sequence of $consonants before a stressed vowel.
sub insert_stress_marker {
    my ($consonants, $hyphenated, $tradspell) = @_;
    my $just_consonants = $consonants =~ s/=//gr;

    # Move stress marker before whole consonant sequence (second is a special case, for
    # consistency with ‹respire›)
    return insert_at_start $consonants
        if $hyphenated =~ /=$just_consonants/
        || $tradspell =~ '^respir';

    # Break after 'ns', if $hyphenated confirms that or $tradspell contains 'trans'
    # (followed by ca|g|l|n|v)
    return insert_after_second $consonants
        if $just_consonants =~ /^(ns)(.*)/
        && ($hyphenated =~ /$1=$2/ || $tradspell =~ /trans(ca|g|l|n|v)/i);

    $consonants =~ s/=$//;  # drop final '='
    my $sep_count = () = $consonants =~ /=/g;

    # Three or more consonants
    return insert_stress_marker_among_multiple_consonants $consonants, $hyphenated, $tradspell,
        $sep_count
        if $sep_count > 1;

    # Second case covers e.g. «eg'zact, ang'zaieti, lug'zhueriass» ‹exact, anxiety, luxurious›
    return insert_after_first $consonants
        if hyphenated_contains $hyphenated, $consonants || $consonants =~ /g=z/;

    # Some special cases
    return insert_at_end $consonants if $tradspell eq 'Antarctica';
    return insert_after_first $consonants
        if ($consonants =~ /^s=/ && $tradspell =~ /^dis/i)
        || ($consonants eq 'c=l' && $tradspell =~ /^Ma?cL/i)
        || ($consonants eq 'p=l' && $tradspell =~ /^popl/i);

    # Break before both consonants if the first is 's' (not followed by 'm')
    # or if the second is 'l' or 'r' (not preceded by 'r')
    return insert_at_start $consonants if $consonants =~ /^s=[^m]|[^r]=[lr]$/;

    # Otherwise break in middle
    return insert_after_first $consonants;
}

# move_stress_marker $word, $tradspell: Move stress marker before the stressed syllable,
# omitting it if the first vowel is the stressed one.
sub move_stress_marker {
    my ($word, $tradspell) = @_;

    return $word unless $word =~ /'/;  # Nothing to do

    # If the compound contains two stress markers, we keep just the first one
    $word =~ s/('.*)'/$1/ if $word =~ /'.*'/;

    if ($word =~ /(.*?)($LYTSPEL_CONSONANT*)'/) {
        my $pre_match                = $1;
        my $consonants_before_marker = $2;

        if ($pre_match eq '') {
            # First vowel is the stressed one
            $word =~ s/'//;
        } elsif ($consonants_before_marker eq '') {
            # Stressed vowel is preceded by another vowel: nothing to do
        } elsif ($consonants_before_marker =~ /^(ss|rr)=$/) {
            # «ss» and «rr» are separated by the marker,
            # e.g. «as'sault, as'sumption, hor'rific»
            $word =~ s/(.)='/'$1=/;
        } elsif ($consonants_before_marker =~ /^nng/) {
            # "nng..." becomes "n'g..."
            $word =~ s/nn(g=.*?)'/n'$1/;
        } elsif ($consonants_before_marker =~ '^[^=]+=$') {
            # Move stress marker before the single consonant
            $word =~ s/$consonants_before_marker'/'$consonants_before_marker/;
        } else {
            # Ask Text::Hyphen
            my $hyphenated = $HYPH->hyphenate($tradspell, '=');
            my $stressed_cons = insert_stress_marker $consonants_before_marker, $hyphenated,
                $tradspell;
            $word =~ s/$consonants_before_marker'/$stressed_cons/;
        }

    } else {
        # This shouldn't happen
        warn "Don't know how to move stress in '$word' ($tradspell)\n";
    }

    return $word;
}

# restore_capitalization $converted, $tradspell: Restore the proper capitalization of a converted
# word. Also deletes separators ('=').
sub restore_capitalization {
    my ($converted, $tradspell) = @_;
    # Delete separators ('=') and convert capital letters to lower case (vowel «Y» as
    # distinguished from consonant «y»)
    $converted = lc(delsep $converted);

    $converted = ucfirst($converted) if $tradspell =~ /^[A-Z][a-z']*$/;  # Capitalized

   # TODO Later fully restore capitalization to match tradspell:
   # Mc|MacCapitalized becomes McCapitalized, e.g. «McAdem, McDowel» ‹McAdam, McDowell›;
   # a repeated /k/ sound is preserved, e.g. «McCoy, McKinli» ‹...McKinley›
   # The stress marker is omitted since the second (capitalized) syllable is always stressed
   # (except McEnroe, McIntosh, McIntyre, McNamara where the first syllable is stressed --
   # probably rewrite those without capital letter e.g. as «Makintosh»; ‹Macintosh› is already
   # in the dict)
   # Preserve D?Capitalized by capitalizing the first two vowels, e.g. «DiCaprio, DuuPont»
   # ‹...DuPont›; the stress marker is omitted since the second syllable is always stressed
   # Preserve O'Capitalized, e.g. «O'Braien» ‹O'Brien›; the capitalized O is spoken /oU/
   # N'Djamena and IJssel become simple capitalized words
   # Other Cap'Capitalized words are dropped as foreign names, e.g. ‹L'Oreal›
   # ALL CAPS and other forms are considered proper names or abbreviations are also dropped
   # lowercase (including apostrophes)
    ##if ($tradspell =~ /^[a-z']+$/) {  # lowercase (including apostrophes)
    return $converted;
}

# convert_pron $pron, $mapref, $maxkeylen, $tradspell: Convert a pronunciation using a given
# mapping alphabet (dictionary reference).
# $maxkeylen is the maximum length of keys that may occur in $mapref.
sub convert_pron {
    my ($pron, $mapref, $maxkeylen, $tradspell) = @_;
    return '' unless $pron;  # Empty input

    my $unconverted = $pron;
    my $converted   = '';

OUTER: while ($unconverted) {
        my $charcount = min $maxkeylen, length $unconverted;

    INNER: while ($charcount) {
            my $start = substr $unconverted, 0, $charcount;
            my $rest = substr $unconverted, $charcount;

            # No sound starts with '`' or ':'
            if ($rest =~ /^[`:]/) {
                $charcount--;
                next INNER;
            }

            my $val = $mapref->{$start};
            if (defined $val) {  # Match found
                $converted = combine_and_adjust $val, $converted, $rest, $tradspell;
                $unconverted = $rest;
                next OUTER;
            }

            $charcount--;
        }

        die "No match found for converting /$pron/ ($tradspell), "
            . "unconverted part: /$unconverted/\n";
    }

    $converted = move_stress_marker $converted,     $tradspell;
    $converted = restore_capitalization $converted, $tradspell;
    return $converted;
}

# build_prefix_dict $mapref, $maxkeylen: Populate the prefix dictionary.
sub build_prefix_dict {
    my ($mapref, $maxkeylen) = @_;
    my $filename = 'prefix.csv';

    open my $fh, '<', $filename or die "Unable to open $filename: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        unless (scalar @$colref == 3) {
            warn "$filename lines should have 3 columns but got: ", join(',', @$colref), "\n";
            next;
        }

        my ($word, $pron, $stress_hint) = @$colref[0 .. 2];

        warn "Duplicate key '$word' in $filename\n" if exists($PREFIXES{$word});
        warn "Unexpected stress hint for prefix $word: '$stress_hint'\n"
            unless $stress_hint =~ /^[12A]$/;

        my $converted = convert_pron $pron, $mapref, $maxkeylen, $word;

        # Final «ss» becomes just «s», e.g. «dis»
        $converted =~ s/ss$/s/;
        $PREFIXES{$word} = [$converted, $stress_hint];
    }

    close $fh;
}

# build_suffix_dict $mapref, $maxkeylen: Populate the suffix dictionary.
sub build_suffix_dict {
    my ($mapref, $maxkeylen) = @_;
    my $filename = "suffix.csv";

    open my $fh, '<', $filename or die "Unable to open $filename: $!\n";
    my $colref = $CSV_IN->getline($fh);  # Skip header line

    while ($colref = $CSV_IN->getline($fh)) {
        unless (scalar @$colref == 2) {
            warn "$filename lines should have 2 columns but got: ", join(',', @$colref), "\n";
            next;
        }

        my ($word, $pron) = @$colref[0 .. 1];
        warn "Duplicate key '$word' in $filename\n" if exists($SUFFIXES{$word});
        $SUFFIXES{$word} = convert_pron $pron, $mapref, $maxkeylen, $word;
    }

    close $fh;
}

# handle_custom_entry $custom_entry, $colref, $tradspell, $mapref, $maxkeylen: Handle a
# word listed in the custom.csv file. The $custom_entry may have one of the following values:
#
# * B: use British (RP) pronunciation
# * A: use American (GA) pronunciation
# * P: use the PhonEng pronunciation
# * D: don't add the word to the output dictionary (used for rare foreign words or names)
# * O: leave the spelling of the word unchanged
#
# Alternatively, a custom pronunciation may be given which is then used to generate the
# final spelling (assumed to have at least two characters, otherwise a warning is printed
# and the entry is ignored).
sub handle_custom_entry {
    my ($custom_entry, $colref, $tradspell, $mapref, $maxkeylen) = @_;
    $PROCESSED_CUSTOM_SET{lc $tradspell} = 1;

    return $tradspell if $custom_entry eq 'O';  # Leave word unchanged
    return '' if $custom_entry eq 'D';          # Skip word altogether

    my $pron = '';

    if ($custom_entry eq 'B') {
        $pron = $colref->[3];
    } elsif ($custom_entry eq 'A') {
        $pron = $colref->[4];
    } elsif ($custom_entry eq 'P') {
        $pron = $colref->[5];
    } elsif (length($custom_entry) > 1) {
        $pron = $custom_entry;
    }

    if ($pron) {
        return convert_pron $pron, $mapref, $maxkeylen, $tradspell;
    } else {
        warn "Unexpected custom entry for $tradspell: $custom_entry\n";
    }
}

# prepare_pron $pron: Fix the pronunication of a word by normalizing non-standard forms.
sub prepare_pron {
    my $pron = shift;
    # Normalize alternative forms of the r-colored schwa
    $pron =~ s/(?<![ei])\@r|\@`r|a#r/\@`/g;
    # If there are multiple stress markers, remove all but the last one
    $pron =~ s/'(?=.*')//g;
    return $pron;
}

# Unify a sound that may be pronounced differently in two accents. Arguments:
#
# * $rp: British pronunciation
# * $ga: American pronunciation
# * $phoneng: PhonEng pronunciation (optional)
# * $alt1: how the vowel is pronounced in RP (treated as a regex)
# * $alt2: how it is pronounced in GA (treated as a regex)
# * $winner: the pronouncation that should be used
# * $tradspell: the traditional spelling (used for debugging/logging)
# * $suppress_warning: set to a true value to suppresss a warning if unification isn't possible
#   (useful for unreliable latterns)
sub unify_sound {
    my ($rp, $ga, $phoneng, $alt1, $alt2, $winner, $tradspell, $suppress_warning) = @_;

    my $rp_alt1_count = () = $rp =~ /$alt1/g;
    my $ga_alt2_count = () = $ga =~ /$alt2/g;

    return $rp, $ga, $phoneng unless $rp_alt1_count && $ga_alt2_count;  # Nothing to do

    # Split on either alternative (NOT matching if /`/ as in /@`/ follows)
    my @rp_split      = split /($alt1|$alt2)(?!`)/, $rp;
    my @ga_split      = split /($alt1|$alt2)(?!`)/, $ga;
    my @phoneng_split = split /($alt1|$alt2)(?!`)/, $phoneng;
    my $rp_elem_count = scalar @rp_split;

    unless ($rp_elem_count == scalar @ga_split) {
        # TODO Disable this warning for the handful of known cases
        warn "Note: Cannot unify $tradspell pronouncations re $alt1/$alt2\n"
            unless $suppress_warning;
        return $rp, $ga, $phoneng;
    }

    my $unify_phoneng_too = $rp_elem_count == scalar @phoneng_split;

    for my $i (0 .. $rp_elem_count - 1) {
        if ($rp_split[$i] =~ /^$alt1$/ && $ga_split[$i] =~ /^$alt2$/) {
            $rp_split[$i] = $winner;
            $ga_split[$i] = $winner;

            $phoneng_split[$i] = $winner
                if $unify_phoneng_too && $phoneng_split[$i] =~ /^($alt1|$alt2)$/;
        }
    }

    $rp = join '', @rp_split;
    $ga = join '', @ga_split;

    $phoneng = join '', @phoneng_split if $unify_phoneng_too;

    return $rp, $ga, $phoneng;
}

# Unify the sound used in different pronunciations in cases where a specific vowel
# pronunciation should "win". Generally, unification is only attempted if RP and GA differ;
# otherwise the given pronunciations are returned unchanged. Redundant pronunciations
# (identical to an earlier one) are eliminated in any case.
sub unify_sounds {
    my ($rp, $ga, $phoneng, $tradspell) = @_;
    $rp      = prepare_pron $rp;
    $ga      = prepare_pron $ga;
    $phoneng = prepare_pron $phoneng;

    # Discard GA if identical to RP
    $ga = '' if $ga eq $rp;
    # Discard PhonEng if identical to RP or GA
    $phoneng = '' if $phoneng eq $rp || $phoneng eq $ga;

    # If PhonEng has /Nk/ where RP/GA have /nk/, use the former as it's usually correct
    if ($phoneng =~ /Nk/ && $rp =~ /nk/) {
        ($rp, $phoneng) = unify_sound $rp, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0;
        ($ga, $phoneng) = unify_sound $ga, $phoneng, '', 'nk', 'Nk', 'Nk', $tradspell, 0
            if $ga;
    }

    return $rp, $ga, $phoneng unless $ga;  # Nothing more to unify

    # Unify vowels:
    # pair, share, variation -> «air»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'e@', 'Er', 'e@', $tradspell, 0;
    # cheer, year, peculiar -> «eer»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'i:?@', 'Ir', 'i@', $tradspell, 0;
    # poor, tour -> «oor»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'U@', 'Ur', 'Ur', $tradspell, 1;
    # number, modern -> «er» (schwa vs. r-colored schwa)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, '(?<![ei])@', '@`', '@`', $tradspell, 1;
    # port, ignore, keyboard, floral -> «oar»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'or', 'or', $tradspell, 1;
    # sorry, tomorrow -> «orr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Qr', 'O:r', 'Qr', $tradspell, 0;
    # for, dinosaur -> «or»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'O:r?', 'O:r', 'O:r', $tradspell, 0;
    # encourage, current -> «urr»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, 'Vr', '3:r?', 'Vr', $tradspell, 0;
    # due, neutral, tune -> «ue»
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'u:", "(?<![j])'u:", "'U:",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "ju:", "(?<![j'])u:", "U:",
        $tradspell, 0;
    # during, neural -> «uer» (/ju:r/ or /jUr/ in RP, /Ur/ in GA)
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j'(?:u:|U)r", "(?<![j])'Ur", "'U:r",
        $tradspell, 0;
    ($rp, $ga, $phoneng) = unify_sound $rp, $ga, $phoneng, "j(?:u:|U)r", "(?<![j'])Ur", "U:r",
        $tradspell, 0;

    return $rp, $ga, $phoneng;
}

# choose_nearer_or_shorter $first, $second, $tradspell: Choose and return $first or $second
# depending on which one is more similar to $tradspell.
# If both are equally similar, the shorter one is returned
# If there is still a tie, $first is returned.
# If $second is undefined or empty, $first is returned without further checks.
sub choose_nearer_or_shorter {
    my ($first, $second, $tradspell) = @_;
    return $first unless $second;

    my $comp = dist($first, $tradspell) <=> dist($second, $tradspell);
    $comp = length($first) <=> length($second) unless $comp;
    # TODO Find out how to disambiguate these cases
    #warn "$first and $second have equal distance to $tradspell and equal length\n" unless $comp;

    return ($comp <= 0) ? $first : $second;
}

# select_nearest: Select among the three converted spellings the one that's closest to
# $tradspell and return it. $converted_ga and $converted_phoneng may be empty.
sub select_nearest {
    my ($converted_rp, $converted_ga, $converted_phoneng, $tradspell) = @_;
    my $choosen = choose_nearer_or_shorter $converted_rp, $converted_ga, $tradspell;
    return choose_nearer_or_shorter $choosen, $converted_phoneng, $tradspell;
}

# postprocess_suffixed ...: Postprocess a suffixed words, restoring original end-of-word spellings
# (e.g. final "tion" in derived words such as «options, tra'ditionel, imoatio'naliti»
# ‹...traditional, emotionality›.
sub postprocess_suffixed {
    my ($converted, $base, $suffix, $pos_hint, $tradspell, $mapref, $maxkeylen) = @_;
    # Some suffixes are usually derived from a certain POS tag
    $pos_hint = 'n' if $tradspell eq 'contractor';
    $pos_hint ||= 'v' if $tradspell eq 'inversely' || $suffix =~ /^(able|ed|e?s|ing|or)$/;
    $pos_hint ||= 'aj' if $suffix =~ /^(ize|ly)$/;
    $pos_hint ||= 'n'
        if $tradspell =~ /^(internist|presentist|progressist)$/
        || $suffix =~ /^(ful|less)$/;
    # TODO x Lookup all bases, e.g. ‹emotionality› is derived from ‹emotional› which is
    # derived from ‹emotion›, or ‹expression=ist=ic› (the former is autoconverted, but not
    # the latter); ditto ‹nationality›.
    # To match: use List::Util 'any'; if( any { /tion$/ } @strings ) {
    my $conv_base_colref = lookup_part_entry($base, $tradspell, $pos_hint, $mapref, $maxkeylen);
    my $conv_base = restore_capitalization $conv_base_colref->[3], $tradspell;

    # TODO Eliminate regex
    # For suffixes where that's possible, simply append the suffix to the converted base word
    if ($suffix =~
/^(able|ant|ative|atory|dom|ed|en|es|ent|er|ess|est|ful|ing|ise|ish|ism|ist|ize|less|ly|ment|ness|n|or|up|s|y)$/
        )
    {
        my $conv_suffix = $SUFFIXES{$suffix};

        # Before suffixes starting with e/i/y, final «c» becomes «k»
        # (e.g. «practikebl» ‹practicable›)
        $conv_base =~ s/c$/k/ if $conv_suffix =~ /^[eiy]/;

        # «d» (past tense) becomes «ed» after «d, t»
        $conv_suffix = 'ed' if $conv_suffix eq 'd' && $conv_base =~ /[dt]$/;

        # Final «ment» becomes stressed before some suffixes
        if ($conv_base =~ /ment$/ && $suffix =~ /^(able|ative)$/) {
            $conv_base =~ s/'//;
            $conv_base =~ s/ment$/'ment/;
        }

        # An additional /g/ might become audible between final /N/ and some suffixes
        # (e.g. «longger, stronggest» ‹longer, strongest›)
        if (   $suffix =~ /^(er|est|ish)$/
            && $conv_base =~ /ng$/
            && $converted =~ /ngg$conv_suffix$/)
        {
            $conv_suffix = "g$conv_suffix";
        }

        # «s» (plural or third person singular) is written «es« after sibilants
        $conv_suffix = 'es' if $conv_suffix eq 's' && $conv_base =~ /([jsxz]|[csz]h)$/;

        # «tys» ‹tise› becomes stressed before «ment»
        # (e.g. «adver'tysment» ‹advertisement›)
        if ($conv_base =~ /tys$/ && $suffix eq 'ment') {
            $conv_base =~ s/'//;
            $conv_base =~ s/tys$/'tys/;
        }

        # Suffix «n» becomes «en» after some consonants
        $conv_suffix = 'en' if $conv_suffix eq 'n' && $conv_base =~ /[djkhlpstv]$/;

        # Rules for single-consonant suffix such as «d, n, s»
        if ($conv_suffix =~ /^[^$LYTSPEL_VOWELS]$/) {
            # Final «i» /i:/ becomes «ie» to prevent misreadings
            $conv_base .= 'e' if $conv_base =~ /i$/;
            # Final «o» /oU/ is restored to «oa»
            $conv_base .= 'a' if $conv_base =~ /(?<!o)o$/;
            # Final «u» /u:/ is restored to «uu»
            $conv_base .= 'u' if $conv_base =~ /(?<!i)u$/;
        }

        # Schwa at the start of suffixes is written «a» if the base word ends in /i:/ or /u:/
        substr $conv_suffix, 0, 1, 'a'
            if $conv_suffix =~ /^e[^er]/
            && $conv_base =~ /(ee|i|[^i]u)$/;

        return "$conv_base$conv_suffix";
    }

    # Restore «tion» (shen) and «sion» (zhen), e.g.
    # «ri'laitionship, tra'ditionel, o'caisionel» ‹relationship, traditional, occasional›
    if ($conv_base =~ /tion$/) {
        $converted =~ s/(.*)shen/$1tion/;
        $converted =~ s/(.*)sho'n/$1tio'n/;
    } elsif ($conv_base =~ /sion$/) {
        $converted =~ s/(.*)zhen/$1sion/;
        $converted =~ s/(.*)zho'n/$1sio'n/;
        # TODO x
        #} elsif ($conv_base =~ /aul$/) {
        #    $converted =~ s/(.*)aul/$1all/;
        #    $converted =~ s/(.*)au'l/$1al'l/;
    }

    # Note: Some cases seem never to occur with these suffixes and hence haven't been added:
    # all» (aul)

# TODO x Suffix handling:
# Preserved:
# *
# * (needed) Omitted schwa between some consonants and «l» and «m», e.g. ‹singles, legalizing,
# legally, algorithms, statistically, rhythms, hospitalization, simplest›
# * «c» /k/: «publicli, publi'caition»
# * But «c» becomes «k» before «e, i, y»: «trafiking»
# * «k» /k/: «weeks, weekli»
# * «ss» /s/: «classic, con'vinssd, con'vinssing, a'nounssment»
# * «a» /@/: «extras, A'merrican»
# * «aw» /O:/: derivs of «law, draw» (only relevant if a consonant follows)
# * «ay» /eI/: derivs of «play, holiday, layer, cayoss» (only relevant if a consonant
#   follows)
# * «eh» /E/
# * unstressed «i» /i:/: derivs of ‹fancy, necessity, video, creation› (only relevant if
# a consonant follows)
# * unstressed «o» /oU/: «yeloer, yeloest, vurchus» (only relevant if a consonant follows)
# * «ow» /aU/: derivs of ‹now, allow› (only relevant if a consonant follows)
# * «oy» /OI/: «de'stroys, de'stroyd, de'stroyer» (only relevant if a consonant follows)
# * «u» /u:/: derivs of ‹clue, issue› (only relevant if a consonant follows)
# * «uh» /V/
# * «y» /aI/ (even before vowels): «hyer»
# * «yr» /aI@`/: «in'spyrd»
# * Any other special end-of-word spellings
# * «t» ‹ed› becomes «d»: «fixd, con'vinssd»
# * Double consonants may occur, e.g. «toatlli» ‹totally›
#
# Special rules:
# * /ks/ doesn't become «x» if the /s/ starts the suffix
# * But the second letter does change in other combis such as «ia» in ‹agreeable›
# * «tion» and «sion» aren't used in -n/-en suffixed words,
#   e.g «ashen, freshen, Rushan, Purzhan»
# * Suffix «ful» remains unchanged (not "fl")
# * If the derived word starts with «e» and the base word with another short vowel,
#   use the latter (e.g. ‹communication, configuration›).
#
# Some suffixes need special treatment:
# * «el» ‹al› becomes just «l» after any of «bcdfgkpstz»
# * ed/es/s
# * -ial after «t» merges to /tS@l/
# * -ion after «st» merges to /tS@n/ (written «chen»), after «t» to /S@n/
#   (written «tion»)
# * -ual after «t» merges to /tSu:@l/
#
# Notes:
# * consonants commonly occurring at the start of suffixes are /d/t/f/l/m/n/s/z/
# * if stress changes, a schwa might become a short vowel--in that case, use it
#   also for the base form, e.g. «telson» due to «tel'sonic» ‹telsonic›
#
# TODO Recognise a= /eI/ suffix just before /s, z/, e.g. ‹asymmetry›
# TODO Debug whether remaining changes between base and derived words are OK
# TODO Explain that stress markers may move into the main word (e.g. before -ation, -ee),
# but never into the prefix or across word boundaries in a compound)
# TODO x Document (if/when applicable) main word+suffix combis such as:
# ‹doable› «duebl» (not duabl), ‹pitiable› «pitieble» (not pitiabl)
# TODO Possibly restore omitted pre-final schwa before suffixes starting with a vowel, e.g
# «lybeler» ‹libeler› from «lybl» ‹libel› -- but probably once before «ism, ist»
# [and maybe «ize»] to prevent misreadings, e.g. «capitelist, funda'mentelist, voakelist»
# ‹capitalist, fundamentalist, vocalist› (rather than
# «*capitlist, funda'mentlist, voaclist»)
# TODO Maybe try the rule: final «ss» after consonant (except /f, k, p, t, T/) is changed
# back to «s», while final «s» is changed to «z» in this case (probably only before
# vowels or just in those cases where confusion is possible, e.g. (sometimes?) before
# «i, er»).
# TODO ‹humanistic› should use «e» for the schwa, like ‹humanist› (generally)
# TODO gondolier,gQnd@#l'i@  # should become gonde'leer, not gondo'leer
# TODO Correct c->k: ‹workaholic› (special case, not a suffix because it's so rare)

    return $converted;
}

# convert_row $colref, $tradspell, $mapref, $maxkeylen: Convert a row (CSV line)
# from $IN_FILE style to $OUT_FILE. Any listed pronunciations are converted using the
# Lytspel rules and the resulting spelling that's nearest to the traditional spelling is
# selected and appended to the resulting output row. Also handles compounds correctly
# and updates the global $SUMMED_DIST and WORD_COUNT variables.
sub convert_row {
    my ($colref, $tradspell, $mapref, $maxkeylen) = @_;
    my $parts = $COMPOUND_DICT_REF->{lc $tradspell};
    my $converted;

    # First check if it's a compound
    my $compound = handle_compound($colref, $parts, $tradspell, $mapref, $maxkeylen) if $parts;

    if (!$compound || $compound =~ /^!/) {
        # It's a base or a suffixed word (the latter requires postprocessing)
        my $custom_entry = $CUSTOM_DICT_REF->{lc $tradspell} // '';

        if ($custom_entry) {
            $converted = handle_custom_entry $custom_entry, $colref, $tradspell, $mapref,
                $maxkeylen;
        } else {
            my ($rp, $ga, $phoneng) = unify_sounds $colref->[3], $colref->[4], $colref->[5],
                $tradspell;
            my $converted_rp      = convert_pron $rp,      $mapref, $maxkeylen, $tradspell;
            my $converted_ga      = convert_pron $ga,      $mapref, $maxkeylen, $tradspell;
            my $converted_phoneng = convert_pron $phoneng, $mapref, $maxkeylen, $tradspell;

            # Omit GA if identical to RP
            $converted_ga = '' if $converted_ga eq $converted_rp;
            # Omit PhonEng if identical to RP or GA
            $converted_phoneng = ''
                if $converted_phoneng eq $converted_rp || $converted_phoneng eq $converted_ga;

            # Keep only the spelling that's closest to tradspell
            # TODO x For compounds, take converted $base + $suffix as baseline?
            $converted = select_nearest $converted_rp, $converted_ga, $converted_phoneng,
                $tradspell;
        }
    } else {
        $converted = $compound;
    }

    return '' unless $converted;  # Skip word if handle_custom_entry returned empty result

    if ($compound && $compound =~ /^!(.*)=(.*)/) {
        # Postprocess suffixed word
        my $base     = $1;
        my $suffix   = $2;
        my $pos_hint = $colref->[1];
        $converted = postprocess_suffixed $converted, $base, $suffix, $pos_hint, $tradspell,
            $mapref, $maxkeylen;
    }

    $SUMMED_DIST += dist $converted, $tradspell;
    $WORD_COUNT++;
    my $conv_colref = [@$colref[0 .. 2], $converted];
    return $conv_colref;
}

# lookup_part_entry $part, $tradspell, $pos_hint, $mapref, $maxkeylen: Look up the entry
# for a word part of a compound, taking case redirects and POS-tagged word parts into
# account. Returns the converted entry row -- if the word hasn't been processed before,
# it will be converted.
sub lookup_part_entry {
    my ($part, $tradspell, $pos_hint, $mapref, $maxkeylen) = @_;
    my $cased         = $CASE_REDIRECT_REF->{$part};
    my $key           = $cased ? $cased : $part;
    my $unconv_colref = $UNCONVERTED_DICT_REF->{$key};

    unless ($unconv_colref) {
        # Must be a POS-tagged word -- use the provided $pos_hint or else 'v', since it's the
        # most frequent POS tag
        my $pos = $pos_hint || 'v';

        # Some heuristics to pick the correct POS tag use
        unless ($pos_hint) {
            # TODO Remove unnecessary parts (such as able, ing)
            # Most words ending in -ate are adjectives (e.g. ‹agglutinate›).
            # Most ‹close...› combinations use the adjective.
            $pos = 'aj'
                if ($part =~ /ate$/ && $tradspell !~ /(able|^predesignate)$/)
                || ($part eq 'close' && $tradspell !~ /^close(down|out|ing|d|s)$|.close$/);
            $pos = 'n'
                if ($part =~ /^(congress|house|lead|transfer|transfer|wind)$/
                && $tradspell !~ /(able|^(${part}e?r|fairlead|mislead|leadoff))$/)
                || $tradspell =~ /^(internship|rebeldom)$/;
        }

        $key = gen_key $part, $pos;
        $unconv_colref = $UNCONVERTED_DICT_REF->{$key};

        # TODO Simplify this code
        unless ($unconv_colref) {
            # Use 'n' or else 'aj' as fallback
            $key = gen_key $part, 'n';
            $unconv_colref = $UNCONVERTED_DICT_REF->{$key};

            unless ($unconv_colref) {
                $key = gen_key $part, 'aj';
                $unconv_colref = $UNCONVERTED_DICT_REF->{$key};

                unless ($unconv_colref) {
                    warn "No entry found for $key\n";
                    return;
                }
            }
        }
    }

    my $conv_colref = $CONVERTED_DICT_REF->{$key};
    unless ($conv_colref) {
        # Convert word now
        $conv_colref = convert_row $unconv_colref, $cased || $part, $mapref, $maxkeylen;
        $CONVERTED_DICT_REF->{$key} = $conv_colref;
    }

    return $conv_colref;
}

# handle_compound $colref, $parts, $tradspell, $mapref, $maxkeylen: Handle a compound or
# derived form. The return value is one of the following:
#
# * the spelling to use if the word is a compound or a prefixed form
# * "!mainword=suffix" if it's a suffixed word (for later postprocessing)
# * undef otherwise
sub handle_compound {
    # TODO Refactor this function into shorter ones
    my ($colref, $parts, $tradspell, $mapref, $maxkeylen) = @_;
    my $pos = $colref->[1];
    my ($first_lytspel, $second_lytspel, $compound);

    if ($parts =~ /-/) {
        # It's a compound made of two parts (separated by '-')
        my ($first, $second) = split /-/, $parts;
        my $first_conv_colref  = lookup_part_entry $first,  $tradspell, $pos, $mapref, $maxkeylen;
        my $second_conv_colref = lookup_part_entry $second, $tradspell, $pos, $mapref, $maxkeylen;
        $first_lytspel  = restore_capitalization $first_conv_colref->[3], $tradspell;
        $second_lytspel = lc $second_conv_colref->[3];
        $compound       = "$first_lytspel$second_lytspel";

        # If the compound contains two stress markers, we keep just the second one
        $compound =~ s/'// if $compound =~ /'.*'/;

        # If the compound contains a stress markers, we retain it (unless the second part is
        # «a'bout» ‹about›, e.g. «roundabout») and are done (unless the first part is
        # «i'lectro» ‹electro› -- then we'll check below which part carries the main stress)
        if ($compound =~ /'/) {
            $compound =~ s/'// if $second eq 'about';
            return $compound unless $first eq 'electro';
        }

        # If this word is listed as a special case, we return it and are done
        return $compound if exists($STRESS_FIRST_PART{$tradspell});

        # Insert stress marker before second part if appropriate
        $compound = "$first_lytspel'$second_lytspel"
            if exists($STRESS_AFTER{$first})
            || exists($STRESS_IF_SECOND{$second})
            || exists($STRESS_SECOND_PART{$tradspell});

        if (exists($STRESS_VARIES_IF_FIRST{$first})) {
            # Check pronunciation to find out which part to stress
            my $pron = $colref->[5] || $colref->[3];  # prefer PhonEng, use RP as fallback

            # In ‹electro...› combinations, we discard the first sound (vowel), since it's
            # never stressed
            $pron = substr($pron, 1) if $first eq 'electro';

            if ($pron =~ /[$SAMPA_VOWELS].*'/) {
                # If a vowel occurs before the stress marker, we assume that the 2nd part is
                # stressed (in case of ‹electro...› combinations, it may already contain a
                # stress marker)
                $first_lytspel =~ s/'//;  # convert «i'lectro» to «ilectro»
                $compound = "$first_lytspel'$second_lytspel" unless $second_lytspel =~ /'/;
            }
        }

        return $compound;
    } else {
        # Otherwise it should be a prefixed or suffixed word (separated by '=')
        my ($first, $second) = split /=/, $parts;
        my $stress_hint;
        my $suffixed = 0;

        unless ($second) {
            warn "Invalid compound definition for $tradspell: $parts\n";
            return undef;
        }

        # Second may be a suffix and/or first may be a prefix
        if (exists $SUFFIXES{$second}) {
            $second_lytspel = $SUFFIXES{$second};
            $suffixed       = 1;
        }

        if (exists $PREFIXES{$first}) {
            $first_lytspel = restore_capitalization $PREFIXES{$first}->[0], $tradspell;
            $stress_hint = $PREFIXES{$first}->[1];
        }

        # The part not yet defined must be a regular entry
        unless ($first_lytspel) {
            my $first_conv_colref = lookup_part_entry $first, $tradspell, $pos, $mapref, $maxkeylen;
            die "Part $first not found while processing $tradspell\n" unless $first_conv_colref;
            $first_lytspel = restore_capitalization $first_conv_colref->[3], $tradspell;
        }

        if (!$second_lytspel || ($second eq 'able' && $stress_hint)) {
            # Lookup second part in regular dictionary if it's not a suffix or in case
            # of prefix='able' combinations such as 'unable'
            my $second_conv_colref = lookup_part_entry $second, $tradspell, $pos, $mapref,
                $maxkeylen;
            die "Part $second not found while processing $tradspell\n" unless $second_conv_colref;
            $second_lytspel = lc $second_conv_colref->[3];
        }

        if ($stress_hint && $suffixed && $first =~ /^(out|post)$/) {
            # Combination of "out" or "post" with a suffix are converted like non-compounds
            return undef;
        }

        if ($suffixed && !$stress_hint) {
            # Main word=suffix combination: return for later postprocessing
            return "!$first=$second";
        }

        $compound = "$first_lytspel$second_lytspel";

        if ($stress_hint eq '1') {
            $second_lytspel =~ s/'//;  # delete stress marker from 2nd part, if any
            $compound = "$first_lytspel$second_lytspel";
        } elsif ($stress_hint eq '2') {
            # Insert stress marker before 2nd part (unless it already contains one)
            $compound = "$first_lytspel'$second_lytspel" unless $second_lytspel =~ /'/;
        } elsif ($stress_hint eq 'A') {
            # Check pronunciation to find out which part to stress
            my $pron = $colref->[5] || $colref->[3];  # prefer PhonEng, use RP as fallback

            if ($pron =~ /[$SAMPA_VOWELS].*'/) {
                # If a vowel occurs before the stress marker, we assume that the 2nd part is
                # stressed
                $compound = "$first_lytspel'$second_lytspel" unless $second_lytspel =~ /'/;
            } else {
                $second_lytspel =~ s/'//;  # delete stress marker from 2nd part, if any
                $compound = "$first_lytspel$second_lytspel";
            }
        } else {
            warn "Entry '$tradspell' has invalid stress hint: '$stress_hint'\n";
        }

        return $compound;

        # TODO Adapt decompose to use prefix/suffix.csv instead of .list by
        # TODO x Add prefixes: ab- (e.g. abampere, 2nd part stressed)
        # Add suffix: -otic (stressed before suffix), -ology (ditto)
        # Stress last syllable of 1st part: -meter (e.g. aerometer, electrometer, hypermeter,
        # alkalimeter), -tropism (e.g. aerotropism, geotropism, stereotropism)
        # Add prefix per- «per»: stress 2nd part; but keep a few manual entries for ‹per›
        # «pur» (likewise stressed on 2nd part): percutaneous,per-cutaneous;
        # peroxidic,per-oxidic; peroxide,per-oxide
        # Add suffixes: -ine «in» or maybe «yn» (e.g. petaline, phialine;
        # ensure that no -line words are accidentally excluded),
        # -oid (e.g. petaloid), -ous «uss» (e.g. petalous)
        # Add prefixes: ‹tele› «tele»; ‹zoo› /zoU@/ «zoa» (PE determines stress);
        # neuro- (make sure it's used for ‹neurosecretion›)
        # neo-
        # Make -tic a suffix instead of a regular compound part (e.g. aromatic;
        # also change compounds-manual entries accordingly),
        # likewise -ary /Eri:/ (e.g. insectary, visionary; also change compounds-manual entries
        # accordingly), -ology (e.g. planetology), -arian (e.g. parliamentarian),
        # make a suffix: tele-
        # Add -nik /nIk/ suffix (e.g. refusenik)
        # Add suffix -taxis /taksIs/ and use instead of compound part (e.g. ‹chemotaxis›)
        # Stress before final consonant(s) of first part (probably treat as suffix): -otic,
        # e.g. «aci'dotic» ‹acidotic›
        # Make ‹zoo› a prefix written «zoe» /zoU@/; first or second part may be stressed.
        # Make suffix: ate (spoken «ait» /eIt/ or sometimes «it» /It/ -- dicts sometimes have
        # /@t/ instead)
        # Add -ible as suffix (or check+fix -ibl spellings)
        # Exceptions where 1st is stressed: all [-=]sphere combis (e.g. biosphere, chemosphere)
        # TODO Adapt decompose (and Makefile) to use prefix|suffix.csv instead of .list
        # TODO Write initial /dI#/ as «di» (for consistency with the «di» ‹de› prefix)
    }

# TODO When looking up words, consider that they might be POS-tagged (v, n, av, prp)
# Then handle prefixed ('=' with known prefix) and suffixed entries.
# TODO Handle prefixes and suffixes correctly («dis, mis; anti, semi» are spelled like that
# regardless of which letter follows; prefixes «baio, nio» ‹bio, neo›;
# suffix «ful» is preserved; «-est» remains as is (never "ast"))
# Test that is also works if the case of the original word is different.
# Correct and use the result for each prefix/suffixes; also handle and
# document schwa/single-letter short changes such as «hexagen» ‹hexagon› due to «he'xagenel»
# ‹hexagonal›; deal with «nationel» ‹national› from «naition» ‹nation› as a special case
# (the derived form is irregular).
# Ensure that «obzur'vaition» ‹observation› is converted correctly (from «ob'zurv» ‹observe›)
# Ensure that the «tion» and «sion» spellings aren't used in words derived by appending «n» or
# «en», e.g. «ashen, freshen, Rushan, Purzhan»
# TODO Add -ance, -ence as suffixes
# TODO Add 'bi' as prefix, otherwise add manual entries:
# biconcave,bi-concave
# biconcavity,bi-concavity
# Add 'on' as prefix, e.g. ‹oncoming› should be analysed as ‹on=coming›
}

# warn_unprocessed_custom_entries: Warn if there are entries in the custom.csv file not
# in the dictionary.
sub warn_unprocessed_custom_entries {
    # TODO Add a similar checks for compounds-manual.csv and compound-black|blacklist.csv
    # (also warn if there are duplicate entries)
    for my $key (sort keys %$CUSTOM_DICT_REF) {
        warn "Unused $CUSTOM entry: $key\n" unless exists $PROCESSED_CUSTOM_SET{$key};
    }
}

# convert_dict: Convert SAMPA spellings to Lytspel.
sub convert_dict {
    my ($mapref, $maxkeylen) = build_mapping;
    build_prefix_dict $mapref, $maxkeylen;
    build_suffix_dict $mapref, $maxkeylen;
    ($UNCONVERTED_DICT_REF, $CASE_REDIRECT_REF) = build_unconverted_dict_and_case_redirects;
    my $outfh = open_outfile_and_write_header $OUT_FILE, [qw(Traditional POS Redirect Lytspel)];

    for my $key (sort { lc $a cmp lc $b } keys %$UNCONVERTED_DICT_REF) {
        my $colref = $UNCONVERTED_DICT_REF->{$key};

        if (scalar @$colref < 4) {
            # Nothing to convert, just output and store line as is
            $CSV_OUT->print($outfh, $colref);
            $CONVERTED_DICT_REF->{$key} = $colref;
            next;
        }

        my $conv_colref = $CONVERTED_DICT_REF->{$key};
        if ($conv_colref) {
            # Word has already been converted
            $CSV_OUT->print($outfh, $conv_colref);
            next;
        }

 # TODO Stress 1st part: breakaway, castaway, cutaway, flyaway, foldaway, getaway, giveaway,
 # Greenaway, Hathaway, hideaway, huntaway, layaway, rockaway, rollaway, runaway, soakaway,
 # stowaway, straightaway, throwaway, walkaway (-away in general);
 # counterattack, counterreply, counterproposal, countersubject, heterocycle, lookalike,
 # minicomputer, pinafore, newsmagazine, turnaround,
 # slugabed, standalone, tarmacadam, telerecord, turnverein, videocassette, woebegone
 # servocontrol/n, antimatter, bioscience (and derivs), inbreeding,  microchip, microprogram,
 # microreader, Microsoft, prefix, semilegendary, subchapter, subnotebook, subroutine,
 # supercalender, superfund, supergiant, superhero, superpower, superstar, underwriting,
 # underwrote,  infiltrate, insufflate, slugabed, dealate
 # -amine (calamine, Dramamine, hexamine, histamine), -around
 # Stress 2nd part: aerologic only, not choplogic; benediction, binocular,
 # bronchiectasis, commonsense, dextrocardia, diacetylmorphine, diazomethane, duecento,
 # echocardiogram, eftsoon, everlasting, farewell, forever, forevermore, goodbye, hemelytron,
 # hereinafter, boohoo, lambaste, mercaptopurine, methacrylate, multiparty
 # methylbenzene, methylnaphthalene, moreover, nymphomaniac, oleomargarine, penannular,
 # penultimate, penultima, phenylalanine, philhellene, prolapse, semidemisemiquaver,
 # Rockhampton, saltpeter, sardonyx, statampere, sulfaguanidine, sulfathiazole, sympetalous,
 # synchrocyclotron, tetraethyl, throughout, uniaxial, without, superconducting, superconductor,
 # superminicomputer, underutilize, methylal, counteract, counterbalance/v
 # (also counterbalancing etc.), straightforward, maltreat, malodorous, upstanding, protozoa,
 # subaltern, malfunction, eftsoon, magnetooptics, paramedic, petrochemical, petrochemistry,
 # portcullis
 # -aldehyde, -chemical, -chemistry, -decagon, -eastern, -forward, -metric, -phonic, -sexual,
 # -western, magneto-, mal- (except malware)
 # PE determines stress: proto-, stereo-, probably after- (e.g. afternoon)
 # TODO Treat all words ending in ‹syllable› or ‹syllabic› as compounds even if not listed
 # (2nd stressed: dissyllable, dodecasyllable), ditto ‹disyllabism› (2nd stressed) and
 # ‹monosyllabicity›
 # TODO Make -ary -> erri a suffix (reactionary, customary)
 # make -ate a suffix spoken either «ait» or «et|it» (e.g. «dy'recteret» ‹directorate›;
 # sometimes it depends on the POS tag, e.g. ‹proportionate›)
 # TODO Add missing entries: centralist (should become central=ist and centralists: centralist=s),
 # Melanesia (base word for Melanesian), grassing (base for grassings, from grass)
 # TODO Possibly integrate additional POS-tagged variants (see below) into extra-words.txt
 # and rename it to .csv (otherwise rename it to .list)
 # TODO Distinguish live/v: liv vs aj: lyv (used for livelong, overlive, unlive);
 # ‹planoconvex› should be come «planocon'vex» (from the aj)
 # TODO Unify /@ri:/ (or /@rI/ or /@`ri/) vs. /Eri:/ to the latter, e.g.
 # ‹solidary, temporary, voluntary›
 # TODO Add custom: involute/n, InvQlu:t (involuut), ally/v,al'aI (a'ly; should also be used in
 # ‹misally›), record/n,A  (rekerd), discord/v,P (also base for discordant), frequent/v,P  (also
 # for frequentative), minute/aj: maIn'U:t (my'nuet),
 # intimate/aj: 'IntImI#t -> intimit (incl. derived variant of ‹intimates›)
 # TODO extra-words: Add ‹controvertible› (should be used for ‹incontrovertible›);
 # ‹errable› (from ‹err›, for ‹inerrable›)
 # TODO Derive from intern/n: internship
 # TODO ‹quad› should probably always become «quod» rather than «quaad»
 # TODO Add stress-shifted variants (2nd/last vowel stressed): content/aj+v (also contentment etc.),
 # concert/v, preconcert/v, reflex/v, resaw/v, survey/v (also for resurvey/v), semipro/n,
 # sublease/v, understeer/v, ferment/v, console/v (also basis for consolatory),
 # interupt/v (also for interrupter etc.), collect/v (also for collecting, collector etc.),
 # compact/aj+v (also for compactness, compactor etc.), adduct/v (also for adductor)
 # add with 1st stressed: misfire/n, redial/n, redo/n, remit/n, replay/n, remake/n, invalid/n+v
 # TODO reincarnate: split in v+aj; Split ‹overestimate, reexport, warehouse› into n+v
 # Add desert/n,dez@rt  # desert (use for semidesert, desertic), mouse/v: m'aUz (also use
 # for mouser), mouth/v: use P (also for mouther and the various -mouthed combis),
 # addict/v (also for addicted), commune/v, insult/v, defect/v: use P
 # subordinate/v should end in «ait» instead of «et»
 # supersaturate: derive from saturate/v; ungallant: derive from gallant/aj;
 # unwind: derive from wind/v; uncleanly: split in aj+av; add bifurcate/aj: ...It
 # toward/aj: tw'ord, /prp: use P (if needed; delete old custom entry)
 # curate/n: kj'UrIt, v: kjUr'eIt (also for curator)
 # alternate/aj+n: 'O:lt@`nIt, v: 'O:lt@`neIt
 # appropriate/aj: a#pr'oUpri:It, v: a#pr'oUpri:eIt (also for appropriator)
 # subalternate should be derived from aj
 # graduate: use -it for aj+n, -ait for v (also graduated|ing)
 # congress/n should use default pron (conggress), only congress/v should use P
 # costume/v: kQst'U:m (co'stuem); estimate/n: 'EstImIt (estimet); proceed/n: P
 # TODO tridimensional should use «tion» spelling (even though it's not a compound)
 # TODO If a word has n+v, generate the same for «=es|s», e.g. ‹overlaps›
 # TODO Maybe try switching «or» and «oar» (check whether that improves visual similarity)
 # TODO Possibly eliminate «c» spelling for /s/ (using «ss» instead), since it causes
 # inconsistencies with suffixes starting with a schwa after final /s/
 # TODO Warn if derived words use a different letter case and fix such cases
 # TODO Add end-of-word spellings such as «eh» to see whether they occur
 # TODO Document cases where the dictionary is insufficient, e.g. ‹bass, drawer, read,
 # subsequence, tier, berlin, closer, moped, taxis, simas, viola, viva›
 # TODO Shift stress marker: «lorn'yet» ‹lorgnette›, not «*lor'nyet»;
 # «may'iutic» ‹maieutic›, not «*ma'yiutic»
 # TODO Custom heuristics (case insensitive): aero- becomes airo- (not airoa-)

        $conv_colref = convert_row $colref, $colref->[0], $mapref, $maxkeylen;
        $CONVERTED_DICT_REF->{$key} = $conv_colref;
        $CSV_OUT->print($outfh, $conv_colref) if $conv_colref;

        # TODO Finally drop POS tag if all variants are written the same, e.g. «mouth»
        # TODO y Make more frequently-used variables file-scoped (not truly global!);
        # use Some_Caps style for them -- lytspelify: $maxkeylen, $mapref, $consonants (?)
        # TODO Switch to a single populate_dict_from_csv method with create_key and create_value
        # callbacks (all files); probably switch to Text::xSV
        # TODO Switch to Struct::Dumb or maybe restricted hashes (Hash::Util)
        # instead of fixed-size lists
        # use Hash::Util 'lock_keys'; my $name = {first => 'Christian', last => 'Siefkes'}
        # lock_keys %$name; $name->{first} (OK); $name->{firs} (runtime error)
        # TODO Switch to "use 5.018" and "use autodie" (no need to check success of open and any
        # other commands) or "use autodie qw(:all)" (also checks system, exec)
        # TODO Maybe switch to experimental::signatures (or Function::Parameters)
        # TODO Switch to Dir::Self to locate PhonEng.pm
        # TODO Preferably use and/or instead of &&/|| to minimize the need for parentheses
        # TODO Use Switch::Plain if/where reasonable
    }

    close $outfh;

    warn_unprocessed_custom_entries;
    my $avg_dist = $SUMMED_DIST / $WORD_COUNT;
    say "Average distance between tradspell and Lytspel: $avg_dist";
}

# Main block
convert_dict;
