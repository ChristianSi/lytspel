#!/usr/bin/perl -CA
# Interactively select the best compound analysis among the candidates identified for each
# compound or derived word.
#
# Entries already in the output file are preserved rather than being overwritten.
# That allows interrupting the interactive use of this script and restarting it later.
#
# Copyright (c) 2015 Christian Siefkes
# See accompanying LICENSE file for licensing information.
#
# Required modules: Readonly and those listed in PhonEng.pm.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Cwd 'abs_path';
use FileHandle;
use File::Basename 'dirname';
use Readonly;
use Scalar::Util 'looks_like_number';

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

Readonly my $IN_FILE  => 'phonetic-dict-candidates.csv';
Readonly my $OUT_FILE => 'phonetic-dict.csv';

# read_existing_entries_or_write_header $fh, $csv: Return a set of all existing words listed in $fh,
# skipping the header line (if any). If $fh is an empty file, a header line is written into it. $fh
# must be a file handle opened in read/append mode.
sub read_existing_entries_or_write_header {
    my ($fh, $csv) = @_;
    my %words;
    seek $fh, 0, 0;
    my $colref = $csv->getline($fh);  # skip header line, if any

    if (!defined $colref) {
        $csv->print($fh, ['Traditional', 'POS', 'Phonetic', 'Redirect', 'Parts']);
    } else {
        while ($colref = $csv->getline($fh)) {
            my $word = $colref->[0];
            $words{$word} = 1;
        }
    }

    return \%words;
}

# trim $str: Removes whitespace from start and end of $str.
sub trim {
    my ($str) = @_;
    $str =~ s/^\s+//;
    $str =~ s/\s+$//;
    return $str;
}

# choose_alternative $word, @alternatives: Interactively let the user choose one of the
# alternatives. The chosen alternative is returned. The user also has the option to choose none of
# the alternatives (in which case an empty string is returned) or to enter the word parts manually.
# If the user wants to quit, undef is returned.
sub choose_alternative {
    my ($word, @alternatives) = @_;
    my $i = 1;
    my $query = "$word: ";

    for my $alt (@alternatives) {
        $query .= "($i) $alt  ";
        $i++;
    }

    $query .= '(0) NONE  (q) QUIT  (:...) ENTER PARTS';
    my $done = 0;

    while (1) {
        say $query;
        my $reply = <STDIN>;
        $reply = trim $reply;

        if (looks_like_number($reply) && 0 <= $reply && $reply < $i) {
            return '' if $reply == 0;
            return $alternatives[$reply - 1];
        } elsif (lc $reply eq 'q') {
            return undef;
        } elsif (lc $reply =~ /^:\s*(.*?)$/) {
            my $parts = split /-/, $1;
            if ($parts < 2) {
                say "Please specify two or more parts (separated by '-')";
                next;
            }
            return $1;
        }
    }
}

# process_entries: Process all entries in $IN_FILE.
sub process_entries {
    open my $infh, '<', $IN_FILE or die "Unable to open $IN_FILE: $!";
    my $incsv = new_csv_in;
    $incsv->getline($infh);  # skip header line
    open my $outfh, '+>>', $OUT_FILE or die "Unable to open $OUT_FILE for appending: $!";
    my $outcsv = new_csv_out;
    my $existing_entries = read_existing_entries_or_write_header $outfh, $outcsv;
    $outfh->autoflush(1);

    while (my $colref = $incsv->getline($infh)) {
        my $word = $colref->[0];
        next if $existing_entries->{$word};  # skip existing entries

        if (@$colref <= 4) {
            # Copy as is
            $outcsv->print($outfh, $colref);
        } else {
            # Let user choose an alternative
            my @initial = splice @$colref, 0, 4;
            my $chosen = choose_alternative $word, @$colref;

            if ($chosen) {
                push @initial, $chosen;
            } elsif (!defined $chosen) {
                last;  # undef signals that the user wants to quit
            }

            $outcsv->print($outfh, \@initial);
        }
    }

    close $infh;
    close $outfh;
}

# Main block
process_entries;
