#!/usr/bin/perl -CA
# Convert 'phonetic-dict.txt' into CSV format, also adding pronunciations generated by espeak.
#
# Copyright (c) 2016-17 Christian Siefkes
# See accompanying LICENSE.txt file for licensing information.
#
# Required modules: Const::Fast and those listed in PhonEng.pm.
# Required external programs (must be in path): espeak.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Const::Fast;
use Cwd 'abs_path';
use File::Basename 'dirname';

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

const my $IN_FILE     => 'phonetic-dict.txt';
const my $OUT_FILE    => 'phoneng-espeak-dict.csv';
const my $EXTRA_WORDS => 'extra-words.txt';
const my $TAGIFY_FILE => 'tagify.csv';
const my $ESPEAK_TMP  => 'espeak-in.tmp';

# File-scoped for convenient access
my $Csv_Out = new_csv_out;
my $Tagify_Dict_Ref = build_lc_map $TAGIFY_FILE, 0;

# read_dict: Reads the original phonetic dict into a hash. Returns a mapping
# from words (e.g. 'yeld', 'hectometre', 'detail') to the corresponding raw
# values (e.g. ': ye°ld', ':> hectometer', '/n: di°täl; v: ditä°l').
sub read_dict {
    open my $file, '<', $IN_FILE or die "Unable to open $IN_FILE: $!\n";
    my %dict;

    while (my $line = <$file>) {
        $line =~ m{^(['\w]+)([:/].*)$} or die "Invalid line: $line\n";
        my $word  = $1;
        my $value = $2;
        # Only add words with two or more letters as well as 'a' and 'I'
        $dict{$word} = $value if length $word > 1 || $word =~ /^[aI]$/i;
    }

    close $file;

    # Also add words listed in 'extra-words.txt' (relevant entries missing in the other
    # dictionaries)
    open my $extra_file, '<', $EXTRA_WORDS or die "Unable to open $EXTRA_WORDS: $!\n";

    while (my $word = <$extra_file>) {
        chomp $word;

        unless (exists $dict{$word}) {
            $dict{$word} = ':';  # Add as value-less simple entry
        } else {
            warn "Unnecessary entry in $EXTRA_WORDS: $word\n";
        }
    }

    close $extra_file;
    return \%dict;
}

# redirect_target $value: Resolves the redirect if $value is a redirect.
# Returns undef otherwise.
sub redirect_target {
    my ($value) = @_;
    return $value =~ /^:>\s+(.*)$/ ? $1 : undef;
}

# generate_tagged_espeak_input $espeak_fh, $word, $pos: Write a line to be pronounced by
# espeak where pronunciation depends on the POS tag of the word.
sub generate_tagged_espeak_input {
    my ($espeak_fh, $word, $pos) = @_;

    if ($pos eq 'v') {
        say $espeak_fh "to $word";
    } elsif ($pos eq 'n') {
        say $espeak_fh "the $word";
    } elsif ($pos eq 'aj') {
        say $espeak_fh "the $word loss";
    } elsif ($pos eq 'av') {
        say $espeak_fh "tell me $word";
    } elsif ($pos eq 'prp') {
        say $espeak_fh $word;  # espeak cannot properly distinguish this unique case anyway
    } else {
        die "Unknown POS tag: $pos\n";
    }
}

# prepare_espeak_input $espeak_fh, $word, $dict: Writes input to be pronounced by espeak.
# If the pronunciation of the word depends on its POS tag, several lines will be written,
# otherwise just one.
sub prepare_espeak_input {
    my ($espeak_fh, $word, $dict) = @_;
    my $value           = $dict->{$word};
    my $redirect_target = redirect_target $value;
    # TODO Delete entry
    my $tags     = $Tagify_Dict_Ref->{lc $word};
    my $phonetic = '';

    unless (defined $redirect_target) {  # Skip redirects
        if ($value =~ m{^/(.*)$} || $tags) {
            # TODO Suitably modify entry if listed in Tagify_Dict_Ref;
            # validate list of tags to ensure that all are valid and none is duplicate
            # Tagged entries
            for my $tagged_pron (split /;\s*/, $1) {
                if ($tagged_pron =~ /^(.*):\s*(.*)$/) {
                    generate_tagged_espeak_input $espeak_fh, $word, $1;
                } else {
                    die "Invalid line: $word$value\n";
                }
            }
        } elsif ($value =~ /^:\s*(.*)$/) {
            # Simple entry
            say $espeak_fh $word;
        } else {
            die "Invalid line: $word$value\n";
        }
    }
}

# strip_spaces $str: Removes whitespace from start and end of $str.
sub strip_spaces {
    my $str = shift // '';
    $str =~ s/^\s+//;
    $str =~ s/\s+$//;
    return $str;
}

# untag_espeak_output $line: Remove the pronunciations of tagging words such as 'to' or 'the'
# from the output generated by espeak.
sub untag_espeak_output {
    my $line = shift;
    $line =~ s/^(ðə|ðɪ|tə|tʊ|tˈɛl mˌiː) //;
    $line =~ s/ (lˈɒs|lˈɔs)$//;
    die "Unexcepted whitespace in espeak output '$line'" if $line =~ /\s/;
    return $line;
}

# write_entry $outfh, $word, $rp_pron_ref, $ga_pron_ref, $dict: Writes CSV entries for a word.
# If the pronunciation of the word depends on its POS tag, several CSV entries will
# be written, otherwise just one. $rp_pron_ref and $ga_pron_ref are array references to the British
# and American pronunciations of all remaining words as generated by espeak; the first entry or
# entries of these arrays will be consumed and the rest will be returned for subsequent calls.
sub write_entry {
    my ($outfh, $word, $rp_pron_ref, $ga_pron_ref, $dict) = @_;
    my $value           = $dict->{$word};
    my $redirect_target = redirect_target $value;
    my $phonetic        = '';

    if (defined $redirect_target) {
        # Redirect
        $Csv_Out->print($outfh, [$word, '', $redirect_target]);
    } else {
        if ($value =~ m{^/(.*)$} || $tags) {
            # Tagged entries
            for my $tagged_pron (split /;\s*/, $1) {
                if ($tagged_pron =~ /^(.*):\s*(.*)$/) {
                    my $rp = untag_espeak_output(shift @$rp_pron_ref);
                    my $ga = untag_espeak_output(shift @$ga_pron_ref);
                    $ga = '' if $ga eq $rp;  # Only print GA if different from RP
                    $Csv_Out->print($outfh, [$word, $1, '', $2, $rp, $ga]);
                } else {
                    die "Invalid line: $word$value\n";
                }
            }
        } elsif ($value =~ /^:\s*(.*)$/) {
            # Simple entry
            my $rp = shift @$rp_pron_ref;
            my $ga = shift @$ga_pron_ref;
            $ga = '' if $ga eq $rp;          # Only print GA if different from RP
            $Csv_Out->print($outfh, [$word, '', '', $1, $rp, $ga]);
        } else {
            die "Invalid line: $word$value\n";
        }
    }

    return $rp_pron_ref, $ga_pron_ref;
}

# Main block
say 'Preparing input for espeak';
my $dict = read_dict;
open my $espeak_fh, '>', $ESPEAK_TMP or die "Unable to open $ESPEAK_TMP for writing: $!\n";
prepare_espeak_input $espeak_fh, $_, $dict for sort { lc $a cmp lc $b } keys %$dict;
close $espeak_fh;
say 'Invoking espeak to generate British pronunciations';
my $rp_prons = `espeak -q --ipa < $ESPEAK_TMP`;
say 'Invoking espeak to generate American pronunciations';
my $ga_prons = `espeak -q --ipa -v en-us < $ESPEAK_TMP`;
unlink $ESPEAK_TMP;
say 'Generating final dictionary';
my $outfh = open_outfile_and_write_header $OUT_FILE, [qw(Traditional POS Redirect PhonEng RP GA)];
my $rp_pron_ref = [split /\s*\n\s*/, strip_spaces $rp_prons];
my $ga_pron_ref = [split /\s*\n\s*/, strip_spaces $ga_prons];
($rp_pron_ref, $ga_pron_ref) = write_entry $outfh, $_, $rp_pron_ref, $ga_pron_ref, $dict
    for sort { lc $a cmp lc $b } keys %$dict;
close $outfh;
# TODO Warn if Tagify_Dict_Ref is not empty, cf. warn_unprocessed_custom_entries
say 'Done';
