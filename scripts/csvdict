#!/usr/bin/perl -CA
# Convert 'phonetic-dict.txt' into CSV format, also adding pronunciations generated by espeak.
#
# Copyright (c) 2016-2020 Christian Siefkes
# See accompanying LICENSE.txt file for licensing information.
#
# Required modules: Const::Fast, List::MoreUtils, and those listed in PhonEng.pm.
# Required external programs (must be in path): espeak.

use 5.014;
use open qw(:std :utf8);  # use UTF-8 for all I/O (by default)
use utf8;                 # allow UTF-8 in source code
use warnings;

use Const::Fast;
use Cwd 'abs_path';
use File::Basename 'dirname';
use List::MoreUtils 'uniq';

use lib dirname(abs_path $0);  # to locate the PhonEng package
use PhonEng;

const my $IN_FILE  => 'phonetic-dict.txt';
const my $OUT_FILE => 'phoneng-espeak-dict.csv';

# Words listed here are added to the output dictionary. If a word listed here would
# otherwise be treated as an redirect, it is added as a normal entry instead.
# In other cases, adding words to this file that already exist in the input dictionary
# triggers a warning.
const my $EXTRA_WORDS => 'extra-words.txt';

# A listing of words for which multiple POS-tagged entries should be created.
# The first column contains the word (case-insensitive); the second the list
# of POS tags, '+'-separated (e.g. 'n+v').
const my $TAGIFY_FILE => 'tagify.csv';

# A single-column listing of words whose tags should be discarded. Instead of several tagged
# variants, just the first listed variant will be used.
const my $UNTAGIFY_FILE => 'untagify.csv';

const my $ESPEAK_TMP => 'espeak-in.tmp';

# File-scoped for convenient access
my $Csv_Out           = new_csv_out;
my $Tagify_Dict_Ref   = build_lc_map $TAGIFY_FILE, 0, 0;
my $Untagify_Dict_Ref = build_lc_map $UNTAGIFY_FILE, 0, 1;

# read_dict: Read the original phonetic dict into a hash. Returns a mapping
# from words (e.g. 'yeld', 'hectometre', 'detail') to the corresponding raw
# values (e.g. ': ye°ld', ':> hectometer', '/n: di°täl; v: ditä°l').
sub read_dict {
    open my $file, '<', $IN_FILE or die "Unable to open $IN_FILE: $!\n";
    my %dict;

    while (my $line = <$file>) {
        $line =~ m{^(['\w]+)([:/].*)$} or die "Invalid line: $line\n";
        my $word  = $1;
        my $value = $2;
        # Only add words with two or more letters as well as 'a' and 'I'
        $dict{$word} = $value if length $word > 1 || $word =~ /^[aI]$/i;
    }

    close $file;

    # Also add words listed in 'extra-words.txt' (relevant entries missing in the other
    # dictionaries)
    open my $extra_file, '<', $EXTRA_WORDS or die "Unable to open $EXTRA_WORDS: $!\n";

    while (my $word = <$extra_file>) {
        chomp $word;

        if (!exists $dict{$word} || redirect_target($dict{$word})) {
            # Word doesn't yet exist or is a redirect: add as value-less simple entry
            $dict{$word} = ':';
        } else {
            warn "Unnecessary entry in $EXTRA_WORDS: $word\n";
        }
    }

    close $extra_file;
    return \%dict;
}

# redirect_target $value: Resolve the redirect if $value is a redirect.
# Returns undef otherwise.
sub redirect_target {
    my ($value) = @_;
    return $value =~ /^:>\s+(.*)$/ ? $1 : undef;
}

# generate_tagged_espeak_input $espeak_fh, $word, $pos: Write a line to be pronounced by
# espeak where pronunciation depends on the POS tag of the word.
sub generate_tagged_espeak_input {
    my ($espeak_fh, $word, $pos) = @_;

    if ($pos eq 'v') {
        say $espeak_fh "to $word";
    } elsif ($pos eq 'n') {
        say $espeak_fh "the $word";
    } elsif ($pos eq 'aj') {
        say $espeak_fh "the $word loss";
    } elsif ($pos eq 'av') {
        say $espeak_fh "tell me $word";
    } elsif ($pos eq 'prp') {
        say $espeak_fh $word;  # espeak cannot properly distinguish this unique case anyway
    } else {
        die "Unknown POS tag: $pos\n";
    }
}

# prepare_espeak_input $espeak_fh, $word, $dict: Write input to be pronounced by espeak.
# If the pronunciation of the word depends on its POS tag, several lines will be written,
# otherwise just one.
sub prepare_espeak_input {
    my ($espeak_fh, $word, $dict) = @_;
    my $value           = $dict->{$word};
    my $redirect_target = redirect_target $value;
    my $tags            = delete $Tagify_Dict_Ref->{lc $word};
    my $drop_tags       = delete $Untagify_Dict_Ref->{lc $word};
    my $phonetic        = '';

    unless (defined $redirect_target) {  # Skip redirects
        if ($value =~ m{^/(.*)$} && !$drop_tags || defined $tags) {
            my (@taglist, $tagged_prons);

            if ($tags) {
                # We should create multiple POS-tagged entries for the word
                @taglist = sort(split /\+/, $tags);
                # The second word (excluding a trailing semicolon) is the (first) pronunciation
                # which we'll re-use for all tags; if the original entry was already tagged,
                # there will be additional pronunciations which we ignore
                my ($pron) = $value =~ /^\S+\s+([^\s;]+)/;
                $pron = '' unless $pron;  # default for extra words
                my $new_value = '/';

                # Sanity check
                die "No POS tags listed for $word in $TAGIFY_FILE: " unless @taglist;
                die "Duplicate POS tags listed for $word in $TAGIFY_FILE: "
                    unless uniq(@taglist) == @taglist;

                # Modify value (from ': PRON' to e.g. '/n: PRON; v: PRON')
                for my $tag (@taglist) {
                    if (valid_pos_tag $tag) {
                        $new_value .= "$tag: $pron; ";
                    } else {
                        die "Unexpected POS tag listed for $word in $TAGIFY_FILE: $tag";
                    }
                }

                # Update $value (omitting trailing '; ')
                $new_value = substr $new_value, 0, -2;
                $dict->{$word} = $new_value;
                $tagged_prons = substr $new_value, 1;
            } else {
                $tagged_prons = substr $value, 1;
            }

            for my $tagged_pron (split /;\s*/, $tagged_prons) {
                if ($tagged_pron =~ /^(.*):\s*(.*)$/) {
                    generate_tagged_espeak_input $espeak_fh, $word, $1;
                } else {
                    die "Invalid line: $word$value";
                }
            }
        } elsif ($value =~ /^:\s*(.*)$/ || $drop_tags) {
            # Entry is simple (untagged) or tags should be dropped
            say $espeak_fh $word;

            if ($drop_tags) {
                # Replace tagged by simple entry, keeping just the first pronunciation
                # (= the second word)
                my ($pron) = $value =~ /^\S+\s+([^\s;]+)/;
                if ($pron) {
                    $dict->{$word} = ": $pron";
                } else {
                    warn "Cannot untagify $word$value\n";
                }
            }

        } else {
            die "Invalid line: $word$value\n";
        }
    }
}

# strip_spaces $str: Remove whitespace from start and end of $str.
sub strip_spaces {
    my $str = shift // '';
    $str =~ s/^\s+//;
    $str =~ s/\s+$//;
    return $str;
}

# untag_espeak_output $line: Remove the pronunciations of tagging words such as 'to' or 'the'
# from the output generated by espeak.
sub untag_espeak_output {
    my $line = shift;
    $line =~ s/^(ðə|ðɪ|tə|tʊ|tˈɛl mˌiː) //;
    $line =~ s/ (lˈɒs|lˈɔs)$//;
    die "Unexcepted whitespace in espeak output '$line'" if $line =~ /\s/;
    return $line;
}

# Restore [ʍ], the voiceless labiovelar approximant, in a single pronunciation (either RP
# or GA).
sub restore_wh_in_pron {
    my ($pron, $word) = @_;
    my @ws_in_pron = ($pron =~ /w/g);
    # Match 'w' and 'wh', but not if preceeded by 'a' or 'o'
    my @ws_and_whs_in_word = ($word =~ /(?<![ao])wh?/g);

    if (scalar @ws_in_pron != scalar @ws_and_whs_in_word) {
        if (@ws_in_pron == 1 && @ws_and_whs_in_word == 0) {
            # The exclusion of 'aw' and 'ow' overmatches in a few words such as 'awhile'
            # and 'nowhere': restore [ʍ] nevertheless
            $pron =~ s/w/ʍ/;
        } elsif (@ws_in_pron == 1 && @ws_and_whs_in_word == 2) {
            # Restore [ʍ] also in words such as 'wheelwright' and 'wholewheat' where one
            # 'w[h]' is silent or pronounced [h]
            $pron =~ s/w/ʍ/;
        } else {
            # Rare (practically unknown) case not yet handled
            warn @ws_in_pron
                . " w's in pronunciation $pron, but "
                . @ws_and_whs_in_word
                . "w[h]'s in word $word";
        }
    } elsif (grep(/^w$/, @ws_and_whs_in_word)) {
        # 'w' occurs at least once, so we have to figure out which [w] becomes [ʍ]
        for my $match (@ws_and_whs_in_word) {
            if ($match eq 'wh') {
                $pron =~ s/w/ʍ/;
            } else {
                # Replace first [w] by [W], which doesn't occur in IPA – later we change it back
                $pron =~ s/w/W/;
            }

            $pron =~ s/W/w/g;
        }
    } else {
        # Since only 'wh' occurs, we change every [w] to [ʍ]
        $pron =~ s/w/ʍ/g;
    }

    return $pron;
}

# Restore [ʍ], the voiceless labiovelar approximant, typically written as 'wh' in tradspell.
# espeak ever emits this sounds, hence we detect its presence from the writing.
# $ga should be set to '' if it's identical to $rp.
# Returns $rp, $ga as modified, if needed (otherwise they are returned unchanged).
sub restore_wh {
    my ($rp, $ga, $word) = @_;
    $word = lc $word;
    if ($rp =~ /w/ && $word =~ /wh/) {
        $rp = restore_wh_in_pron $rp, $word;
        $ga = restore_wh_in_pron $ga, $word if $ga;
    }
    return $rp, $ga;
}

# write_entry $outfh, $word, $rp_pron_ref, $ga_pron_ref, $dict: Write CSV entries for a word.
# If the pronunciation of the word depends on its POS tag, several CSV entries will
# be written, otherwise just one. $rp_pron_ref and $ga_pron_ref are array references to the British
# and American pronunciations of all remaining words as generated by espeak; the first entry or
# entries of these arrays will be consumed and the rest will be returned for subsequent calls.
sub write_entry {
    my ($outfh, $word, $rp_pron_ref, $ga_pron_ref, $dict) = @_;
    my $value           = $dict->{$word};
    my $redirect_target = redirect_target $value;
    my $phonetic        = '';

    if (defined $redirect_target) {
        # Redirect
        $Csv_Out->print($outfh, [$word, '', $redirect_target]);
    } else {
        if ($value =~ m{^/(.*)$}) {
            # Tagged entries
            for my $tagged_pron (split /;\s*/, $1) {
                if ($tagged_pron =~ /^(.*):\s*(.*)$/) {
                    my $rp = untag_espeak_output(shift @$rp_pron_ref);
                    my $ga = untag_espeak_output(shift @$ga_pron_ref);
                    $ga = '' if $ga eq $rp;  # Only print GA if different from RP
                    ($rp, $ga) = restore_wh $rp, $ga, $word;
                    $Csv_Out->print($outfh, [$word, $1, '', $2, $rp, $ga]);
                } else {
                    die "Invalid line: $word$value\n";
                }
            }
        } elsif ($value =~ /^:\s*(.*)$/) {
            # Simple entry
            my $rp = shift @$rp_pron_ref;
            my $ga = shift @$ga_pron_ref;
            $ga = '' if $ga eq $rp;          # Only print GA if different from RP
            ($rp, $ga) = restore_wh $rp, $ga, $word;
            $Csv_Out->print($outfh, [$word, '', '', $1, $rp, $ga]);
        } else {
            die "Invalid line: $word$value\n";
        }
    }

    return $rp_pron_ref, $ga_pron_ref;
}

# build_csv_dict: Convert 'phonetic-dict.txt' into CSV format, also adding pronunciations
# generated by espeak.
sub build_csv_dict {
    say 'Preparing input for espeak';
    my $dict = read_dict;
    open my $espeak_fh, '>', $ESPEAK_TMP or die "Unable to open $ESPEAK_TMP for writing: $!\n";
    prepare_espeak_input $espeak_fh, $_, $dict for sort { lc $a cmp lc $b } keys %$dict;
    close $espeak_fh;
    say 'Invoking espeak to generate British pronunciations';
    my $rp_prons = `espeak -q --ipa < $ESPEAK_TMP`;
    say 'Invoking espeak to generate American pronunciations';
    my $ga_prons = `espeak -q --ipa -v en-us < $ESPEAK_TMP`;
    unlink $ESPEAK_TMP;
    say 'Generating final dictionary';
    my $outfh = open_outfile_and_write_header $OUT_FILE,
        [qw(Traditional POS Redirect PhonEng RP GA)];
    my $rp_pron_ref = [split /\s*\n\s*/, strip_spaces $rp_prons];
    my $ga_pron_ref = [split /\s*\n\s*/, strip_spaces $ga_prons];
    ($rp_pron_ref, $ga_pron_ref) = write_entry $outfh, $_, $rp_pron_ref, $ga_pron_ref, $dict
        for sort { lc $a cmp lc $b } keys %$dict;
    close $outfh;

    # Warn if there are any Tagify_Dict_Ref or Untagify_Dict_Ref entries left
    warn "Unused $TAGIFY_FILE entry: $_\n"   for sort keys %$Tagify_Dict_Ref;
    warn "Unused $UNTAGIFY_FILE entry: $_\n" for sort keys %$Untagify_Dict_Ref;
    say 'Done';
}

# Main block
build_csv_dict
